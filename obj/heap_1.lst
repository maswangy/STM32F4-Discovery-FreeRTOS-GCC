   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"heap_1.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.ucHeap,"aw",%nobits
  20              		.align	2
  23              	ucHeap:
  24 0000 00000000 		.space	76800
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.section	.bss.xNextFreeByte,"aw",%nobits
  26              		.align	2
  29              	xNextFreeByte:
  30 0000 00000000 		.space	4
  31              		.section	.text.pvPortMalloc,"ax",%progbits
  32              		.align	2
  33              		.global	pvPortMalloc
  34              		.thumb
  35              		.thumb_func
  37              	pvPortMalloc:
  38              	.LFB110:
  39              		.file 1 "Source/portable/MemMang/heap_1.c"
   1:Source/portable/MemMang/heap_1.c **** /*
   2:Source/portable/MemMang/heap_1.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/portable/MemMang/heap_1.c ****     All rights reserved
   4:Source/portable/MemMang/heap_1.c **** 
   5:Source/portable/MemMang/heap_1.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/portable/MemMang/heap_1.c **** 
   7:Source/portable/MemMang/heap_1.c ****     ***************************************************************************
   8:Source/portable/MemMang/heap_1.c ****      *                                                                       *
   9:Source/portable/MemMang/heap_1.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/portable/MemMang/heap_1.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/portable/MemMang/heap_1.c ****      *    platform software that has become a de facto standard.             *
  12:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  13:Source/portable/MemMang/heap_1.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/portable/MemMang/heap_1.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/portable/MemMang/heap_1.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  17:Source/portable/MemMang/heap_1.c ****      *    Thank you!                                                         *
  18:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  19:Source/portable/MemMang/heap_1.c ****     ***************************************************************************
  20:Source/portable/MemMang/heap_1.c **** 
  21:Source/portable/MemMang/heap_1.c ****     This file is part of the FreeRTOS distribution.
  22:Source/portable/MemMang/heap_1.c **** 
  23:Source/portable/MemMang/heap_1.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/portable/MemMang/heap_1.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/portable/MemMang/heap_1.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/portable/MemMang/heap_1.c **** 
  27:Source/portable/MemMang/heap_1.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/portable/MemMang/heap_1.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/portable/MemMang/heap_1.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/portable/MemMang/heap_1.c ****     >>! kernel.
  31:Source/portable/MemMang/heap_1.c **** 
  32:Source/portable/MemMang/heap_1.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/portable/MemMang/heap_1.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/portable/MemMang/heap_1.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/portable/MemMang/heap_1.c ****     link: http://www.freertos.org/a00114.html
  36:Source/portable/MemMang/heap_1.c **** 
  37:Source/portable/MemMang/heap_1.c ****     1 tab == 4 spaces!
  38:Source/portable/MemMang/heap_1.c **** 
  39:Source/portable/MemMang/heap_1.c ****     ***************************************************************************
  40:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  41:Source/portable/MemMang/heap_1.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/portable/MemMang/heap_1.c ****      *    not run, what could be wrong?"                                     *
  43:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  44:Source/portable/MemMang/heap_1.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/portable/MemMang/heap_1.c ****      *                                                                       *
  46:Source/portable/MemMang/heap_1.c ****     ***************************************************************************
  47:Source/portable/MemMang/heap_1.c **** 
  48:Source/portable/MemMang/heap_1.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/portable/MemMang/heap_1.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/portable/MemMang/heap_1.c **** 
  51:Source/portable/MemMang/heap_1.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/portable/MemMang/heap_1.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/portable/MemMang/heap_1.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/portable/MemMang/heap_1.c **** 
  55:Source/portable/MemMang/heap_1.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/portable/MemMang/heap_1.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/portable/MemMang/heap_1.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/portable/MemMang/heap_1.c **** 
  59:Source/portable/MemMang/heap_1.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/portable/MemMang/heap_1.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/portable/MemMang/heap_1.c ****     mission critical applications that require provable dependability.
  62:Source/portable/MemMang/heap_1.c **** 
  63:Source/portable/MemMang/heap_1.c ****     1 tab == 4 spaces!
  64:Source/portable/MemMang/heap_1.c **** */
  65:Source/portable/MemMang/heap_1.c **** 
  66:Source/portable/MemMang/heap_1.c **** 
  67:Source/portable/MemMang/heap_1.c **** /*
  68:Source/portable/MemMang/heap_1.c ****  * The simplest possible implementation of pvPortMalloc().  Note that this
  69:Source/portable/MemMang/heap_1.c ****  * implementation does NOT allow allocated memory to be freed again.
  70:Source/portable/MemMang/heap_1.c ****  *
  71:Source/portable/MemMang/heap_1.c ****  * See heap_2.c, heap_3.c and heap_4.c for alternative implementations, and the
  72:Source/portable/MemMang/heap_1.c ****  * memory management pages of http://www.FreeRTOS.org for more information.
  73:Source/portable/MemMang/heap_1.c ****  */
  74:Source/portable/MemMang/heap_1.c **** #include <stdlib.h>
  75:Source/portable/MemMang/heap_1.c **** 
  76:Source/portable/MemMang/heap_1.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  77:Source/portable/MemMang/heap_1.c **** all the API functions to use the MPU wrappers.  That should only be done when
  78:Source/portable/MemMang/heap_1.c **** task.h is included from an application file. */
  79:Source/portable/MemMang/heap_1.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  80:Source/portable/MemMang/heap_1.c **** 
  81:Source/portable/MemMang/heap_1.c **** #include "FreeRTOS.h"
  82:Source/portable/MemMang/heap_1.c **** #include "task.h"
  83:Source/portable/MemMang/heap_1.c **** 
  84:Source/portable/MemMang/heap_1.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  85:Source/portable/MemMang/heap_1.c **** 
  86:Source/portable/MemMang/heap_1.c **** /* A few bytes might be lost to byte aligning the heap start address. */
  87:Source/portable/MemMang/heap_1.c **** #define configADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
  88:Source/portable/MemMang/heap_1.c **** 
  89:Source/portable/MemMang/heap_1.c **** /* Allocate the memory for the heap. */
  90:Source/portable/MemMang/heap_1.c **** static unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
  91:Source/portable/MemMang/heap_1.c **** static size_t xNextFreeByte = ( size_t ) 0;
  92:Source/portable/MemMang/heap_1.c **** 
  93:Source/portable/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
  94:Source/portable/MemMang/heap_1.c **** 
  95:Source/portable/MemMang/heap_1.c **** void *pvPortMalloc( size_t xWantedSize )
  96:Source/portable/MemMang/heap_1.c **** {
  40              		.loc 1 96 0
  41              		.cfi_startproc
  42              		@ args = 0, pretend = 0, frame = 16
  43              		@ frame_needed = 1, uses_anonymous_args = 0
  44 0000 80B5     		push	{r7, lr}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 8
  47              		.cfi_offset 7, -8
  48              		.cfi_offset 14, -4
  49 0002 84B0     		sub	sp, sp, #16
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 24
  52 0004 00AF     		add	r7, sp, #0
  53              	.LCFI2:
  54              		.cfi_def_cfa_register 7
  55 0006 7860     		str	r0, [r7, #4]
  97:Source/portable/MemMang/heap_1.c **** void *pvReturn = NULL;
  56              		.loc 1 97 0
  57 0008 4FF00003 		mov	r3, #0
  58 000c FB60     		str	r3, [r7, #12]
  98:Source/portable/MemMang/heap_1.c **** static unsigned char *pucAlignedHeap = NULL;
  99:Source/portable/MemMang/heap_1.c **** 
 100:Source/portable/MemMang/heap_1.c **** 	/* Ensure that blocks are always aligned to the required number of bytes. */
 101:Source/portable/MemMang/heap_1.c **** 	#if portBYTE_ALIGNMENT != 1
 102:Source/portable/MemMang/heap_1.c **** 		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  59              		.loc 1 102 0
  60 000e 7B68     		ldr	r3, [r7, #4]
  61 0010 03F00703 		and	r3, r3, #7
  62 0014 002B     		cmp	r3, #0
  63 0016 05D0     		beq	.L2
 103:Source/portable/MemMang/heap_1.c **** 		{
 104:Source/portable/MemMang/heap_1.c **** 			/* Byte alignment required. */
 105:Source/portable/MemMang/heap_1.c **** 			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  64              		.loc 1 105 0
  65 0018 7B68     		ldr	r3, [r7, #4]
  66 001a 23F00703 		bic	r3, r3, #7
  67 001e 03F10803 		add	r3, r3, #8
  68 0022 7B60     		str	r3, [r7, #4]
  69              	.L2:
 106:Source/portable/MemMang/heap_1.c **** 		}
 107:Source/portable/MemMang/heap_1.c **** 	#endif
 108:Source/portable/MemMang/heap_1.c **** 
 109:Source/portable/MemMang/heap_1.c **** 	vTaskSuspendAll();
  70              		.loc 1 109 0
  71 0024 FFF7FEFF 		bl	vTaskSuspendAll
 110:Source/portable/MemMang/heap_1.c **** 	{
 111:Source/portable/MemMang/heap_1.c **** 		if( pucAlignedHeap == NULL )
  72              		.loc 1 111 0
  73 0028 40F20003 		movw	r3, #:lower16:pucAlignedHeap.8082
  74 002c C0F20003 		movt	r3, #:upper16:pucAlignedHeap.8082
  75 0030 1B68     		ldr	r3, [r3, #0]
  76 0032 002B     		cmp	r3, #0
  77 0034 08D1     		bne	.L3
 112:Source/portable/MemMang/heap_1.c **** 		{
 113:Source/portable/MemMang/heap_1.c **** 			/* Ensure the heap starts on a correctly aligned boundary. */
 114:Source/portable/MemMang/heap_1.c **** 			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ]
  78              		.loc 1 114 0
  79 0036 244B     		ldr	r3, .L7
  80 0038 23F00703 		bic	r3, r3, #7
  81 003c 1A46     		mov	r2, r3
  82 003e 40F20003 		movw	r3, #:lower16:pucAlignedHeap.8082
  83 0042 C0F20003 		movt	r3, #:upper16:pucAlignedHeap.8082
  84 0046 1A60     		str	r2, [r3, #0]
  85              	.L3:
 115:Source/portable/MemMang/heap_1.c **** 		}
 116:Source/portable/MemMang/heap_1.c **** 
 117:Source/portable/MemMang/heap_1.c **** 		/* Check there is enough room left for the allocation. */
 118:Source/portable/MemMang/heap_1.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  86              		.loc 1 118 0
  87 0048 40F20003 		movw	r3, #:lower16:xNextFreeByte
  88 004c C0F20003 		movt	r3, #:upper16:xNextFreeByte
  89 0050 1A68     		ldr	r2, [r3, #0]
  90 0052 7B68     		ldr	r3, [r7, #4]
  91 0054 D218     		adds	r2, r2, r3
  92 0056 42F6F733 		movw	r3, #11255
  93 005a C0F20103 		movt	r3, 1
  94 005e 9A42     		cmp	r2, r3
  95 0060 25D8     		bhi	.L4
 119:Source/portable/MemMang/heap_1.c **** 			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
  96              		.loc 1 119 0 discriminator 1
  97 0062 40F20003 		movw	r3, #:lower16:xNextFreeByte
  98 0066 C0F20003 		movt	r3, #:upper16:xNextFreeByte
  99 006a 1A68     		ldr	r2, [r3, #0]
 100 006c 7B68     		ldr	r3, [r7, #4]
 101 006e D218     		adds	r2, r2, r3
 102 0070 40F20003 		movw	r3, #:lower16:xNextFreeByte
 103 0074 C0F20003 		movt	r3, #:upper16:xNextFreeByte
 104 0078 1B68     		ldr	r3, [r3, #0]
 118:Source/portable/MemMang/heap_1.c **** 		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 105              		.loc 1 118 0 discriminator 1
 106 007a 9A42     		cmp	r2, r3
 107 007c 17D9     		bls	.L4
 120:Source/portable/MemMang/heap_1.c **** 		{
 121:Source/portable/MemMang/heap_1.c **** 			/* Return the next free byte then increment the index past this
 122:Source/portable/MemMang/heap_1.c **** 			block. */
 123:Source/portable/MemMang/heap_1.c **** 			pvReturn = pucAlignedHeap + xNextFreeByte;
 108              		.loc 1 123 0
 109 007e 40F20003 		movw	r3, #:lower16:pucAlignedHeap.8082
 110 0082 C0F20003 		movt	r3, #:upper16:pucAlignedHeap.8082
 111 0086 1A68     		ldr	r2, [r3, #0]
 112 0088 40F20003 		movw	r3, #:lower16:xNextFreeByte
 113 008c C0F20003 		movt	r3, #:upper16:xNextFreeByte
 114 0090 1B68     		ldr	r3, [r3, #0]
 115 0092 D318     		adds	r3, r2, r3
 116 0094 FB60     		str	r3, [r7, #12]
 124:Source/portable/MemMang/heap_1.c **** 			xNextFreeByte += xWantedSize;
 117              		.loc 1 124 0
 118 0096 40F20003 		movw	r3, #:lower16:xNextFreeByte
 119 009a C0F20003 		movt	r3, #:upper16:xNextFreeByte
 120 009e 1A68     		ldr	r2, [r3, #0]
 121 00a0 7B68     		ldr	r3, [r7, #4]
 122 00a2 D218     		adds	r2, r2, r3
 123 00a4 40F20003 		movw	r3, #:lower16:xNextFreeByte
 124 00a8 C0F20003 		movt	r3, #:upper16:xNextFreeByte
 125 00ac 1A60     		str	r2, [r3, #0]
 126              	.L4:
 125:Source/portable/MemMang/heap_1.c **** 		}
 126:Source/portable/MemMang/heap_1.c **** 
 127:Source/portable/MemMang/heap_1.c **** 		traceMALLOC( pvReturn, xWantedSize );
 128:Source/portable/MemMang/heap_1.c **** 	}	
 129:Source/portable/MemMang/heap_1.c **** 	xTaskResumeAll();
 127              		.loc 1 129 0
 128 00ae FFF7FEFF 		bl	xTaskResumeAll
 130:Source/portable/MemMang/heap_1.c **** 
 131:Source/portable/MemMang/heap_1.c **** 	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
 132:Source/portable/MemMang/heap_1.c **** 	{
 133:Source/portable/MemMang/heap_1.c **** 		if( pvReturn == NULL )
 129              		.loc 1 133 0
 130 00b2 FB68     		ldr	r3, [r7, #12]
 131 00b4 002B     		cmp	r3, #0
 132 00b6 01D1     		bne	.L5
 133              	.LBB2:
 134:Source/portable/MemMang/heap_1.c **** 		{
 135:Source/portable/MemMang/heap_1.c **** 			extern void vApplicationMallocFailedHook( void );
 136:Source/portable/MemMang/heap_1.c **** 			vApplicationMallocFailedHook();
 134              		.loc 1 136 0
 135 00b8 FFF7FEFF 		bl	vApplicationMallocFailedHook
 136              	.L5:
 137              	.LBE2:
 137:Source/portable/MemMang/heap_1.c **** 		}
 138:Source/portable/MemMang/heap_1.c **** 	}
 139:Source/portable/MemMang/heap_1.c **** 	#endif
 140:Source/portable/MemMang/heap_1.c **** 
 141:Source/portable/MemMang/heap_1.c **** 	return pvReturn;
 138              		.loc 1 141 0
 139 00bc FB68     		ldr	r3, [r7, #12]
 142:Source/portable/MemMang/heap_1.c **** }
 140              		.loc 1 142 0
 141 00be 1846     		mov	r0, r3
 142 00c0 07F11007 		add	r7, r7, #16
 143 00c4 BD46     		mov	sp, r7
 144 00c6 80BD     		pop	{r7, pc}
 145              	.L8:
 146              		.align	2
 147              	.L7:
 148 00c8 08000000 		.word	ucHeap+8
 149              		.cfi_endproc
 150              	.LFE110:
 152              		.section	.text.vPortFree,"ax",%progbits
 153              		.align	2
 154              		.global	vPortFree
 155              		.thumb
 156              		.thumb_func
 158              	vPortFree:
 159              	.LFB111:
 143:Source/portable/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 144:Source/portable/MemMang/heap_1.c **** 
 145:Source/portable/MemMang/heap_1.c **** void vPortFree( void *pv )
 146:Source/portable/MemMang/heap_1.c **** {
 160              		.loc 1 146 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 8
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164 0000 80B5     		push	{r7, lr}
 165              	.LCFI3:
 166              		.cfi_def_cfa_offset 8
 167              		.cfi_offset 7, -8
 168              		.cfi_offset 14, -4
 169 0002 82B0     		sub	sp, sp, #8
 170              	.LCFI4:
 171              		.cfi_def_cfa_offset 16
 172 0004 00AF     		add	r7, sp, #0
 173              	.LCFI5:
 174              		.cfi_def_cfa_register 7
 175 0006 7860     		str	r0, [r7, #4]
 147:Source/portable/MemMang/heap_1.c **** 	/* Memory cannot be freed using this scheme.  See heap_2.c, heap_3.c and
 148:Source/portable/MemMang/heap_1.c **** 	heap_4.c for alternative implementations, and the memory management pages of
 149:Source/portable/MemMang/heap_1.c **** 	http://www.FreeRTOS.org for more information. */
 150:Source/portable/MemMang/heap_1.c **** 	( void ) pv;
 151:Source/portable/MemMang/heap_1.c **** 
 152:Source/portable/MemMang/heap_1.c **** 	/* Force an assert as it is invalid to call this function. */
 153:Source/portable/MemMang/heap_1.c **** 	configASSERT( pv == NULL );
 176              		.loc 1 153 0
 177 0008 7B68     		ldr	r3, [r7, #4]
 178 000a 002B     		cmp	r3, #0
 179 000c 02D0     		beq	.L9
 180              		.loc 1 153 0 is_stmt 0 discriminator 1
 181 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 182              	.L11:
 183              		.loc 1 153 0 discriminator 2
 184 0012 FEE7     		b	.L11
 185              	.L9:
 154:Source/portable/MemMang/heap_1.c **** }
 186              		.loc 1 154 0 is_stmt 1
 187 0014 07F10807 		add	r7, r7, #8
 188 0018 BD46     		mov	sp, r7
 189 001a 80BD     		pop	{r7, pc}
 190              		.cfi_endproc
 191              	.LFE111:
 193              		.section	.text.vPortInitialiseBlocks,"ax",%progbits
 194              		.align	2
 195              		.global	vPortInitialiseBlocks
 196              		.thumb
 197              		.thumb_func
 199              	vPortInitialiseBlocks:
 200              	.LFB112:
 155:Source/portable/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 156:Source/portable/MemMang/heap_1.c **** 
 157:Source/portable/MemMang/heap_1.c **** void vPortInitialiseBlocks( void )
 158:Source/portable/MemMang/heap_1.c **** {
 201              		.loc 1 158 0
 202              		.cfi_startproc
 203              		@ args = 0, pretend = 0, frame = 0
 204              		@ frame_needed = 1, uses_anonymous_args = 0
 205              		@ link register save eliminated.
 206 0000 80B4     		push	{r7}
 207              	.LCFI6:
 208              		.cfi_def_cfa_offset 4
 209              		.cfi_offset 7, -4
 210 0002 00AF     		add	r7, sp, #0
 211              	.LCFI7:
 212              		.cfi_def_cfa_register 7
 159:Source/portable/MemMang/heap_1.c **** 	/* Only required when static memory is not cleared. */
 160:Source/portable/MemMang/heap_1.c **** 	xNextFreeByte = ( size_t ) 0;
 213              		.loc 1 160 0
 214 0004 40F20003 		movw	r3, #:lower16:xNextFreeByte
 215 0008 C0F20003 		movt	r3, #:upper16:xNextFreeByte
 216 000c 4FF00002 		mov	r2, #0
 217 0010 1A60     		str	r2, [r3, #0]
 161:Source/portable/MemMang/heap_1.c **** }
 218              		.loc 1 161 0
 219 0012 BD46     		mov	sp, r7
 220 0014 80BC     		pop	{r7}
 221 0016 7047     		bx	lr
 222              		.cfi_endproc
 223              	.LFE112:
 225              		.section	.text.xPortGetFreeHeapSize,"ax",%progbits
 226              		.align	2
 227              		.global	xPortGetFreeHeapSize
 228              		.thumb
 229              		.thumb_func
 231              	xPortGetFreeHeapSize:
 232              	.LFB113:
 162:Source/portable/MemMang/heap_1.c **** /*-----------------------------------------------------------*/
 163:Source/portable/MemMang/heap_1.c **** 
 164:Source/portable/MemMang/heap_1.c **** size_t xPortGetFreeHeapSize( void )
 165:Source/portable/MemMang/heap_1.c **** {
 233              		.loc 1 165 0
 234              		.cfi_startproc
 235              		@ args = 0, pretend = 0, frame = 0
 236              		@ frame_needed = 1, uses_anonymous_args = 0
 237              		@ link register save eliminated.
 238 0000 80B4     		push	{r7}
 239              	.LCFI8:
 240              		.cfi_def_cfa_offset 4
 241              		.cfi_offset 7, -4
 242 0002 00AF     		add	r7, sp, #0
 243              	.LCFI9:
 244              		.cfi_def_cfa_register 7
 166:Source/portable/MemMang/heap_1.c **** 	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 245              		.loc 1 166 0
 246 0004 40F20003 		movw	r3, #:lower16:xNextFreeByte
 247 0008 C0F20003 		movt	r3, #:upper16:xNextFreeByte
 248 000c 1B68     		ldr	r3, [r3, #0]
 249 000e C3F59533 		rsb	r3, r3, #76288
 250 0012 03F5FC73 		add	r3, r3, #504
 167:Source/portable/MemMang/heap_1.c **** }
 251              		.loc 1 167 0
 252 0016 1846     		mov	r0, r3
 253 0018 BD46     		mov	sp, r7
 254 001a 80BC     		pop	{r7}
 255 001c 7047     		bx	lr
 256              		.cfi_endproc
 257              	.LFE113:
 259 001e 00BF     		.section	.bss.pucAlignedHeap.8082,"aw",%nobits
 260              		.align	2
 263              	pucAlignedHeap.8082:
 264 0000 00000000 		.space	4
 265              		.text
 266              	.Letext0:
 267              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 268              		.file 3 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 269              		.file 4 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 heap_1.c
     /tmp/cc3Nw8V2.s:20     .bss.ucHeap:00000000 $d
     /tmp/cc3Nw8V2.s:23     .bss.ucHeap:00000000 ucHeap
     /tmp/cc3Nw8V2.s:26     .bss.xNextFreeByte:00000000 $d
     /tmp/cc3Nw8V2.s:29     .bss.xNextFreeByte:00000000 xNextFreeByte
     /tmp/cc3Nw8V2.s:32     .text.pvPortMalloc:00000000 $t
     /tmp/cc3Nw8V2.s:37     .text.pvPortMalloc:00000000 pvPortMalloc
     /tmp/cc3Nw8V2.s:263    .bss.pucAlignedHeap.8082:00000000 pucAlignedHeap.8082
     /tmp/cc3Nw8V2.s:148    .text.pvPortMalloc:000000c8 $d
     /tmp/cc3Nw8V2.s:153    .text.vPortFree:00000000 $t
     /tmp/cc3Nw8V2.s:158    .text.vPortFree:00000000 vPortFree
     /tmp/cc3Nw8V2.s:194    .text.vPortInitialiseBlocks:00000000 $t
     /tmp/cc3Nw8V2.s:199    .text.vPortInitialiseBlocks:00000000 vPortInitialiseBlocks
     /tmp/cc3Nw8V2.s:226    .text.xPortGetFreeHeapSize:00000000 $t
     /tmp/cc3Nw8V2.s:231    .text.xPortGetFreeHeapSize:00000000 xPortGetFreeHeapSize
     /tmp/cc3Nw8V2.s:260    .bss.pucAlignedHeap.8082:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vTaskSuspendAll
xTaskResumeAll
vApplicationMallocFailedHook
ulPortSetInterruptMask
