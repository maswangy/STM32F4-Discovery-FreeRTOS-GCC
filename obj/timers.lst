   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"timers.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xActiveTimerList1,"aw",%nobits
  20              		.align	2
  23              	xActiveTimerList1:
  24 0000 00000000 		.space	20
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.section	.bss.xActiveTimerList2,"aw",%nobits
  26              		.align	2
  29              	xActiveTimerList2:
  30 0000 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.bss.pxCurrentTimerList,"aw",%nobits
  32              		.align	2
  35              	pxCurrentTimerList:
  36 0000 00000000 		.space	4
  37              		.section	.bss.pxOverflowTimerList,"aw",%nobits
  38              		.align	2
  41              	pxOverflowTimerList:
  42 0000 00000000 		.space	4
  43              		.section	.bss.xTimerQueue,"aw",%nobits
  44              		.align	2
  47              	xTimerQueue:
  48 0000 00000000 		.space	4
  49              		.section	.rodata
  50              		.align	2
  51              	.LC0:
  52 0000 546D7220 		.ascii	"Tmr Svc\000"
  52      53766300 
  53              		.section	.text.xTimerCreateTimerTask,"ax",%progbits
  54              		.align	2
  55              		.global	xTimerCreateTimerTask
  56              		.thumb
  57              		.thumb_func
  59              	xTimerCreateTimerTask:
  60              	.LFB110:
  61              		.file 1 "Source/timers.c"
   1:Source/timers.c **** /*
   2:Source/timers.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/timers.c ****     All rights reserved
   4:Source/timers.c **** 
   5:Source/timers.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/timers.c **** 
   7:Source/timers.c ****     ***************************************************************************
   8:Source/timers.c ****      *                                                                       *
   9:Source/timers.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/timers.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/timers.c ****      *    platform software that has become a de facto standard.             *
  12:Source/timers.c ****      *                                                                       *
  13:Source/timers.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/timers.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/timers.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/timers.c ****      *                                                                       *
  17:Source/timers.c ****      *    Thank you!                                                         *
  18:Source/timers.c ****      *                                                                       *
  19:Source/timers.c ****     ***************************************************************************
  20:Source/timers.c **** 
  21:Source/timers.c ****     This file is part of the FreeRTOS distribution.
  22:Source/timers.c **** 
  23:Source/timers.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/timers.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/timers.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/timers.c **** 
  27:Source/timers.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/timers.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/timers.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/timers.c ****     >>! kernel.
  31:Source/timers.c **** 
  32:Source/timers.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/timers.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/timers.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/timers.c ****     link: http://www.freertos.org/a00114.html
  36:Source/timers.c **** 
  37:Source/timers.c ****     1 tab == 4 spaces!
  38:Source/timers.c **** 
  39:Source/timers.c ****     ***************************************************************************
  40:Source/timers.c ****      *                                                                       *
  41:Source/timers.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/timers.c ****      *    not run, what could be wrong?"                                     *
  43:Source/timers.c ****      *                                                                       *
  44:Source/timers.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/timers.c ****      *                                                                       *
  46:Source/timers.c ****     ***************************************************************************
  47:Source/timers.c **** 
  48:Source/timers.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/timers.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/timers.c **** 
  51:Source/timers.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/timers.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/timers.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/timers.c **** 
  55:Source/timers.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/timers.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/timers.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/timers.c **** 
  59:Source/timers.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/timers.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/timers.c ****     mission critical applications that require provable dependability.
  62:Source/timers.c **** 
  63:Source/timers.c ****     1 tab == 4 spaces!
  64:Source/timers.c **** */
  65:Source/timers.c **** 
  66:Source/timers.c **** /* Standard includes. */
  67:Source/timers.c **** #include <stdlib.h>
  68:Source/timers.c **** 
  69:Source/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:Source/timers.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:Source/timers.c **** task.h is included from an application file. */
  72:Source/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:Source/timers.c **** 
  74:Source/timers.c **** #include "FreeRTOS.h"
  75:Source/timers.c **** #include "task.h"
  76:Source/timers.c **** #include "queue.h"
  77:Source/timers.c **** #include "timers.h"
  78:Source/timers.c **** 
  79:Source/timers.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  80:Source/timers.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  81:Source/timers.c **** header files above, but not in this file, in order to generate the correct
  82:Source/timers.c **** privileged Vs unprivileged linkage and placement. */
  83:Source/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  84:Source/timers.c **** 
  85:Source/timers.c **** 
  86:Source/timers.c **** /* This entire source file will be skipped if the application is not configured
  87:Source/timers.c **** to include software timer functionality.  This #if is closed at the very bottom
  88:Source/timers.c **** of this file.  If you want to include software timer functionality then ensure
  89:Source/timers.c **** configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  90:Source/timers.c **** #if ( configUSE_TIMERS == 1 )
  91:Source/timers.c **** 
  92:Source/timers.c **** /* Misc definitions. */
  93:Source/timers.c **** #define tmrNO_DELAY		( portTickType ) 0U
  94:Source/timers.c **** 
  95:Source/timers.c **** /* The definition of the timers themselves. */
  96:Source/timers.c **** typedef struct tmrTimerControl
  97:Source/timers.c **** {
  98:Source/timers.c **** 	const signed char		*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included 
  99:Source/timers.c **** 	xListItem				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for ev
 100:Source/timers.c **** 	portTickType			xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
 101:Source/timers.c **** 	unsigned portBASE_TYPE	uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically rest
 102:Source/timers.c **** 	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified 
 103:Source/timers.c **** 	tmrTIMER_CALLBACK		pxCallbackFunction;	/*<< The function that will be called when the timer expire
 104:Source/timers.c **** } xTIMER;
 105:Source/timers.c **** 
 106:Source/timers.c **** /* The definition of messages that can be sent and received on the timer
 107:Source/timers.c **** queue. */
 108:Source/timers.c **** typedef struct tmrTimerQueueMessage
 109:Source/timers.c **** {
 110:Source/timers.c **** 	portBASE_TYPE			xMessageID;			/*<< The command being sent to the timer service task. */
 111:Source/timers.c **** 	portTickType			xMessageValue;		/*<< An optional value used by a subset of commands, for example, w
 112:Source/timers.c **** 	xTIMER *				pxTimer;			/*<< The timer to which the command will be applied. */
 113:Source/timers.c **** } xTIMER_MESSAGE;
 114:Source/timers.c **** 
 115:Source/timers.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 116:Source/timers.c **** static variables must be declared volatile. */
 117:Source/timers.c **** 
 118:Source/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
 119:Source/timers.c **** time order, with the nearest expiry time at the front of the list.  Only the
 120:Source/timers.c **** timer service task is allowed to access xActiveTimerList. */
 121:Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList1;
 122:Source/timers.c **** PRIVILEGED_DATA static xList xActiveTimerList2;
 123:Source/timers.c **** PRIVILEGED_DATA static xList *pxCurrentTimerList;
 124:Source/timers.c **** PRIVILEGED_DATA static xList *pxOverflowTimerList;
 125:Source/timers.c **** 
 126:Source/timers.c **** /* A queue that is used to send commands to the timer service task. */
 127:Source/timers.c **** PRIVILEGED_DATA static xQueueHandle xTimerQueue = NULL;
 128:Source/timers.c **** 
 129:Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 130:Source/timers.c **** 
 131:Source/timers.c **** 	PRIVILEGED_DATA static xTaskHandle xTimerTaskHandle = NULL;
 132:Source/timers.c **** 
 133:Source/timers.c **** #endif
 134:Source/timers.c **** 
 135:Source/timers.c **** /*lint +e956 */
 136:Source/timers.c **** 
 137:Source/timers.c **** /*-----------------------------------------------------------*/
 138:Source/timers.c **** 
 139:Source/timers.c **** /*
 140:Source/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 141:Source/timers.c ****  * been initialised already.
 142:Source/timers.c ****  */
 143:Source/timers.c **** static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 144:Source/timers.c **** 
 145:Source/timers.c **** /*
 146:Source/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 147:Source/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 148:Source/timers.c ****  * xTimerQueue queue.
 149:Source/timers.c ****  */
 150:Source/timers.c **** static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
 151:Source/timers.c **** 
 152:Source/timers.c **** /*
 153:Source/timers.c ****  * Called by the timer service task to interpret and process a command it
 154:Source/timers.c ****  * received on the timer queue.
 155:Source/timers.c ****  */
 156:Source/timers.c **** static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 157:Source/timers.c **** 
 158:Source/timers.c **** /*
 159:Source/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 160:Source/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 161:Source/timers.c ****  */
 162:Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 163:Source/timers.c **** 
 164:Source/timers.c **** /*
 165:Source/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 166:Source/timers.c ****  * auto reload timer, then call its callback.
 167:Source/timers.c ****  */
 168:Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow ) PRIVILEGE
 169:Source/timers.c **** 
 170:Source/timers.c **** /*
 171:Source/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 172:Source/timers.c ****  * current timer list does not still reference some timers.
 173:Source/timers.c ****  */
 174:Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime ) PRIVILEGED_FUNCTION;
 175:Source/timers.c **** 
 176:Source/timers.c **** /*
 177:Source/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 178:Source/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 179:Source/timers.c ****  */
 180:Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION
 181:Source/timers.c **** 
 182:Source/timers.c **** /*
 183:Source/timers.c ****  * If the timer list contains any active timers then return the expire time of
 184:Source/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 185:Source/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 186:Source/timers.c ****  * to pdTRUE.
 187:Source/timers.c ****  */
 188:Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty ) PRIVILEGED_FUNCTION;
 189:Source/timers.c **** 
 190:Source/timers.c **** /*
 191:Source/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 192:Source/timers.c ****  * until either a timer does expire or a command is received.
 193:Source/timers.c ****  */
 194:Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 195:Source/timers.c **** 
 196:Source/timers.c **** /*-----------------------------------------------------------*/
 197:Source/timers.c **** 
 198:Source/timers.c **** portBASE_TYPE xTimerCreateTimerTask( void )
 199:Source/timers.c **** {
  62              		.loc 1 199 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 8
  65              		@ frame_needed = 1, uses_anonymous_args = 0
  66 0000 80B5     		push	{r7, lr}
  67              	.LCFI0:
  68              		.cfi_def_cfa_offset 8
  69              		.cfi_offset 7, -8
  70              		.cfi_offset 14, -4
  71 0002 86B0     		sub	sp, sp, #24
  72              	.LCFI1:
  73              		.cfi_def_cfa_offset 32
  74 0004 04AF     		add	r7, sp, #16
  75              	.LCFI2:
  76              		.cfi_def_cfa 7, 16
 200:Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
  77              		.loc 1 200 0
  78 0006 4FF00003 		mov	r3, #0
  79 000a 7B60     		str	r3, [r7, #4]
 201:Source/timers.c **** 
 202:Source/timers.c **** 	/* This function is called when the scheduler is started if
 203:Source/timers.c **** 	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 204:Source/timers.c **** 	timer service task has been created/initialised.  If timers have already
 205:Source/timers.c **** 	been created then the initialisation will already have been performed. */
 206:Source/timers.c **** 	prvCheckForValidListAndQueue();
  80              		.loc 1 206 0
  81 000c FFF7FEFF 		bl	prvCheckForValidListAndQueue
 207:Source/timers.c **** 
 208:Source/timers.c **** 	if( xTimerQueue != NULL )
  82              		.loc 1 208 0
  83 0010 40F20003 		movw	r3, #:lower16:xTimerQueue
  84 0014 C0F20003 		movt	r3, #:upper16:xTimerQueue
  85 0018 1B68     		ldr	r3, [r3, #0]
  86 001a 002B     		cmp	r3, #0
  87 001c 1AD0     		beq	.L2
 209:Source/timers.c **** 	{
 210:Source/timers.c **** 		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 211:Source/timers.c **** 		{
 212:Source/timers.c **** 			/* Create the timer task, storing its handle in xTimerTaskHandle so
 213:Source/timers.c **** 			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
 214:Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
 215:Source/timers.c **** 		}
 216:Source/timers.c **** 		#else
 217:Source/timers.c **** 		{
 218:Source/timers.c **** 			/* Create the timer task without storing its handle. */
 219:Source/timers.c **** 			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) confi
  88              		.loc 1 219 0
  89 001e 4FF00203 		mov	r3, #2
  90 0022 0093     		str	r3, [sp, #0]
  91 0024 4FF00003 		mov	r3, #0
  92 0028 0193     		str	r3, [sp, #4]
  93 002a 4FF00003 		mov	r3, #0
  94 002e 0293     		str	r3, [sp, #8]
  95 0030 4FF00003 		mov	r3, #0
  96 0034 0393     		str	r3, [sp, #12]
  97 0036 40F20000 		movw	r0, #:lower16:prvTimerTask
  98 003a C0F20000 		movt	r0, #:upper16:prvTimerTask
  99 003e 40F20001 		movw	r1, #:lower16:.LC0
 100 0042 C0F20001 		movt	r1, #:upper16:.LC0
 101 0046 4FF48272 		mov	r2, #260
 102 004a 4FF00003 		mov	r3, #0
 103 004e FFF7FEFF 		bl	xTaskGenericCreate
 104 0052 7860     		str	r0, [r7, #4]
 105              	.L2:
 220:Source/timers.c **** 		}
 221:Source/timers.c **** 		#endif
 222:Source/timers.c **** 	}
 223:Source/timers.c **** 
 224:Source/timers.c **** 	configASSERT( xReturn );
 106              		.loc 1 224 0
 107 0054 7B68     		ldr	r3, [r7, #4]
 108 0056 002B     		cmp	r3, #0
 109 0058 02D1     		bne	.L3
 110              		.loc 1 224 0 is_stmt 0 discriminator 1
 111 005a FFF7FEFF 		bl	ulPortSetInterruptMask
 112              	.L4:
 113              		.loc 1 224 0 discriminator 2
 114 005e FEE7     		b	.L4
 115              	.L3:
 225:Source/timers.c **** 	return xReturn;
 116              		.loc 1 225 0 is_stmt 1
 117 0060 7B68     		ldr	r3, [r7, #4]
 226:Source/timers.c **** }
 118              		.loc 1 226 0
 119 0062 1846     		mov	r0, r3
 120 0064 07F10807 		add	r7, r7, #8
 121 0068 BD46     		mov	sp, r7
 122 006a 80BD     		pop	{r7, pc}
 123              		.cfi_endproc
 124              	.LFE110:
 126              		.section	.text.xTimerCreate,"ax",%progbits
 127              		.align	2
 128              		.global	xTimerCreate
 129              		.thumb
 130              		.thumb_func
 132              	xTimerCreate:
 133              	.LFB111:
 227:Source/timers.c **** /*-----------------------------------------------------------*/
 228:Source/timers.c **** 
 229:Source/timers.c **** xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks,
 230:Source/timers.c **** {
 134              		.loc 1 230 0
 135              		.cfi_startproc
 136              		@ args = 4, pretend = 0, frame = 24
 137              		@ frame_needed = 1, uses_anonymous_args = 0
 138 0000 80B5     		push	{r7, lr}
 139              	.LCFI3:
 140              		.cfi_def_cfa_offset 8
 141              		.cfi_offset 7, -8
 142              		.cfi_offset 14, -4
 143 0002 86B0     		sub	sp, sp, #24
 144              	.LCFI4:
 145              		.cfi_def_cfa_offset 32
 146 0004 00AF     		add	r7, sp, #0
 147              	.LCFI5:
 148              		.cfi_def_cfa_register 7
 149 0006 F860     		str	r0, [r7, #12]
 150 0008 B960     		str	r1, [r7, #8]
 151 000a 7A60     		str	r2, [r7, #4]
 152 000c 3B60     		str	r3, [r7, #0]
 231:Source/timers.c **** xTIMER *pxNewTimer;
 232:Source/timers.c **** 
 233:Source/timers.c **** 	/* Allocate the timer structure. */
 234:Source/timers.c **** 	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 153              		.loc 1 234 0
 154 000e BB68     		ldr	r3, [r7, #8]
 155 0010 002B     		cmp	r3, #0
 156 0012 03D1     		bne	.L7
 235:Source/timers.c **** 	{
 236:Source/timers.c **** 		pxNewTimer = NULL;
 157              		.loc 1 236 0
 158 0014 4FF00003 		mov	r3, #0
 159 0018 7B61     		str	r3, [r7, #20]
 160 001a 1EE0     		b	.L8
 161              	.L7:
 237:Source/timers.c **** 	}
 238:Source/timers.c **** 	else
 239:Source/timers.c **** 	{
 240:Source/timers.c **** 		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 162              		.loc 1 240 0
 163 001c 4FF02800 		mov	r0, #40
 164 0020 FFF7FEFF 		bl	pvPortMalloc
 165 0024 7861     		str	r0, [r7, #20]
 241:Source/timers.c **** 		if( pxNewTimer != NULL )
 166              		.loc 1 241 0
 167 0026 7B69     		ldr	r3, [r7, #20]
 168 0028 002B     		cmp	r3, #0
 169 002a 16D0     		beq	.L8
 242:Source/timers.c **** 		{
 243:Source/timers.c **** 			/* Ensure the infrastructure used by the timer service task has been
 244:Source/timers.c **** 			created/initialised. */
 245:Source/timers.c **** 			prvCheckForValidListAndQueue();
 170              		.loc 1 245 0
 171 002c FFF7FEFF 		bl	prvCheckForValidListAndQueue
 246:Source/timers.c **** 
 247:Source/timers.c **** 			/* Initialise the timer structure members using the function parameters. */
 248:Source/timers.c **** 			pxNewTimer->pcTimerName = pcTimerName;
 172              		.loc 1 248 0
 173 0030 7B69     		ldr	r3, [r7, #20]
 174 0032 FA68     		ldr	r2, [r7, #12]
 175 0034 1A60     		str	r2, [r3, #0]
 249:Source/timers.c **** 			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 176              		.loc 1 249 0
 177 0036 7B69     		ldr	r3, [r7, #20]
 178 0038 BA68     		ldr	r2, [r7, #8]
 179 003a 9A61     		str	r2, [r3, #24]
 250:Source/timers.c **** 			pxNewTimer->uxAutoReload = uxAutoReload;
 180              		.loc 1 250 0
 181 003c 7B69     		ldr	r3, [r7, #20]
 182 003e 7A68     		ldr	r2, [r7, #4]
 183 0040 DA61     		str	r2, [r3, #28]
 251:Source/timers.c **** 			pxNewTimer->pvTimerID = pvTimerID;
 184              		.loc 1 251 0
 185 0042 7B69     		ldr	r3, [r7, #20]
 186 0044 3A68     		ldr	r2, [r7, #0]
 187 0046 1A62     		str	r2, [r3, #32]
 252:Source/timers.c **** 			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 188              		.loc 1 252 0
 189 0048 7B69     		ldr	r3, [r7, #20]
 190 004a 3A6A     		ldr	r2, [r7, #32]
 191 004c 5A62     		str	r2, [r3, #36]
 253:Source/timers.c **** 			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 192              		.loc 1 253 0
 193 004e 7B69     		ldr	r3, [r7, #20]
 194 0050 03F10403 		add	r3, r3, #4
 195 0054 1846     		mov	r0, r3
 196 0056 FFF7FEFF 		bl	vListInitialiseItem
 197              	.L8:
 254:Source/timers.c **** 
 255:Source/timers.c **** 			traceTIMER_CREATE( pxNewTimer );
 256:Source/timers.c **** 		}
 257:Source/timers.c **** 		else
 258:Source/timers.c **** 		{
 259:Source/timers.c **** 			traceTIMER_CREATE_FAILED();
 260:Source/timers.c **** 		}
 261:Source/timers.c **** 	}
 262:Source/timers.c **** 
 263:Source/timers.c **** 	/* 0 is not a valid value for xTimerPeriodInTicks. */
 264:Source/timers.c **** 	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 198              		.loc 1 264 0
 199 005a BB68     		ldr	r3, [r7, #8]
 200 005c 002B     		cmp	r3, #0
 201 005e 02D1     		bne	.L9
 202              		.loc 1 264 0 is_stmt 0 discriminator 1
 203 0060 FFF7FEFF 		bl	ulPortSetInterruptMask
 204              	.L10:
 205              		.loc 1 264 0 discriminator 2
 206 0064 FEE7     		b	.L10
 207              	.L9:
 265:Source/timers.c **** 
 266:Source/timers.c **** 	return ( xTimerHandle ) pxNewTimer;
 208              		.loc 1 266 0 is_stmt 1
 209 0066 7B69     		ldr	r3, [r7, #20]
 267:Source/timers.c **** }
 210              		.loc 1 267 0
 211 0068 1846     		mov	r0, r3
 212 006a 07F11807 		add	r7, r7, #24
 213 006e BD46     		mov	sp, r7
 214 0070 80BD     		pop	{r7, pc}
 215              		.cfi_endproc
 216              	.LFE111:
 218 0072 00BF     		.section	.text.xTimerGenericCommand,"ax",%progbits
 219              		.align	2
 220              		.global	xTimerGenericCommand
 221              		.thumb
 222              		.thumb_func
 224              	xTimerGenericCommand:
 225              	.LFB112:
 268:Source/timers.c **** /*-----------------------------------------------------------*/
 269:Source/timers.c **** 
 270:Source/timers.c **** portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOp
 271:Source/timers.c **** {
 226              		.loc 1 271 0
 227              		.cfi_startproc
 228              		@ args = 4, pretend = 0, frame = 32
 229              		@ frame_needed = 1, uses_anonymous_args = 0
 230 0000 80B5     		push	{r7, lr}
 231              	.LCFI6:
 232              		.cfi_def_cfa_offset 8
 233              		.cfi_offset 7, -8
 234              		.cfi_offset 14, -4
 235 0002 88B0     		sub	sp, sp, #32
 236              	.LCFI7:
 237              		.cfi_def_cfa_offset 40
 238 0004 00AF     		add	r7, sp, #0
 239              	.LCFI8:
 240              		.cfi_def_cfa_register 7
 241 0006 F860     		str	r0, [r7, #12]
 242 0008 B960     		str	r1, [r7, #8]
 243 000a 7A60     		str	r2, [r7, #4]
 244 000c 3B60     		str	r3, [r7, #0]
 272:Source/timers.c **** portBASE_TYPE xReturn = pdFAIL;
 245              		.loc 1 272 0
 246 000e 4FF00003 		mov	r3, #0
 247 0012 FB61     		str	r3, [r7, #28]
 273:Source/timers.c **** xTIMER_MESSAGE xMessage;
 274:Source/timers.c **** 
 275:Source/timers.c **** 	/* Send a message to the timer service task to perform a particular action
 276:Source/timers.c **** 	on a particular timer definition. */
 277:Source/timers.c **** 	if( xTimerQueue != NULL )
 248              		.loc 1 277 0
 249 0014 40F20003 		movw	r3, #:lower16:xTimerQueue
 250 0018 C0F20003 		movt	r3, #:upper16:xTimerQueue
 251 001c 1B68     		ldr	r3, [r3, #0]
 252 001e 002B     		cmp	r3, #0
 253 0020 3DD0     		beq	.L13
 278:Source/timers.c **** 	{
 279:Source/timers.c **** 		/* Send a command to the timer service task to start the xTimer timer. */
 280:Source/timers.c **** 		xMessage.xMessageID = xCommandID;
 254              		.loc 1 280 0
 255 0022 BB68     		ldr	r3, [r7, #8]
 256 0024 3B61     		str	r3, [r7, #16]
 281:Source/timers.c **** 		xMessage.xMessageValue = xOptionalValue;
 257              		.loc 1 281 0
 258 0026 7B68     		ldr	r3, [r7, #4]
 259 0028 7B61     		str	r3, [r7, #20]
 282:Source/timers.c **** 		xMessage.pxTimer = ( xTIMER * ) xTimer;
 260              		.loc 1 282 0
 261 002a FB68     		ldr	r3, [r7, #12]
 262 002c BB61     		str	r3, [r7, #24]
 283:Source/timers.c **** 
 284:Source/timers.c **** 		if( pxHigherPriorityTaskWoken == NULL )
 263              		.loc 1 284 0
 264 002e 3B68     		ldr	r3, [r7, #0]
 265 0030 002B     		cmp	r3, #0
 266 0032 25D1     		bne	.L14
 285:Source/timers.c **** 		{
 286:Source/timers.c **** 			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 267              		.loc 1 286 0
 268 0034 FFF7FEFF 		bl	xTaskGetSchedulerState
 269 0038 0346     		mov	r3, r0
 270 003a 012B     		cmp	r3, #1
 271 003c 0FD1     		bne	.L15
 287:Source/timers.c **** 			{
 288:Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 272              		.loc 1 288 0
 273 003e 40F20003 		movw	r3, #:lower16:xTimerQueue
 274 0042 C0F20003 		movt	r3, #:upper16:xTimerQueue
 275 0046 1A68     		ldr	r2, [r3, #0]
 276 0048 07F11003 		add	r3, r7, #16
 277 004c 1046     		mov	r0, r2
 278 004e 1946     		mov	r1, r3
 279 0050 BA6A     		ldr	r2, [r7, #40]
 280 0052 4FF00003 		mov	r3, #0
 281 0056 FFF7FEFF 		bl	xQueueGenericSend
 282 005a F861     		str	r0, [r7, #28]
 283 005c 1FE0     		b	.L13
 284              	.L15:
 289:Source/timers.c **** 			}
 290:Source/timers.c **** 			else
 291:Source/timers.c **** 			{
 292:Source/timers.c **** 				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 285              		.loc 1 292 0
 286 005e 40F20003 		movw	r3, #:lower16:xTimerQueue
 287 0062 C0F20003 		movt	r3, #:upper16:xTimerQueue
 288 0066 1A68     		ldr	r2, [r3, #0]
 289 0068 07F11003 		add	r3, r7, #16
 290 006c 1046     		mov	r0, r2
 291 006e 1946     		mov	r1, r3
 292 0070 4FF00002 		mov	r2, #0
 293 0074 4FF00003 		mov	r3, #0
 294 0078 FFF7FEFF 		bl	xQueueGenericSend
 295 007c F861     		str	r0, [r7, #28]
 296 007e 0EE0     		b	.L13
 297              	.L14:
 293:Source/timers.c **** 			}
 294:Source/timers.c **** 		}
 295:Source/timers.c **** 		else
 296:Source/timers.c **** 		{
 297:Source/timers.c **** 			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 298              		.loc 1 297 0
 299 0080 40F20003 		movw	r3, #:lower16:xTimerQueue
 300 0084 C0F20003 		movt	r3, #:upper16:xTimerQueue
 301 0088 1A68     		ldr	r2, [r3, #0]
 302 008a 07F11003 		add	r3, r7, #16
 303 008e 1046     		mov	r0, r2
 304 0090 1946     		mov	r1, r3
 305 0092 3A68     		ldr	r2, [r7, #0]
 306 0094 4FF00003 		mov	r3, #0
 307 0098 FFF7FEFF 		bl	xQueueGenericSendFromISR
 308 009c F861     		str	r0, [r7, #28]
 309              	.L13:
 298:Source/timers.c **** 		}
 299:Source/timers.c **** 
 300:Source/timers.c **** 		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 301:Source/timers.c **** 	}
 302:Source/timers.c **** 
 303:Source/timers.c **** 	return xReturn;
 310              		.loc 1 303 0
 311 009e FB69     		ldr	r3, [r7, #28]
 304:Source/timers.c **** }
 312              		.loc 1 304 0
 313 00a0 1846     		mov	r0, r3
 314 00a2 07F12007 		add	r7, r7, #32
 315 00a6 BD46     		mov	sp, r7
 316 00a8 80BD     		pop	{r7, pc}
 317              		.cfi_endproc
 318              	.LFE112:
 320 00aa 00BF     		.section	.text.prvProcessExpiredTimer,"ax",%progbits
 321              		.align	2
 322              		.thumb
 323              		.thumb_func
 325              	prvProcessExpiredTimer:
 326              	.LFB113:
 305:Source/timers.c **** /*-----------------------------------------------------------*/
 306:Source/timers.c **** 
 307:Source/timers.c **** #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
 308:Source/timers.c **** 
 309:Source/timers.c **** 	xTaskHandle xTimerGetTimerDaemonTaskHandle( void )
 310:Source/timers.c **** 	{
 311:Source/timers.c **** 		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 312:Source/timers.c **** 		started, then xTimerTaskHandle will be NULL. */
 313:Source/timers.c **** 		configASSERT( ( xTimerTaskHandle != NULL ) );
 314:Source/timers.c **** 		return xTimerTaskHandle;
 315:Source/timers.c **** 	}
 316:Source/timers.c **** 
 317:Source/timers.c **** #endif
 318:Source/timers.c **** /*-----------------------------------------------------------*/
 319:Source/timers.c **** 
 320:Source/timers.c **** static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
 321:Source/timers.c **** {
 327              		.loc 1 321 0
 328              		.cfi_startproc
 329              		@ args = 0, pretend = 0, frame = 16
 330              		@ frame_needed = 1, uses_anonymous_args = 0
 331 0000 80B5     		push	{r7, lr}
 332              	.LCFI9:
 333              		.cfi_def_cfa_offset 8
 334              		.cfi_offset 7, -8
 335              		.cfi_offset 14, -4
 336 0002 86B0     		sub	sp, sp, #24
 337              	.LCFI10:
 338              		.cfi_def_cfa_offset 32
 339 0004 02AF     		add	r7, sp, #8
 340              	.LCFI11:
 341              		.cfi_def_cfa 7, 24
 342 0006 7860     		str	r0, [r7, #4]
 343 0008 3960     		str	r1, [r7, #0]
 322:Source/timers.c **** xTIMER *pxTimer;
 323:Source/timers.c **** portBASE_TYPE xResult;
 324:Source/timers.c **** 
 325:Source/timers.c **** 	/* Remove the timer from the list of active timers.  A check has already
 326:Source/timers.c **** 	been performed to ensure the list is not empty. */
 327:Source/timers.c **** 	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 344              		.loc 1 327 0
 345 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 346 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 347 0012 1B68     		ldr	r3, [r3, #0]
 348 0014 DB68     		ldr	r3, [r3, #12]
 349 0016 DB68     		ldr	r3, [r3, #12]
 350 0018 FB60     		str	r3, [r7, #12]
 328:Source/timers.c **** 	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 351              		.loc 1 328 0
 352 001a FB68     		ldr	r3, [r7, #12]
 353 001c 03F10403 		add	r3, r3, #4
 354 0020 1846     		mov	r0, r3
 355 0022 FFF7FEFF 		bl	uxListRemove
 329:Source/timers.c **** 	traceTIMER_EXPIRED( pxTimer );
 330:Source/timers.c **** 
 331:Source/timers.c **** 	/* If the timer is an auto reload timer then calculate the next
 332:Source/timers.c **** 	expiry time and re-insert the timer in the list of active timers. */
 333:Source/timers.c **** 	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 356              		.loc 1 333 0
 357 0026 FB68     		ldr	r3, [r7, #12]
 358 0028 DB69     		ldr	r3, [r3, #28]
 359 002a 012B     		cmp	r3, #1
 360 002c 1ED1     		bne	.L18
 334:Source/timers.c **** 	{
 335:Source/timers.c **** 		/* This is the only time a timer is inserted into a list using
 336:Source/timers.c **** 		a time relative to anything other than the current time.  It
 337:Source/timers.c **** 		will therefore be inserted into the correct list relative to
 338:Source/timers.c **** 		the time this task thinks it is now, even if a command to
 339:Source/timers.c **** 		switch lists due to a tick count overflow is already waiting in
 340:Source/timers.c **** 		the timer queue. */
 341:Source/timers.c **** 		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTim
 361              		.loc 1 341 0
 362 002e FB68     		ldr	r3, [r7, #12]
 363 0030 9A69     		ldr	r2, [r3, #24]
 364 0032 7B68     		ldr	r3, [r7, #4]
 365 0034 D318     		adds	r3, r2, r3
 366 0036 F868     		ldr	r0, [r7, #12]
 367 0038 1946     		mov	r1, r3
 368 003a 3A68     		ldr	r2, [r7, #0]
 369 003c 7B68     		ldr	r3, [r7, #4]
 370 003e FFF7FEFF 		bl	prvInsertTimerInActiveList
 371 0042 0346     		mov	r3, r0
 372 0044 012B     		cmp	r3, #1
 373 0046 11D1     		bne	.L18
 342:Source/timers.c **** 		{
 343:Source/timers.c **** 			/* The timer expired before it was added to the active timer
 344:Source/timers.c **** 			list.  Reload it now.  */
 345:Source/timers.c **** 			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 374              		.loc 1 345 0
 375 0048 4FF00003 		mov	r3, #0
 376 004c 0093     		str	r3, [sp, #0]
 377 004e F868     		ldr	r0, [r7, #12]
 378 0050 4FF00001 		mov	r1, #0
 379 0054 7A68     		ldr	r2, [r7, #4]
 380 0056 4FF00003 		mov	r3, #0
 381 005a FFF7FEFF 		bl	xTimerGenericCommand
 382 005e B860     		str	r0, [r7, #8]
 346:Source/timers.c **** 			configASSERT( xResult );
 383              		.loc 1 346 0
 384 0060 BB68     		ldr	r3, [r7, #8]
 385 0062 002B     		cmp	r3, #0
 386 0064 02D1     		bne	.L18
 387              		.loc 1 346 0 is_stmt 0 discriminator 1
 388 0066 FFF7FEFF 		bl	ulPortSetInterruptMask
 389              	.L19:
 390              		.loc 1 346 0 discriminator 2
 391 006a FEE7     		b	.L19
 392              	.L18:
 347:Source/timers.c **** 			( void ) xResult;
 348:Source/timers.c **** 		}
 349:Source/timers.c **** 	}
 350:Source/timers.c **** 
 351:Source/timers.c **** 	/* Call the timer callback. */
 352:Source/timers.c **** 	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 393              		.loc 1 352 0 is_stmt 1
 394 006c FB68     		ldr	r3, [r7, #12]
 395 006e 5B6A     		ldr	r3, [r3, #36]
 396 0070 F868     		ldr	r0, [r7, #12]
 397 0072 9847     		blx	r3
 353:Source/timers.c **** }
 398              		.loc 1 353 0
 399 0074 07F11007 		add	r7, r7, #16
 400 0078 BD46     		mov	sp, r7
 401 007a 80BD     		pop	{r7, pc}
 402              		.cfi_endproc
 403              	.LFE113:
 405              		.section	.text.prvTimerTask,"ax",%progbits
 406              		.align	2
 407              		.thumb
 408              		.thumb_func
 410              	prvTimerTask:
 411              	.LFB114:
 354:Source/timers.c **** /*-----------------------------------------------------------*/
 355:Source/timers.c **** 
 356:Source/timers.c **** static void prvTimerTask( void *pvParameters )
 357:Source/timers.c **** {
 412              		.loc 1 357 0
 413              		.cfi_startproc
 414              		@ args = 0, pretend = 0, frame = 16
 415              		@ frame_needed = 1, uses_anonymous_args = 0
 416 0000 80B5     		push	{r7, lr}
 417              	.LCFI12:
 418              		.cfi_def_cfa_offset 8
 419              		.cfi_offset 7, -8
 420              		.cfi_offset 14, -4
 421 0002 84B0     		sub	sp, sp, #16
 422              	.LCFI13:
 423              		.cfi_def_cfa_offset 24
 424 0004 00AF     		add	r7, sp, #0
 425              	.LCFI14:
 426              		.cfi_def_cfa_register 7
 427 0006 7860     		str	r0, [r7, #4]
 428              	.L21:
 358:Source/timers.c **** portTickType xNextExpireTime;
 359:Source/timers.c **** portBASE_TYPE xListWasEmpty;
 360:Source/timers.c **** 
 361:Source/timers.c **** 	/* Just to avoid compiler warnings. */
 362:Source/timers.c **** 	( void ) pvParameters;
 363:Source/timers.c **** 
 364:Source/timers.c **** 	for( ;; )
 365:Source/timers.c **** 	{
 366:Source/timers.c **** 		/* Query the timers list to see if it contains any timers, and if so,
 367:Source/timers.c **** 		obtain the time at which the next timer will expire. */
 368:Source/timers.c **** 		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 429              		.loc 1 368 0 discriminator 1
 430 0008 07F10803 		add	r3, r7, #8
 431 000c 1846     		mov	r0, r3
 432 000e FFF7FEFF 		bl	prvGetNextExpireTime
 433 0012 F860     		str	r0, [r7, #12]
 369:Source/timers.c **** 
 370:Source/timers.c **** 		/* If a timer has expired, process it.  Otherwise, block this task
 371:Source/timers.c **** 		until either a timer does expire, or a command is received. */
 372:Source/timers.c **** 		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 434              		.loc 1 372 0 discriminator 1
 435 0014 BB68     		ldr	r3, [r7, #8]
 436 0016 F868     		ldr	r0, [r7, #12]
 437 0018 1946     		mov	r1, r3
 438 001a FFF7FEFF 		bl	prvProcessTimerOrBlockTask
 373:Source/timers.c **** 
 374:Source/timers.c **** 		/* Empty the command queue. */
 375:Source/timers.c **** 		prvProcessReceivedCommands();
 439              		.loc 1 375 0 discriminator 1
 440 001e FFF7FEFF 		bl	prvProcessReceivedCommands
 376:Source/timers.c **** 	}
 441              		.loc 1 376 0 discriminator 1
 442 0022 F1E7     		b	.L21
 443              		.cfi_endproc
 444              	.LFE114:
 446              		.section	.text.prvProcessTimerOrBlockTask,"ax",%progbits
 447              		.align	2
 448              		.thumb
 449              		.thumb_func
 451              	prvProcessTimerOrBlockTask:
 452              	.LFB115:
 377:Source/timers.c **** }
 378:Source/timers.c **** /*-----------------------------------------------------------*/
 379:Source/timers.c **** 
 380:Source/timers.c **** static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
 381:Source/timers.c **** {
 453              		.loc 1 381 0
 454              		.cfi_startproc
 455              		@ args = 0, pretend = 0, frame = 16
 456              		@ frame_needed = 1, uses_anonymous_args = 0
 457 0000 80B5     		push	{r7, lr}
 458              	.LCFI15:
 459              		.cfi_def_cfa_offset 8
 460              		.cfi_offset 7, -8
 461              		.cfi_offset 14, -4
 462 0002 84B0     		sub	sp, sp, #16
 463              	.LCFI16:
 464              		.cfi_def_cfa_offset 24
 465 0004 00AF     		add	r7, sp, #0
 466              	.LCFI17:
 467              		.cfi_def_cfa_register 7
 468 0006 7860     		str	r0, [r7, #4]
 469 0008 3960     		str	r1, [r7, #0]
 382:Source/timers.c **** portTickType xTimeNow;
 383:Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched;
 384:Source/timers.c **** 
 385:Source/timers.c **** 	vTaskSuspendAll();
 470              		.loc 1 385 0
 471 000a FFF7FEFF 		bl	vTaskSuspendAll
 386:Source/timers.c **** 	{
 387:Source/timers.c **** 		/* Obtain the time now to make an assessment as to whether the timer
 388:Source/timers.c **** 		has expired or not.  If obtaining the time causes the lists to switch
 389:Source/timers.c **** 		then don't process this timer as any timers that remained in the list
 390:Source/timers.c **** 		when the lists were switched will have been processed within the
 391:Source/timers.c **** 		prvSampelTimeNow() function. */
 392:Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 472              		.loc 1 392 0
 473 000e 07F10803 		add	r3, r7, #8
 474 0012 1846     		mov	r0, r3
 475 0014 FFF7FEFF 		bl	prvSampleTimeNow
 476 0018 F860     		str	r0, [r7, #12]
 393:Source/timers.c **** 		if( xTimerListsWereSwitched == pdFALSE )
 477              		.loc 1 393 0
 478 001a BB68     		ldr	r3, [r7, #8]
 479 001c 002B     		cmp	r3, #0
 480 001e 21D1     		bne	.L23
 394:Source/timers.c **** 		{
 395:Source/timers.c **** 			/* The tick count has not overflowed, has the timer expired? */
 396:Source/timers.c **** 			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 481              		.loc 1 396 0
 482 0020 3B68     		ldr	r3, [r7, #0]
 483 0022 002B     		cmp	r3, #0
 484 0024 0AD1     		bne	.L24
 485              		.loc 1 396 0 is_stmt 0 discriminator 1
 486 0026 7A68     		ldr	r2, [r7, #4]
 487 0028 FB68     		ldr	r3, [r7, #12]
 488 002a 9A42     		cmp	r2, r3
 489 002c 06D8     		bhi	.L24
 397:Source/timers.c **** 			{
 398:Source/timers.c **** 				( void ) xTaskResumeAll();
 490              		.loc 1 398 0 is_stmt 1
 491 002e FFF7FEFF 		bl	xTaskResumeAll
 399:Source/timers.c **** 				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 492              		.loc 1 399 0
 493 0032 7868     		ldr	r0, [r7, #4]
 494 0034 F968     		ldr	r1, [r7, #12]
 495 0036 FFF7FEFF 		bl	prvProcessExpiredTimer
 496 003a 17E0     		b	.L22
 497              	.L24:
 400:Source/timers.c **** 			}
 401:Source/timers.c **** 			else
 402:Source/timers.c **** 			{
 403:Source/timers.c **** 				/* The tick count has not overflowed, and the next expire
 404:Source/timers.c **** 				time has not been reached yet.  This task should therefore
 405:Source/timers.c **** 				block to wait for the next expire time or a command to be
 406:Source/timers.c **** 				received - whichever comes first.  The following line cannot
 407:Source/timers.c **** 				be reached unless xNextExpireTime > xTimeNow, except in the
 408:Source/timers.c **** 				case when the current timer list is empty. */
 409:Source/timers.c **** 				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 498              		.loc 1 409 0
 499 003c 40F20003 		movw	r3, #:lower16:xTimerQueue
 500 0040 C0F20003 		movt	r3, #:upper16:xTimerQueue
 501 0044 1A68     		ldr	r2, [r3, #0]
 502 0046 7968     		ldr	r1, [r7, #4]
 503 0048 FB68     		ldr	r3, [r7, #12]
 504 004a CB1A     		subs	r3, r1, r3
 505 004c 1046     		mov	r0, r2
 506 004e 1946     		mov	r1, r3
 507 0050 FFF7FEFF 		bl	vQueueWaitForMessageRestricted
 410:Source/timers.c **** 
 411:Source/timers.c **** 				if( xTaskResumeAll() == pdFALSE )
 508              		.loc 1 411 0
 509 0054 FFF7FEFF 		bl	xTaskResumeAll
 510 0058 0346     		mov	r3, r0
 511 005a 002B     		cmp	r3, #0
 512 005c 05D1     		bne	.L27
 412:Source/timers.c **** 				{
 413:Source/timers.c **** 					/* Yield to wait for either a command to arrive, or the block time
 414:Source/timers.c **** 					to expire.  If a command arrived between the critical section being
 415:Source/timers.c **** 					exited and this yield then the yield will not cause the task
 416:Source/timers.c **** 					to block. */
 417:Source/timers.c **** 					portYIELD_WITHIN_API();
 513              		.loc 1 417 0
 514 005e FFF7FEFF 		bl	vPortYield
 515 0062 02E0     		b	.L27
 516              	.L23:
 418:Source/timers.c **** 				}
 419:Source/timers.c **** 			}
 420:Source/timers.c **** 		}
 421:Source/timers.c **** 		else
 422:Source/timers.c **** 		{
 423:Source/timers.c **** 			( void ) xTaskResumeAll();
 517              		.loc 1 423 0
 518 0064 FFF7FEFF 		bl	xTaskResumeAll
 519 0068 00E0     		b	.L22
 520              	.L27:
 417:Source/timers.c **** 					portYIELD_WITHIN_API();
 521              		.loc 1 417 0
 522 006a 00BF     		nop
 523              	.L22:
 424:Source/timers.c **** 		}
 425:Source/timers.c **** 	}
 426:Source/timers.c **** }
 524              		.loc 1 426 0
 525 006c 07F11007 		add	r7, r7, #16
 526 0070 BD46     		mov	sp, r7
 527 0072 80BD     		pop	{r7, pc}
 528              		.cfi_endproc
 529              	.LFE115:
 531              		.section	.text.prvGetNextExpireTime,"ax",%progbits
 532              		.align	2
 533              		.thumb
 534              		.thumb_func
 536              	prvGetNextExpireTime:
 537              	.LFB116:
 427:Source/timers.c **** /*-----------------------------------------------------------*/
 428:Source/timers.c **** 
 429:Source/timers.c **** static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
 430:Source/timers.c **** {
 538              		.loc 1 430 0
 539              		.cfi_startproc
 540              		@ args = 0, pretend = 0, frame = 16
 541              		@ frame_needed = 1, uses_anonymous_args = 0
 542              		@ link register save eliminated.
 543 0000 80B4     		push	{r7}
 544              	.LCFI18:
 545              		.cfi_def_cfa_offset 4
 546              		.cfi_offset 7, -4
 547 0002 85B0     		sub	sp, sp, #20
 548              	.LCFI19:
 549              		.cfi_def_cfa_offset 24
 550 0004 00AF     		add	r7, sp, #0
 551              	.LCFI20:
 552              		.cfi_def_cfa_register 7
 553 0006 7860     		str	r0, [r7, #4]
 431:Source/timers.c **** portTickType xNextExpireTime;
 432:Source/timers.c **** 
 433:Source/timers.c **** 	/* Timers are listed in expiry time order, with the head of the list
 434:Source/timers.c **** 	referencing the task that will expire first.  Obtain the time at which
 435:Source/timers.c **** 	the timer with the nearest expiry time will expire.  If there are no
 436:Source/timers.c **** 	active timers then just set the next expire time to 0.  That will cause
 437:Source/timers.c **** 	this task to unblock when the tick count overflows, at which point the
 438:Source/timers.c **** 	timer lists will be switched and the next expiry time can be
 439:Source/timers.c **** 	re-assessed.  */
 440:Source/timers.c **** 	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 554              		.loc 1 440 0
 555 0008 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 556 000c C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 557 0010 1B68     		ldr	r3, [r3, #0]
 558 0012 1B68     		ldr	r3, [r3, #0]
 559 0014 002B     		cmp	r3, #0
 560 0016 14BF     		ite	ne
 561 0018 0023     		movne	r3, #0
 562 001a 0123     		moveq	r3, #1
 563 001c DBB2     		uxtb	r3, r3
 564 001e 1A46     		mov	r2, r3
 565 0020 7B68     		ldr	r3, [r7, #4]
 566 0022 1A60     		str	r2, [r3, #0]
 441:Source/timers.c **** 	if( *pxListWasEmpty == pdFALSE )
 567              		.loc 1 441 0
 568 0024 7B68     		ldr	r3, [r7, #4]
 569 0026 1B68     		ldr	r3, [r3, #0]
 570 0028 002B     		cmp	r3, #0
 571 002a 08D1     		bne	.L29
 442:Source/timers.c **** 	{
 443:Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 572              		.loc 1 443 0
 573 002c 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 574 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 575 0034 1B68     		ldr	r3, [r3, #0]
 576 0036 DB68     		ldr	r3, [r3, #12]
 577 0038 1B68     		ldr	r3, [r3, #0]
 578 003a FB60     		str	r3, [r7, #12]
 579 003c 02E0     		b	.L30
 580              	.L29:
 444:Source/timers.c **** 	}
 445:Source/timers.c **** 	else
 446:Source/timers.c **** 	{
 447:Source/timers.c **** 		/* Ensure the task unblocks when the tick count rolls over. */
 448:Source/timers.c **** 		xNextExpireTime = ( portTickType ) 0U;
 581              		.loc 1 448 0
 582 003e 4FF00003 		mov	r3, #0
 583 0042 FB60     		str	r3, [r7, #12]
 584              	.L30:
 449:Source/timers.c **** 	}
 450:Source/timers.c **** 
 451:Source/timers.c **** 	return xNextExpireTime;
 585              		.loc 1 451 0
 586 0044 FB68     		ldr	r3, [r7, #12]
 452:Source/timers.c **** }
 587              		.loc 1 452 0
 588 0046 1846     		mov	r0, r3
 589 0048 07F11407 		add	r7, r7, #20
 590 004c BD46     		mov	sp, r7
 591 004e 80BC     		pop	{r7}
 592 0050 7047     		bx	lr
 593              		.cfi_endproc
 594              	.LFE116:
 596 0052 00BF     		.section	.text.prvSampleTimeNow,"ax",%progbits
 597              		.align	2
 598              		.thumb
 599              		.thumb_func
 601              	prvSampleTimeNow:
 602              	.LFB117:
 453:Source/timers.c **** /*-----------------------------------------------------------*/
 454:Source/timers.c **** 
 455:Source/timers.c **** static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
 456:Source/timers.c **** {
 603              		.loc 1 456 0
 604              		.cfi_startproc
 605              		@ args = 0, pretend = 0, frame = 16
 606              		@ frame_needed = 1, uses_anonymous_args = 0
 607 0000 80B5     		push	{r7, lr}
 608              	.LCFI21:
 609              		.cfi_def_cfa_offset 8
 610              		.cfi_offset 7, -8
 611              		.cfi_offset 14, -4
 612 0002 84B0     		sub	sp, sp, #16
 613              	.LCFI22:
 614              		.cfi_def_cfa_offset 24
 615 0004 00AF     		add	r7, sp, #0
 616              	.LCFI23:
 617              		.cfi_def_cfa_register 7
 618 0006 7860     		str	r0, [r7, #4]
 457:Source/timers.c **** portTickType xTimeNow;
 458:Source/timers.c **** PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only 
 459:Source/timers.c **** 
 460:Source/timers.c **** 	xTimeNow = xTaskGetTickCount();
 619              		.loc 1 460 0
 620 0008 FFF7FEFF 		bl	xTaskGetTickCount
 621 000c F860     		str	r0, [r7, #12]
 461:Source/timers.c **** 
 462:Source/timers.c **** 	if( xTimeNow < xLastTime )
 622              		.loc 1 462 0
 623 000e 40F20003 		movw	r3, #:lower16:xLastTime.8300
 624 0012 C0F20003 		movt	r3, #:upper16:xLastTime.8300
 625 0016 1B68     		ldr	r3, [r3, #0]
 626 0018 FA68     		ldr	r2, [r7, #12]
 627 001a 9A42     		cmp	r2, r3
 628 001c 0CD2     		bcs	.L33
 463:Source/timers.c **** 	{
 464:Source/timers.c **** 		prvSwitchTimerLists( xLastTime );
 629              		.loc 1 464 0
 630 001e 40F20003 		movw	r3, #:lower16:xLastTime.8300
 631 0022 C0F20003 		movt	r3, #:upper16:xLastTime.8300
 632 0026 1B68     		ldr	r3, [r3, #0]
 633 0028 1846     		mov	r0, r3
 634 002a FFF7FEFF 		bl	prvSwitchTimerLists
 465:Source/timers.c **** 		*pxTimerListsWereSwitched = pdTRUE;
 635              		.loc 1 465 0
 636 002e 7B68     		ldr	r3, [r7, #4]
 637 0030 4FF00102 		mov	r2, #1
 638 0034 1A60     		str	r2, [r3, #0]
 639 0036 03E0     		b	.L34
 640              	.L33:
 466:Source/timers.c **** 	}
 467:Source/timers.c **** 	else
 468:Source/timers.c **** 	{
 469:Source/timers.c **** 		*pxTimerListsWereSwitched = pdFALSE;
 641              		.loc 1 469 0
 642 0038 7B68     		ldr	r3, [r7, #4]
 643 003a 4FF00002 		mov	r2, #0
 644 003e 1A60     		str	r2, [r3, #0]
 645              	.L34:
 470:Source/timers.c **** 	}
 471:Source/timers.c **** 
 472:Source/timers.c **** 	xLastTime = xTimeNow;
 646              		.loc 1 472 0
 647 0040 40F20003 		movw	r3, #:lower16:xLastTime.8300
 648 0044 C0F20003 		movt	r3, #:upper16:xLastTime.8300
 649 0048 FA68     		ldr	r2, [r7, #12]
 650 004a 1A60     		str	r2, [r3, #0]
 473:Source/timers.c **** 
 474:Source/timers.c **** 	return xTimeNow;
 651              		.loc 1 474 0
 652 004c FB68     		ldr	r3, [r7, #12]
 475:Source/timers.c **** }
 653              		.loc 1 475 0
 654 004e 1846     		mov	r0, r3
 655 0050 07F11007 		add	r7, r7, #16
 656 0054 BD46     		mov	sp, r7
 657 0056 80BD     		pop	{r7, pc}
 658              		.cfi_endproc
 659              	.LFE117:
 661              		.section	.text.prvInsertTimerInActiveList,"ax",%progbits
 662              		.align	2
 663              		.thumb
 664              		.thumb_func
 666              	prvInsertTimerInActiveList:
 667              	.LFB118:
 476:Source/timers.c **** /*-----------------------------------------------------------*/
 477:Source/timers.c **** 
 478:Source/timers.c **** static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, por
 479:Source/timers.c **** {
 668              		.loc 1 479 0
 669              		.cfi_startproc
 670              		@ args = 0, pretend = 0, frame = 24
 671              		@ frame_needed = 1, uses_anonymous_args = 0
 672 0000 80B5     		push	{r7, lr}
 673              	.LCFI24:
 674              		.cfi_def_cfa_offset 8
 675              		.cfi_offset 7, -8
 676              		.cfi_offset 14, -4
 677 0002 86B0     		sub	sp, sp, #24
 678              	.LCFI25:
 679              		.cfi_def_cfa_offset 32
 680 0004 00AF     		add	r7, sp, #0
 681              	.LCFI26:
 682              		.cfi_def_cfa_register 7
 683 0006 F860     		str	r0, [r7, #12]
 684 0008 B960     		str	r1, [r7, #8]
 685 000a 7A60     		str	r2, [r7, #4]
 686 000c 3B60     		str	r3, [r7, #0]
 480:Source/timers.c **** portBASE_TYPE xProcessTimerNow = pdFALSE;
 687              		.loc 1 480 0
 688 000e 4FF00003 		mov	r3, #0
 689 0012 7B61     		str	r3, [r7, #20]
 481:Source/timers.c **** 
 482:Source/timers.c **** 	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 690              		.loc 1 482 0
 691 0014 FB68     		ldr	r3, [r7, #12]
 692 0016 BA68     		ldr	r2, [r7, #8]
 693 0018 5A60     		str	r2, [r3, #4]
 483:Source/timers.c **** 	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 694              		.loc 1 483 0
 695 001a FB68     		ldr	r3, [r7, #12]
 696 001c FA68     		ldr	r2, [r7, #12]
 697 001e 1A61     		str	r2, [r3, #16]
 484:Source/timers.c **** 
 485:Source/timers.c **** 	if( xNextExpiryTime <= xTimeNow )
 698              		.loc 1 485 0
 699 0020 BA68     		ldr	r2, [r7, #8]
 700 0022 7B68     		ldr	r3, [r7, #4]
 701 0024 9A42     		cmp	r2, r3
 702 0026 17D8     		bhi	.L37
 486:Source/timers.c **** 	{
 487:Source/timers.c **** 		/* Has the expiry time elapsed between the command to start/reset a
 488:Source/timers.c **** 		timer was issued, and the time the command was processed? */
 489:Source/timers.c **** 		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 703              		.loc 1 489 0
 704 0028 7A68     		ldr	r2, [r7, #4]
 705 002a 3B68     		ldr	r3, [r7, #0]
 706 002c D21A     		subs	r2, r2, r3
 707 002e FB68     		ldr	r3, [r7, #12]
 708 0030 9B69     		ldr	r3, [r3, #24]
 709 0032 9A42     		cmp	r2, r3
 710 0034 03D3     		bcc	.L38
 490:Source/timers.c **** 		{
 491:Source/timers.c **** 			/* The time between a command being issued and the command being
 492:Source/timers.c **** 			processed actually exceeds the timers period.  */
 493:Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 711              		.loc 1 493 0
 712 0036 4FF00103 		mov	r3, #1
 713 003a 7B61     		str	r3, [r7, #20]
 714 003c 24E0     		b	.L39
 715              	.L38:
 494:Source/timers.c **** 		}
 495:Source/timers.c **** 		else
 496:Source/timers.c **** 		{
 497:Source/timers.c **** 			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 716              		.loc 1 497 0
 717 003e 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 718 0042 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 719 0046 1A68     		ldr	r2, [r3, #0]
 720 0048 FB68     		ldr	r3, [r7, #12]
 721 004a 03F10403 		add	r3, r3, #4
 722 004e 1046     		mov	r0, r2
 723 0050 1946     		mov	r1, r3
 724 0052 FFF7FEFF 		bl	vListInsert
 725 0056 17E0     		b	.L39
 726              	.L37:
 498:Source/timers.c **** 		}
 499:Source/timers.c **** 	}
 500:Source/timers.c **** 	else
 501:Source/timers.c **** 	{
 502:Source/timers.c **** 		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 727              		.loc 1 502 0
 728 0058 7A68     		ldr	r2, [r7, #4]
 729 005a 3B68     		ldr	r3, [r7, #0]
 730 005c 9A42     		cmp	r2, r3
 731 005e 07D2     		bcs	.L40
 732              		.loc 1 502 0 is_stmt 0 discriminator 1
 733 0060 BA68     		ldr	r2, [r7, #8]
 734 0062 3B68     		ldr	r3, [r7, #0]
 735 0064 9A42     		cmp	r2, r3
 736 0066 03D3     		bcc	.L40
 503:Source/timers.c **** 		{
 504:Source/timers.c **** 			/* If, since the command was issued, the tick count has overflowed
 505:Source/timers.c **** 			but the expiry time has not, then the timer must have already passed
 506:Source/timers.c **** 			its expiry time and should be processed immediately. */
 507:Source/timers.c **** 			xProcessTimerNow = pdTRUE;
 737              		.loc 1 507 0 is_stmt 1
 738 0068 4FF00103 		mov	r3, #1
 739 006c 7B61     		str	r3, [r7, #20]
 740 006e 0BE0     		b	.L39
 741              	.L40:
 508:Source/timers.c **** 		}
 509:Source/timers.c **** 		else
 510:Source/timers.c **** 		{
 511:Source/timers.c **** 			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 742              		.loc 1 511 0
 743 0070 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 744 0074 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 745 0078 1A68     		ldr	r2, [r3, #0]
 746 007a FB68     		ldr	r3, [r7, #12]
 747 007c 03F10403 		add	r3, r3, #4
 748 0080 1046     		mov	r0, r2
 749 0082 1946     		mov	r1, r3
 750 0084 FFF7FEFF 		bl	vListInsert
 751              	.L39:
 512:Source/timers.c **** 		}
 513:Source/timers.c **** 	}
 514:Source/timers.c **** 
 515:Source/timers.c **** 	return xProcessTimerNow;
 752              		.loc 1 515 0
 753 0088 7B69     		ldr	r3, [r7, #20]
 516:Source/timers.c **** }
 754              		.loc 1 516 0
 755 008a 1846     		mov	r0, r3
 756 008c 07F11807 		add	r7, r7, #24
 757 0090 BD46     		mov	sp, r7
 758 0092 80BD     		pop	{r7, pc}
 759              		.cfi_endproc
 760              	.LFE118:
 762              		.section	.text.prvProcessReceivedCommands,"ax",%progbits
 763              		.align	2
 764              		.thumb
 765              		.thumb_func
 767              	prvProcessReceivedCommands:
 768              	.LFB119:
 517:Source/timers.c **** /*-----------------------------------------------------------*/
 518:Source/timers.c **** 
 519:Source/timers.c **** static void	prvProcessReceivedCommands( void )
 520:Source/timers.c **** {
 769              		.loc 1 520 0
 770              		.cfi_startproc
 771              		@ args = 0, pretend = 0, frame = 32
 772              		@ frame_needed = 1, uses_anonymous_args = 0
 773 0000 80B5     		push	{r7, lr}
 774              	.LCFI27:
 775              		.cfi_def_cfa_offset 8
 776              		.cfi_offset 7, -8
 777              		.cfi_offset 14, -4
 778 0002 8AB0     		sub	sp, sp, #40
 779              	.LCFI28:
 780              		.cfi_def_cfa_offset 48
 781 0004 02AF     		add	r7, sp, #8
 782              	.LCFI29:
 783              		.cfi_def_cfa 7, 40
 521:Source/timers.c **** xTIMER_MESSAGE xMessage;
 522:Source/timers.c **** xTIMER *pxTimer;
 523:Source/timers.c **** portBASE_TYPE xTimerListsWereSwitched, xResult;
 524:Source/timers.c **** portTickType xTimeNow;
 525:Source/timers.c **** 
 526:Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does
 784              		.loc 1 526 0
 785 0006 66E0     		b	.L43
 786              	.L55:
 527:Source/timers.c **** 	{
 528:Source/timers.c **** 		pxTimer = xMessage.pxTimer;
 787              		.loc 1 528 0
 788 0008 3B69     		ldr	r3, [r7, #16]
 789 000a FB61     		str	r3, [r7, #28]
 529:Source/timers.c **** 
 530:Source/timers.c **** 		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 790              		.loc 1 530 0
 791 000c FB69     		ldr	r3, [r7, #28]
 792 000e 5B69     		ldr	r3, [r3, #20]
 793 0010 002B     		cmp	r3, #0
 794 0012 05D0     		beq	.L44
 531:Source/timers.c **** 		{
 532:Source/timers.c **** 			/* The timer is in a list, remove it. */
 533:Source/timers.c **** 			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 795              		.loc 1 533 0
 796 0014 FB69     		ldr	r3, [r7, #28]
 797 0016 03F10403 		add	r3, r3, #4
 798 001a 1846     		mov	r0, r3
 799 001c FFF7FEFF 		bl	uxListRemove
 800              	.L44:
 534:Source/timers.c **** 		}
 535:Source/timers.c **** 
 536:Source/timers.c **** 		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
 537:Source/timers.c **** 
 538:Source/timers.c **** 		/* In this case the xTimerListsWereSwitched parameter is not used, but 
 539:Source/timers.c **** 		it must be present in the function call.  prvSampleTimeNow() must be 
 540:Source/timers.c **** 		called after the message is received from xTimerQueue so there is no 
 541:Source/timers.c **** 		possibility of a higher priority task adding a message to the message
 542:Source/timers.c **** 		queue with a time that is ahead of the timer daemon task (because it
 543:Source/timers.c **** 		pre-empted the timer daemon task after the xTimeNow value was set). */
 544:Source/timers.c **** 		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 801              		.loc 1 544 0
 802 0020 07F10403 		add	r3, r7, #4
 803 0024 1846     		mov	r0, r3
 804 0026 FFF7FEFF 		bl	prvSampleTimeNow
 805 002a B861     		str	r0, [r7, #24]
 545:Source/timers.c **** 
 546:Source/timers.c **** 		switch( xMessage.xMessageID )
 806              		.loc 1 546 0
 807 002c BB68     		ldr	r3, [r7, #8]
 808 002e 032B     		cmp	r3, #3
 809 0030 4ED8     		bhi	.L56
 810 0032 01A2     		adr	r2, .L50
 811 0034 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 812              		.align	2
 813              	.L50:
 814 0038 49000000 		.word	.L46+1
 815 003c D1000000 		.word	.L56+1
 816 0040 9F000000 		.word	.L48+1
 817 0044 C9000000 		.word	.L49+1
 818              	.L46:
 547:Source/timers.c **** 		{
 548:Source/timers.c **** 			case tmrCOMMAND_START :
 549:Source/timers.c **** 				/* Start or restart a timer. */
 550:Source/timers.c **** 				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks
 819              		.loc 1 550 0
 820 0048 FA68     		ldr	r2, [r7, #12]
 821 004a FB69     		ldr	r3, [r7, #28]
 822 004c 9B69     		ldr	r3, [r3, #24]
 823 004e D218     		adds	r2, r2, r3
 824 0050 FB68     		ldr	r3, [r7, #12]
 825 0052 F869     		ldr	r0, [r7, #28]
 826 0054 1146     		mov	r1, r2
 827 0056 BA69     		ldr	r2, [r7, #24]
 828 0058 FFF7FEFF 		bl	prvInsertTimerInActiveList
 829 005c 0346     		mov	r3, r0
 830 005e 012B     		cmp	r3, #1
 831 0060 38D1     		bne	.L57
 551:Source/timers.c **** 				{
 552:Source/timers.c **** 					/* The timer expired before it was added to the active timer
 553:Source/timers.c **** 					list.  Process it now. */
 554:Source/timers.c **** 					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 832              		.loc 1 554 0
 833 0062 FB69     		ldr	r3, [r7, #28]
 834 0064 5B6A     		ldr	r3, [r3, #36]
 835 0066 F869     		ldr	r0, [r7, #28]
 836 0068 9847     		blx	r3
 555:Source/timers.c **** 
 556:Source/timers.c **** 					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 837              		.loc 1 556 0
 838 006a FB69     		ldr	r3, [r7, #28]
 839 006c DB69     		ldr	r3, [r3, #28]
 840 006e 012B     		cmp	r3, #1
 841 0070 30D1     		bne	.L57
 557:Source/timers.c **** 					{
 558:Source/timers.c **** 						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->
 842              		.loc 1 558 0
 843 0072 FA68     		ldr	r2, [r7, #12]
 844 0074 FB69     		ldr	r3, [r7, #28]
 845 0076 9B69     		ldr	r3, [r3, #24]
 846 0078 D318     		adds	r3, r2, r3
 847 007a 4FF00002 		mov	r2, #0
 848 007e 0092     		str	r2, [sp, #0]
 849 0080 F869     		ldr	r0, [r7, #28]
 850 0082 4FF00001 		mov	r1, #0
 851 0086 1A46     		mov	r2, r3
 852 0088 4FF00003 		mov	r3, #0
 853 008c FFF7FEFF 		bl	xTimerGenericCommand
 854 0090 7861     		str	r0, [r7, #20]
 559:Source/timers.c **** 						configASSERT( xResult );
 855              		.loc 1 559 0
 856 0092 7B69     		ldr	r3, [r7, #20]
 857 0094 002B     		cmp	r3, #0
 858 0096 1DD1     		bne	.L57
 859              		.loc 1 559 0 is_stmt 0 discriminator 1
 860 0098 FFF7FEFF 		bl	ulPortSetInterruptMask
 861              	.L52:
 862              		.loc 1 559 0 discriminator 2
 863 009c FEE7     		b	.L52
 864              	.L48:
 560:Source/timers.c **** 						( void ) xResult;
 561:Source/timers.c **** 					}
 562:Source/timers.c **** 				}
 563:Source/timers.c **** 				break;
 564:Source/timers.c **** 
 565:Source/timers.c **** 			case tmrCOMMAND_STOP :
 566:Source/timers.c **** 				/* The timer has already been removed from the active list.
 567:Source/timers.c **** 				There is nothing to do here. */
 568:Source/timers.c **** 				break;
 569:Source/timers.c **** 
 570:Source/timers.c **** 			case tmrCOMMAND_CHANGE_PERIOD :
 571:Source/timers.c **** 				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 865              		.loc 1 571 0 is_stmt 1
 866 009e FA68     		ldr	r2, [r7, #12]
 867 00a0 FB69     		ldr	r3, [r7, #28]
 868 00a2 9A61     		str	r2, [r3, #24]
 572:Source/timers.c **** 				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 869              		.loc 1 572 0
 870 00a4 FB69     		ldr	r3, [r7, #28]
 871 00a6 9B69     		ldr	r3, [r3, #24]
 872 00a8 002B     		cmp	r3, #0
 873 00aa 02D1     		bne	.L53
 874              		.loc 1 572 0 is_stmt 0 discriminator 1
 875 00ac FFF7FEFF 		bl	ulPortSetInterruptMask
 876              	.L54:
 877              		.loc 1 572 0 discriminator 2
 878 00b0 FEE7     		b	.L54
 879              	.L53:
 573:Source/timers.c **** 
 574:Source/timers.c **** 				/* The new period does not really have a reference, and can be
 575:Source/timers.c **** 				longer or shorter than the old one.  The command time is 
 576:Source/timers.c **** 				therefore set to the current time, and as the period cannot be
 577:Source/timers.c **** 				zero the next expiry time can only be in the future, meaning
 578:Source/timers.c **** 				(unlike for the xTimerStart() case above) there is no fail case
 579:Source/timers.c **** 				that needs to be handled here. */
 580:Source/timers.c **** 				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTim
 880              		.loc 1 580 0 is_stmt 1
 881 00b2 FB69     		ldr	r3, [r7, #28]
 882 00b4 9A69     		ldr	r2, [r3, #24]
 883 00b6 BB69     		ldr	r3, [r7, #24]
 884 00b8 D318     		adds	r3, r2, r3
 885 00ba F869     		ldr	r0, [r7, #28]
 886 00bc 1946     		mov	r1, r3
 887 00be BA69     		ldr	r2, [r7, #24]
 888 00c0 BB69     		ldr	r3, [r7, #24]
 889 00c2 FFF7FEFF 		bl	prvInsertTimerInActiveList
 581:Source/timers.c **** 				break;
 890              		.loc 1 581 0
 891 00c6 06E0     		b	.L43
 892              	.L49:
 582:Source/timers.c **** 
 583:Source/timers.c **** 			case tmrCOMMAND_DELETE :
 584:Source/timers.c **** 				/* The timer has already been removed from the active list,
 585:Source/timers.c **** 				just free up the memory. */
 586:Source/timers.c **** 				vPortFree( pxTimer );
 893              		.loc 1 586 0
 894 00c8 F869     		ldr	r0, [r7, #28]
 895 00ca FFF7FEFF 		bl	vPortFree
 587:Source/timers.c **** 				break;
 896              		.loc 1 587 0
 897 00ce 02E0     		b	.L43
 898              	.L56:
 588:Source/timers.c **** 
 589:Source/timers.c **** 			default	:
 590:Source/timers.c **** 				/* Don't expect to get here. */
 591:Source/timers.c **** 				break;
 899              		.loc 1 591 0
 900 00d0 00BF     		nop
 901 00d2 00E0     		b	.L43
 902              	.L57:
 563:Source/timers.c **** 				break;
 903              		.loc 1 563 0
 904 00d4 00BF     		nop
 905              	.L43:
 526:Source/timers.c **** 	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does
 906              		.loc 1 526 0 discriminator 1
 907 00d6 40F20003 		movw	r3, #:lower16:xTimerQueue
 908 00da C0F20003 		movt	r3, #:upper16:xTimerQueue
 909 00de 1A68     		ldr	r2, [r3, #0]
 910 00e0 07F10803 		add	r3, r7, #8
 911 00e4 1046     		mov	r0, r2
 912 00e6 1946     		mov	r1, r3
 913 00e8 4FF00002 		mov	r2, #0
 914 00ec 4FF00003 		mov	r3, #0
 915 00f0 FFF7FEFF 		bl	xQueueGenericReceive
 916 00f4 0346     		mov	r3, r0
 917 00f6 002B     		cmp	r3, #0
 918 00f8 86D1     		bne	.L55
 592:Source/timers.c **** 		}
 593:Source/timers.c **** 	}
 594:Source/timers.c **** }
 919              		.loc 1 594 0
 920 00fa 07F12007 		add	r7, r7, #32
 921 00fe BD46     		mov	sp, r7
 922 0100 80BD     		pop	{r7, pc}
 923              		.cfi_endproc
 924              	.LFE119:
 926 0102 00BF     		.section	.text.prvSwitchTimerLists,"ax",%progbits
 927              		.align	2
 928              		.thumb
 929              		.thumb_func
 931              	prvSwitchTimerLists:
 932              	.LFB120:
 595:Source/timers.c **** /*-----------------------------------------------------------*/
 596:Source/timers.c **** 
 597:Source/timers.c **** static void prvSwitchTimerLists( portTickType xLastTime )
 598:Source/timers.c **** {
 933              		.loc 1 598 0
 934              		.cfi_startproc
 935              		@ args = 0, pretend = 0, frame = 32
 936              		@ frame_needed = 1, uses_anonymous_args = 0
 937 0000 80B5     		push	{r7, lr}
 938              	.LCFI30:
 939              		.cfi_def_cfa_offset 8
 940              		.cfi_offset 7, -8
 941              		.cfi_offset 14, -4
 942 0002 8AB0     		sub	sp, sp, #40
 943              	.LCFI31:
 944              		.cfi_def_cfa_offset 48
 945 0004 02AF     		add	r7, sp, #8
 946              	.LCFI32:
 947              		.cfi_def_cfa 7, 40
 948 0006 7860     		str	r0, [r7, #4]
 599:Source/timers.c **** portTickType xNextExpireTime, xReloadTime;
 600:Source/timers.c **** xList *pxTemp;
 601:Source/timers.c **** xTIMER *pxTimer;
 602:Source/timers.c **** portBASE_TYPE xResult;
 603:Source/timers.c **** 
 604:Source/timers.c **** 	/* Remove compiler warnings if configASSERT() is not defined. */
 605:Source/timers.c **** 	( void ) xLastTime;
 606:Source/timers.c **** 
 607:Source/timers.c **** 	/* The tick count has overflowed.  The timer lists must be switched.
 608:Source/timers.c **** 	If there are any timers still referenced from the current timer list
 609:Source/timers.c **** 	then they must have expired and should be processed before the lists
 610:Source/timers.c **** 	are switched. */
 611:Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 949              		.loc 1 611 0
 950 0008 4BE0     		b	.L59
 951              	.L62:
 612:Source/timers.c **** 	{
 613:Source/timers.c **** 		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 952              		.loc 1 613 0
 953 000a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 954 000e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 955 0012 1B68     		ldr	r3, [r3, #0]
 956 0014 DB68     		ldr	r3, [r3, #12]
 957 0016 1B68     		ldr	r3, [r3, #0]
 958 0018 FB61     		str	r3, [r7, #28]
 614:Source/timers.c **** 
 615:Source/timers.c **** 		/* Remove the timer from the list. */
 616:Source/timers.c **** 		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 959              		.loc 1 616 0
 960 001a 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 961 001e C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 962 0022 1B68     		ldr	r3, [r3, #0]
 963 0024 DB68     		ldr	r3, [r3, #12]
 964 0026 DB68     		ldr	r3, [r3, #12]
 965 0028 BB61     		str	r3, [r7, #24]
 617:Source/timers.c **** 		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 966              		.loc 1 617 0
 967 002a BB69     		ldr	r3, [r7, #24]
 968 002c 03F10403 		add	r3, r3, #4
 969 0030 1846     		mov	r0, r3
 970 0032 FFF7FEFF 		bl	uxListRemove
 618:Source/timers.c **** 
 619:Source/timers.c **** 		/* Execute its callback, then send a command to restart the timer if
 620:Source/timers.c **** 		it is an auto-reload timer.  It cannot be restarted here as the lists
 621:Source/timers.c **** 		have not yet been switched. */
 622:Source/timers.c **** 		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 971              		.loc 1 622 0
 972 0036 BB69     		ldr	r3, [r7, #24]
 973 0038 5B6A     		ldr	r3, [r3, #36]
 974 003a B869     		ldr	r0, [r7, #24]
 975 003c 9847     		blx	r3
 623:Source/timers.c **** 
 624:Source/timers.c **** 		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 976              		.loc 1 624 0
 977 003e BB69     		ldr	r3, [r7, #24]
 978 0040 DB69     		ldr	r3, [r3, #28]
 979 0042 012B     		cmp	r3, #1
 980 0044 2DD1     		bne	.L59
 625:Source/timers.c **** 		{
 626:Source/timers.c **** 			/* Calculate the reload value, and if the reload value results in
 627:Source/timers.c **** 			the timer going into the same timer list then it has already expired
 628:Source/timers.c **** 			and the timer should be re-inserted into the current list so it is
 629:Source/timers.c **** 			processed again within this loop.  Otherwise a command should be sent
 630:Source/timers.c **** 			to restart the timer to ensure it is only inserted into a list after
 631:Source/timers.c **** 			the lists have been swapped. */
 632:Source/timers.c **** 			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 981              		.loc 1 632 0
 982 0046 BB69     		ldr	r3, [r7, #24]
 983 0048 9A69     		ldr	r2, [r3, #24]
 984 004a FB69     		ldr	r3, [r7, #28]
 985 004c D318     		adds	r3, r2, r3
 986 004e 7B61     		str	r3, [r7, #20]
 633:Source/timers.c **** 			if( xReloadTime > xNextExpireTime )
 987              		.loc 1 633 0
 988 0050 7A69     		ldr	r2, [r7, #20]
 989 0052 FB69     		ldr	r3, [r7, #28]
 990 0054 9A42     		cmp	r2, r3
 991 0056 12D9     		bls	.L60
 634:Source/timers.c **** 			{
 635:Source/timers.c **** 				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 992              		.loc 1 635 0
 993 0058 BB69     		ldr	r3, [r7, #24]
 994 005a 7A69     		ldr	r2, [r7, #20]
 995 005c 5A60     		str	r2, [r3, #4]
 636:Source/timers.c **** 				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 996              		.loc 1 636 0
 997 005e BB69     		ldr	r3, [r7, #24]
 998 0060 BA69     		ldr	r2, [r7, #24]
 999 0062 1A61     		str	r2, [r3, #16]
 637:Source/timers.c **** 				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 1000              		.loc 1 637 0
 1001 0064 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1002 0068 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1003 006c 1A68     		ldr	r2, [r3, #0]
 1004 006e BB69     		ldr	r3, [r7, #24]
 1005 0070 03F10403 		add	r3, r3, #4
 1006 0074 1046     		mov	r0, r2
 1007 0076 1946     		mov	r1, r3
 1008 0078 FFF7FEFF 		bl	vListInsert
 1009 007c 11E0     		b	.L59
 1010              	.L60:
 638:Source/timers.c **** 			}
 639:Source/timers.c **** 			else
 640:Source/timers.c **** 			{
 641:Source/timers.c **** 				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY )
 1011              		.loc 1 641 0
 1012 007e 4FF00003 		mov	r3, #0
 1013 0082 0093     		str	r3, [sp, #0]
 1014 0084 B869     		ldr	r0, [r7, #24]
 1015 0086 4FF00001 		mov	r1, #0
 1016 008a FA69     		ldr	r2, [r7, #28]
 1017 008c 4FF00003 		mov	r3, #0
 1018 0090 FFF7FEFF 		bl	xTimerGenericCommand
 1019 0094 3861     		str	r0, [r7, #16]
 642:Source/timers.c **** 				configASSERT( xResult );
 1020              		.loc 1 642 0
 1021 0096 3B69     		ldr	r3, [r7, #16]
 1022 0098 002B     		cmp	r3, #0
 1023 009a 02D1     		bne	.L59
 1024              		.loc 1 642 0 is_stmt 0 discriminator 1
 1025 009c FFF7FEFF 		bl	ulPortSetInterruptMask
 1026              	.L61:
 1027              		.loc 1 642 0 discriminator 2
 1028 00a0 FEE7     		b	.L61
 1029              	.L59:
 611:Source/timers.c **** 	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 1030              		.loc 1 611 0 is_stmt 1 discriminator 1
 1031 00a2 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1032 00a6 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1033 00aa 1B68     		ldr	r3, [r3, #0]
 1034 00ac 1B68     		ldr	r3, [r3, #0]
 1035 00ae 002B     		cmp	r3, #0
 1036 00b0 ABD1     		bne	.L62
 643:Source/timers.c **** 				( void ) xResult;
 644:Source/timers.c **** 			}
 645:Source/timers.c **** 		}
 646:Source/timers.c **** 	}
 647:Source/timers.c **** 
 648:Source/timers.c **** 	pxTemp = pxCurrentTimerList;
 1037              		.loc 1 648 0
 1038 00b2 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1039 00b6 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1040 00ba 1B68     		ldr	r3, [r3, #0]
 1041 00bc FB60     		str	r3, [r7, #12]
 649:Source/timers.c **** 	pxCurrentTimerList = pxOverflowTimerList;
 1042              		.loc 1 649 0
 1043 00be 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1044 00c2 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1045 00c6 1A68     		ldr	r2, [r3, #0]
 1046 00c8 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1047 00cc C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1048 00d0 1A60     		str	r2, [r3, #0]
 650:Source/timers.c **** 	pxOverflowTimerList = pxTemp;
 1049              		.loc 1 650 0
 1050 00d2 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1051 00d6 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1052 00da FA68     		ldr	r2, [r7, #12]
 1053 00dc 1A60     		str	r2, [r3, #0]
 651:Source/timers.c **** }
 1054              		.loc 1 651 0
 1055 00de 07F12007 		add	r7, r7, #32
 1056 00e2 BD46     		mov	sp, r7
 1057 00e4 80BD     		pop	{r7, pc}
 1058              		.cfi_endproc
 1059              	.LFE120:
 1061 00e6 00BF     		.section	.text.prvCheckForValidListAndQueue,"ax",%progbits
 1062              		.align	2
 1063              		.thumb
 1064              		.thumb_func
 1066              	prvCheckForValidListAndQueue:
 1067              	.LFB121:
 652:Source/timers.c **** /*-----------------------------------------------------------*/
 653:Source/timers.c **** 
 654:Source/timers.c **** static void prvCheckForValidListAndQueue( void )
 655:Source/timers.c **** {
 1068              		.loc 1 655 0
 1069              		.cfi_startproc
 1070              		@ args = 0, pretend = 0, frame = 0
 1071              		@ frame_needed = 1, uses_anonymous_args = 0
 1072 0000 80B5     		push	{r7, lr}
 1073              	.LCFI33:
 1074              		.cfi_def_cfa_offset 8
 1075              		.cfi_offset 7, -8
 1076              		.cfi_offset 14, -4
 1077 0002 00AF     		add	r7, sp, #0
 1078              	.LCFI34:
 1079              		.cfi_def_cfa_register 7
 656:Source/timers.c **** 	/* Check that the list from which active timers are referenced, and the
 657:Source/timers.c **** 	queue used to communicate with the timer service, have been
 658:Source/timers.c **** 	initialised. */
 659:Source/timers.c **** 	taskENTER_CRITICAL();
 1080              		.loc 1 659 0
 1081 0004 FFF7FEFF 		bl	vPortEnterCritical
 660:Source/timers.c **** 	{
 661:Source/timers.c **** 		if( xTimerQueue == NULL )
 1082              		.loc 1 661 0
 1083 0008 40F20003 		movw	r3, #:lower16:xTimerQueue
 1084 000c C0F20003 		movt	r3, #:upper16:xTimerQueue
 1085 0010 1B68     		ldr	r3, [r3, #0]
 1086 0012 002B     		cmp	r3, #0
 1087 0014 2BD1     		bne	.L64
 662:Source/timers.c **** 		{
 663:Source/timers.c **** 			vListInitialise( &xActiveTimerList1 );
 1088              		.loc 1 663 0
 1089 0016 40F20000 		movw	r0, #:lower16:xActiveTimerList1
 1090 001a C0F20000 		movt	r0, #:upper16:xActiveTimerList1
 1091 001e FFF7FEFF 		bl	vListInitialise
 664:Source/timers.c **** 			vListInitialise( &xActiveTimerList2 );
 1092              		.loc 1 664 0
 1093 0022 40F20000 		movw	r0, #:lower16:xActiveTimerList2
 1094 0026 C0F20000 		movt	r0, #:upper16:xActiveTimerList2
 1095 002a FFF7FEFF 		bl	vListInitialise
 665:Source/timers.c **** 			pxCurrentTimerList = &xActiveTimerList1;
 1096              		.loc 1 665 0
 1097 002e 40F20003 		movw	r3, #:lower16:pxCurrentTimerList
 1098 0032 C0F20003 		movt	r3, #:upper16:pxCurrentTimerList
 1099 0036 40F20002 		movw	r2, #:lower16:xActiveTimerList1
 1100 003a C0F20002 		movt	r2, #:upper16:xActiveTimerList1
 1101 003e 1A60     		str	r2, [r3, #0]
 666:Source/timers.c **** 			pxOverflowTimerList = &xActiveTimerList2;
 1102              		.loc 1 666 0
 1103 0040 40F20003 		movw	r3, #:lower16:pxOverflowTimerList
 1104 0044 C0F20003 		movt	r3, #:upper16:pxOverflowTimerList
 1105 0048 40F20002 		movw	r2, #:lower16:xActiveTimerList2
 1106 004c C0F20002 		movt	r2, #:upper16:xActiveTimerList2
 1107 0050 1A60     		str	r2, [r3, #0]
 667:Source/timers.c **** 			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_
 1108              		.loc 1 667 0
 1109 0052 4FF00A00 		mov	r0, #10
 1110 0056 4FF00C01 		mov	r1, #12
 1111 005a 4FF00002 		mov	r2, #0
 1112 005e FFF7FEFF 		bl	xQueueGenericCreate
 1113 0062 0246     		mov	r2, r0
 1114 0064 40F20003 		movw	r3, #:lower16:xTimerQueue
 1115 0068 C0F20003 		movt	r3, #:upper16:xTimerQueue
 1116 006c 1A60     		str	r2, [r3, #0]
 1117              	.L64:
 668:Source/timers.c **** 		}
 669:Source/timers.c **** 	}
 670:Source/timers.c **** 	taskEXIT_CRITICAL();
 1118              		.loc 1 670 0
 1119 006e FFF7FEFF 		bl	vPortExitCritical
 671:Source/timers.c **** }
 1120              		.loc 1 671 0
 1121 0072 80BD     		pop	{r7, pc}
 1122              		.cfi_endproc
 1123              	.LFE121:
 1125              		.section	.text.xTimerIsTimerActive,"ax",%progbits
 1126              		.align	2
 1127              		.global	xTimerIsTimerActive
 1128              		.thumb
 1129              		.thumb_func
 1131              	xTimerIsTimerActive:
 1132              	.LFB122:
 672:Source/timers.c **** /*-----------------------------------------------------------*/
 673:Source/timers.c **** 
 674:Source/timers.c **** portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
 675:Source/timers.c **** {
 1133              		.loc 1 675 0
 1134              		.cfi_startproc
 1135              		@ args = 0, pretend = 0, frame = 16
 1136              		@ frame_needed = 1, uses_anonymous_args = 0
 1137 0000 80B5     		push	{r7, lr}
 1138              	.LCFI35:
 1139              		.cfi_def_cfa_offset 8
 1140              		.cfi_offset 7, -8
 1141              		.cfi_offset 14, -4
 1142 0002 84B0     		sub	sp, sp, #16
 1143              	.LCFI36:
 1144              		.cfi_def_cfa_offset 24
 1145 0004 00AF     		add	r7, sp, #0
 1146              	.LCFI37:
 1147              		.cfi_def_cfa_register 7
 1148 0006 7860     		str	r0, [r7, #4]
 676:Source/timers.c **** portBASE_TYPE xTimerIsInActiveList;
 677:Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1149              		.loc 1 677 0
 1150 0008 7B68     		ldr	r3, [r7, #4]
 1151 000a FB60     		str	r3, [r7, #12]
 678:Source/timers.c **** 
 679:Source/timers.c **** 	/* Is the timer in the list of active timers? */
 680:Source/timers.c **** 	taskENTER_CRITICAL();
 1152              		.loc 1 680 0
 1153 000c FFF7FEFF 		bl	vPortEnterCritical
 681:Source/timers.c **** 	{
 682:Source/timers.c **** 		/* Checking to see if it is in the NULL list in effect checks to see if
 683:Source/timers.c **** 		it is referenced from either the current or the overflow timer lists in
 684:Source/timers.c **** 		one go, but the logic has to be reversed, hence the '!'. */
 685:Source/timers.c **** 		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 1154              		.loc 1 685 0
 1155 0010 FB68     		ldr	r3, [r7, #12]
 1156 0012 5B69     		ldr	r3, [r3, #20]
 1157 0014 002B     		cmp	r3, #0
 1158 0016 0CBF     		ite	eq
 1159 0018 0023     		moveq	r3, #0
 1160 001a 0123     		movne	r3, #1
 1161 001c DBB2     		uxtb	r3, r3
 1162 001e BB60     		str	r3, [r7, #8]
 686:Source/timers.c **** 	}
 687:Source/timers.c **** 	taskEXIT_CRITICAL();
 1163              		.loc 1 687 0
 1164 0020 FFF7FEFF 		bl	vPortExitCritical
 688:Source/timers.c **** 
 689:Source/timers.c **** 	return xTimerIsInActiveList;
 1165              		.loc 1 689 0
 1166 0024 BB68     		ldr	r3, [r7, #8]
 690:Source/timers.c **** }
 1167              		.loc 1 690 0
 1168 0026 1846     		mov	r0, r3
 1169 0028 07F11007 		add	r7, r7, #16
 1170 002c BD46     		mov	sp, r7
 1171 002e 80BD     		pop	{r7, pc}
 1172              		.cfi_endproc
 1173              	.LFE122:
 1175              		.section	.text.pvTimerGetTimerID,"ax",%progbits
 1176              		.align	2
 1177              		.global	pvTimerGetTimerID
 1178              		.thumb
 1179              		.thumb_func
 1181              	pvTimerGetTimerID:
 1182              	.LFB123:
 691:Source/timers.c **** /*-----------------------------------------------------------*/
 692:Source/timers.c **** 
 693:Source/timers.c **** void *pvTimerGetTimerID( xTimerHandle xTimer )
 694:Source/timers.c **** {
 1183              		.loc 1 694 0
 1184              		.cfi_startproc
 1185              		@ args = 0, pretend = 0, frame = 16
 1186              		@ frame_needed = 1, uses_anonymous_args = 0
 1187              		@ link register save eliminated.
 1188 0000 80B4     		push	{r7}
 1189              	.LCFI38:
 1190              		.cfi_def_cfa_offset 4
 1191              		.cfi_offset 7, -4
 1192 0002 85B0     		sub	sp, sp, #20
 1193              	.LCFI39:
 1194              		.cfi_def_cfa_offset 24
 1195 0004 00AF     		add	r7, sp, #0
 1196              	.LCFI40:
 1197              		.cfi_def_cfa_register 7
 1198 0006 7860     		str	r0, [r7, #4]
 695:Source/timers.c **** xTIMER *pxTimer = ( xTIMER * ) xTimer;
 1199              		.loc 1 695 0
 1200 0008 7B68     		ldr	r3, [r7, #4]
 1201 000a FB60     		str	r3, [r7, #12]
 696:Source/timers.c **** 
 697:Source/timers.c **** 	return pxTimer->pvTimerID;
 1202              		.loc 1 697 0
 1203 000c FB68     		ldr	r3, [r7, #12]
 1204 000e 1B6A     		ldr	r3, [r3, #32]
 698:Source/timers.c **** }
 1205              		.loc 1 698 0
 1206 0010 1846     		mov	r0, r3
 1207 0012 07F11407 		add	r7, r7, #20
 1208 0016 BD46     		mov	sp, r7
 1209 0018 80BC     		pop	{r7}
 1210 001a 7047     		bx	lr
 1211              		.cfi_endproc
 1212              	.LFE123:
 1214              		.section	.bss.xLastTime.8300,"aw",%nobits
 1215              		.align	2
 1218              	xLastTime.8300:
 1219 0000 00000000 		.space	4
 1220              		.text
 1221              	.Letext0:
 1222              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 1223              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 1224              		.file 4 "Source/include/list.h"
 1225              		.file 5 "Source/include/queue.h"
 1226              		.file 6 "Source/include/timers.h"
 1227              		.file 7 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/ccAXJBMV.s:20     .bss.xActiveTimerList1:00000000 $d
     /tmp/ccAXJBMV.s:23     .bss.xActiveTimerList1:00000000 xActiveTimerList1
     /tmp/ccAXJBMV.s:26     .bss.xActiveTimerList2:00000000 $d
     /tmp/ccAXJBMV.s:29     .bss.xActiveTimerList2:00000000 xActiveTimerList2
     /tmp/ccAXJBMV.s:32     .bss.pxCurrentTimerList:00000000 $d
     /tmp/ccAXJBMV.s:35     .bss.pxCurrentTimerList:00000000 pxCurrentTimerList
     /tmp/ccAXJBMV.s:38     .bss.pxOverflowTimerList:00000000 $d
     /tmp/ccAXJBMV.s:41     .bss.pxOverflowTimerList:00000000 pxOverflowTimerList
     /tmp/ccAXJBMV.s:44     .bss.xTimerQueue:00000000 $d
     /tmp/ccAXJBMV.s:47     .bss.xTimerQueue:00000000 xTimerQueue
     /tmp/ccAXJBMV.s:50     .rodata:00000000 $d
     /tmp/ccAXJBMV.s:51     .rodata:00000000 .LC0
     /tmp/ccAXJBMV.s:54     .text.xTimerCreateTimerTask:00000000 $t
     /tmp/ccAXJBMV.s:59     .text.xTimerCreateTimerTask:00000000 xTimerCreateTimerTask
     /tmp/ccAXJBMV.s:1066   .text.prvCheckForValidListAndQueue:00000000 prvCheckForValidListAndQueue
     /tmp/ccAXJBMV.s:410    .text.prvTimerTask:00000000 prvTimerTask
     /tmp/ccAXJBMV.s:127    .text.xTimerCreate:00000000 $t
     /tmp/ccAXJBMV.s:132    .text.xTimerCreate:00000000 xTimerCreate
     /tmp/ccAXJBMV.s:219    .text.xTimerGenericCommand:00000000 $t
     /tmp/ccAXJBMV.s:224    .text.xTimerGenericCommand:00000000 xTimerGenericCommand
     /tmp/ccAXJBMV.s:321    .text.prvProcessExpiredTimer:00000000 $t
     /tmp/ccAXJBMV.s:325    .text.prvProcessExpiredTimer:00000000 prvProcessExpiredTimer
     /tmp/ccAXJBMV.s:666    .text.prvInsertTimerInActiveList:00000000 prvInsertTimerInActiveList
     /tmp/ccAXJBMV.s:406    .text.prvTimerTask:00000000 $t
     /tmp/ccAXJBMV.s:536    .text.prvGetNextExpireTime:00000000 prvGetNextExpireTime
     /tmp/ccAXJBMV.s:451    .text.prvProcessTimerOrBlockTask:00000000 prvProcessTimerOrBlockTask
     /tmp/ccAXJBMV.s:767    .text.prvProcessReceivedCommands:00000000 prvProcessReceivedCommands
     /tmp/ccAXJBMV.s:447    .text.prvProcessTimerOrBlockTask:00000000 $t
     /tmp/ccAXJBMV.s:601    .text.prvSampleTimeNow:00000000 prvSampleTimeNow
     /tmp/ccAXJBMV.s:532    .text.prvGetNextExpireTime:00000000 $t
     /tmp/ccAXJBMV.s:597    .text.prvSampleTimeNow:00000000 $t
     /tmp/ccAXJBMV.s:1218   .bss.xLastTime.8300:00000000 xLastTime.8300
     /tmp/ccAXJBMV.s:931    .text.prvSwitchTimerLists:00000000 prvSwitchTimerLists
     /tmp/ccAXJBMV.s:662    .text.prvInsertTimerInActiveList:00000000 $t
     /tmp/ccAXJBMV.s:763    .text.prvProcessReceivedCommands:00000000 $t
     /tmp/ccAXJBMV.s:814    .text.prvProcessReceivedCommands:00000038 $d
     /tmp/ccAXJBMV.s:820    .text.prvProcessReceivedCommands:00000048 $t
     /tmp/ccAXJBMV.s:927    .text.prvSwitchTimerLists:00000000 $t
     /tmp/ccAXJBMV.s:1062   .text.prvCheckForValidListAndQueue:00000000 $t
     /tmp/ccAXJBMV.s:1126   .text.xTimerIsTimerActive:00000000 $t
     /tmp/ccAXJBMV.s:1131   .text.xTimerIsTimerActive:00000000 xTimerIsTimerActive
     /tmp/ccAXJBMV.s:1176   .text.pvTimerGetTimerID:00000000 $t
     /tmp/ccAXJBMV.s:1181   .text.pvTimerGetTimerID:00000000 pvTimerGetTimerID
     /tmp/ccAXJBMV.s:1215   .bss.xLastTime.8300:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericCreate
ulPortSetInterruptMask
pvPortMalloc
vListInitialiseItem
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
uxListRemove
vTaskSuspendAll
xTaskResumeAll
vQueueWaitForMessageRestricted
vPortYield
xTaskGetTickCount
vListInsert
vPortFree
xQueueGenericReceive
vPortEnterCritical
vListInitialise
xQueueGenericCreate
vPortExitCritical
