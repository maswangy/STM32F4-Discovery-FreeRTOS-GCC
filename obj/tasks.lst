   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.global	pxCurrentTCB
  20              		.section	.bss.pxCurrentTCB,"aw",%nobits
  21              		.align	2
  24              	pxCurrentTCB:
  25 0000 00000000 		.space	4
  26              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  27              		.align	2
  30              	pxReadyTasksLists:
  31 0000 00000000 		.space	100
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  33              		.align	2
  36              	xDelayedTaskList1:
  37 0000 00000000 		.space	20
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList2:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  45              		.align	2
  48              	pxDelayedTaskList:
  49 0000 00000000 		.space	4
  50              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxOverflowDelayedTaskList:
  55 0000 00000000 		.space	4
  56              		.section	.bss.xPendingReadyList,"aw",%nobits
  57              		.align	2
  60              	xPendingReadyList:
  61 0000 00000000 		.space	20
  61      00000000 
  61      00000000 
  61      00000000 
  61      00000000 
  62              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  63              		.align	2
  66              	xTasksWaitingTermination:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.uxTasksDeleted,"aw",%nobits
  69              		.align	2
  72              	uxTasksDeleted:
  73 0000 00000000 		.space	4
  74              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  75              		.align	2
  78              	xSuspendedTaskList:
  79 0000 00000000 		.space	20
  79      00000000 
  79      00000000 
  79      00000000 
  79      00000000 
  80              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  81              		.align	2
  84              	uxCurrentNumberOfTasks:
  85 0000 00000000 		.space	4
  86              		.section	.bss.xTickCount,"aw",%nobits
  87              		.align	2
  90              	xTickCount:
  91 0000 00000000 		.space	4
  92              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  93              		.align	2
  96              	uxTopReadyPriority:
  97 0000 00000000 		.space	4
  98              		.section	.bss.xSchedulerRunning,"aw",%nobits
  99              		.align	2
 102              	xSchedulerRunning:
 103 0000 00000000 		.space	4
 104              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 105              		.align	2
 108              	uxSchedulerSuspended:
 109 0000 00000000 		.space	4
 110              		.section	.bss.uxPendedTicks,"aw",%nobits
 111              		.align	2
 114              	uxPendedTicks:
 115 0000 00000000 		.space	4
 116              		.section	.bss.xYieldPending,"aw",%nobits
 117              		.align	2
 120              	xYieldPending:
 121 0000 00000000 		.space	4
 122              		.section	.bss.xNumOfOverflows,"aw",%nobits
 123              		.align	2
 126              	xNumOfOverflows:
 127 0000 00000000 		.space	4
 128              		.section	.bss.uxTaskNumber,"aw",%nobits
 129              		.align	2
 132              	uxTaskNumber:
 133 0000 00000000 		.space	4
 134              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 135              		.align	2
 138              	xNextTaskUnblockTime:
 139 0000 FFFFFFFF 		.word	-1
 140              		.section	.text.xTaskGenericCreate,"ax",%progbits
 141              		.align	2
 142              		.global	xTaskGenericCreate
 143              		.thumb
 144              		.thumb_func
 146              	xTaskGenericCreate:
 147              	.LFB110:
 148              		.file 1 "Source/tasks.c"
   1:Source/tasks.c **** /*
   2:Source/tasks.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/tasks.c ****     All rights reserved
   4:Source/tasks.c **** 
   5:Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/tasks.c **** 
   7:Source/tasks.c ****     ***************************************************************************
   8:Source/tasks.c ****      *                                                                       *
   9:Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/tasks.c ****      *    platform software that has become a de facto standard.             *
  12:Source/tasks.c ****      *                                                                       *
  13:Source/tasks.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/tasks.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/tasks.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/tasks.c ****      *                                                                       *
  17:Source/tasks.c ****      *    Thank you!                                                         *
  18:Source/tasks.c ****      *                                                                       *
  19:Source/tasks.c ****     ***************************************************************************
  20:Source/tasks.c **** 
  21:Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  22:Source/tasks.c **** 
  23:Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/tasks.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/tasks.c **** 
  27:Source/tasks.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/tasks.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/tasks.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/tasks.c ****     >>! kernel.
  31:Source/tasks.c **** 
  32:Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  36:Source/tasks.c **** 
  37:Source/tasks.c ****     1 tab == 4 spaces!
  38:Source/tasks.c **** 
  39:Source/tasks.c ****     ***************************************************************************
  40:Source/tasks.c ****      *                                                                       *
  41:Source/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/tasks.c ****      *    not run, what could be wrong?"                                     *
  43:Source/tasks.c ****      *                                                                       *
  44:Source/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/tasks.c ****      *                                                                       *
  46:Source/tasks.c ****     ***************************************************************************
  47:Source/tasks.c **** 
  48:Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/tasks.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/tasks.c **** 
  51:Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/tasks.c **** 
  55:Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/tasks.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/tasks.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/tasks.c **** 
  59:Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/tasks.c ****     mission critical applications that require provable dependability.
  62:Source/tasks.c **** 
  63:Source/tasks.c ****     1 tab == 4 spaces!
  64:Source/tasks.c **** */
  65:Source/tasks.c **** 
  66:Source/tasks.c **** /* Standard includes. */
  67:Source/tasks.c **** #include <stdlib.h>
  68:Source/tasks.c **** #include <string.h>
  69:Source/tasks.c **** 
  70:Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  71:Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  72:Source/tasks.c **** task.h is included from an application file. */
  73:Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  74:Source/tasks.c **** 
  75:Source/tasks.c **** /* FreeRTOS includes. */
  76:Source/tasks.c **** #include "FreeRTOS.h"
  77:Source/tasks.c **** #include "task.h"
  78:Source/tasks.c **** #include "timers.h"
  79:Source/tasks.c **** #include "StackMacros.h"
  80:Source/tasks.c **** 
  81:Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  82:Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  83:Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  84:Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  85:Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  86:Source/tasks.c **** 
  87:Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  88:Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  89:Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  90:Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  91:Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  92:Source/tasks.c **** 	#include <stdio.h>
  93:Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  94:Source/tasks.c **** 
  95:Source/tasks.c **** /* Sanity check the configuration. */
  96:Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
  97:Source/tasks.c **** 	#if INCLUDE_vTaskSuspend != 1
  98:Source/tasks.c **** 		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
  99:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
 100:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
 101:Source/tasks.c **** 
 102:Source/tasks.c **** /*
 103:Source/tasks.c ****  * Defines the size, in words, of the stack allocated to the idle task.
 104:Source/tasks.c ****  */
 105:Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
 106:Source/tasks.c **** 
 107:Source/tasks.c **** /*
 108:Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 109:Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 110:Source/tasks.c ****  * (the task's run time environment, including register values)
 111:Source/tasks.c ****  */
 112:Source/tasks.c **** typedef struct tskTaskControlBlock
 113:Source/tasks.c **** {
 114:Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
 115:Source/tasks.c **** 
 116:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 117:Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 118:Source/tasks.c **** 	#endif
 119:Source/tasks.c **** 
 120:Source/tasks.c **** 	xListItem				xGenericListItem;	/*< The list that the state list item of a task is reference from d
 121:Source/tasks.c **** 	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
 122:Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 123:Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 124:Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 125:Source/tasks.c **** 
 126:Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 127:Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the sta
 128:Source/tasks.c **** 	#endif
 129:Source/tasks.c **** 
 130:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 131:Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports 
 132:Source/tasks.c **** 	#endif
 133:Source/tasks.c **** 
 134:Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 135:Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is create
 136:Source/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party tra
 137:Source/tasks.c **** 	#endif
 138:Source/tasks.c **** 
 139:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 140:Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 141:Source/tasks.c **** 	#endif
 142:Source/tasks.c **** 
 143:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 144:Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 145:Source/tasks.c **** 	#endif
 146:Source/tasks.c **** 
 147:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 148:Source/tasks.c **** 		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running
 149:Source/tasks.c **** 	#endif
 150:Source/tasks.c **** 
 151:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 152:Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 153:Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 154:Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 155:Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 156:Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 157:Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 158:Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 159:Source/tasks.c **** 		struct _reent xNewLib_reent;
 160:Source/tasks.c **** 	#endif
 161:Source/tasks.c **** 
 162:Source/tasks.c **** } tskTCB;
 163:Source/tasks.c **** 
 164:Source/tasks.c **** 
 165:Source/tasks.c **** /*
 166:Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 167:Source/tasks.c ****  * be global, rather than file scope.
 168:Source/tasks.c ****  */
 169:Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 170:Source/tasks.c **** 	#define static
 171:Source/tasks.c **** #endif
 172:Source/tasks.c **** 
 173:Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 174:Source/tasks.c **** static variables must be declared volatile. */
 175:Source/tasks.c **** 
 176:Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 177:Source/tasks.c **** 
 178:Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 179:Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 180:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 181:Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 182:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList;				/*< Points to the delayed task list c
 183:Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 184:Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 185:Source/tasks.c **** 
 186:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 187:Source/tasks.c **** 
 188:Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 189:Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 190:Source/tasks.c **** 
 191:Source/tasks.c **** #endif
 192:Source/tasks.c **** 
 193:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 194:Source/tasks.c **** 
 195:Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 196:Source/tasks.c **** 
 197:Source/tasks.c **** #endif
 198:Source/tasks.c **** 
 199:Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 200:Source/tasks.c **** 
 201:Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task
 202:Source/tasks.c **** 
 203:Source/tasks.c **** #endif
 204:Source/tasks.c **** 
 205:Source/tasks.c **** /* Other file private variables. --------------------------------*/
 206:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 207:Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 208:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 209:Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 210:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 211:Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxPendedTicks 			= ( unsigned portBASE_TYPE 
 212:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xYieldPending 					= pdFALSE;
 213:Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 214:Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 215:Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= portMAX_DELAY;
 216:Source/tasks.c **** 
 217:Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 218:Source/tasks.c **** 
 219:Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 220:Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTotalRunTime = 0UL;			/*< Holds the total amount of executi
 221:Source/tasks.c **** 
 222:Source/tasks.c **** #endif
 223:Source/tasks.c **** 
 224:Source/tasks.c **** /*lint +e956 */
 225:Source/tasks.c **** 
 226:Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 227:Source/tasks.c **** 
 228:Source/tasks.c **** /*
 229:Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 230:Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 231:Source/tasks.c ****  */
 232:Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 233:Source/tasks.c **** 
 234:Source/tasks.c **** /*
 235:Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 236:Source/tasks.c ****  */
 237:Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 238:Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 239:Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 240:Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 241:Source/tasks.c **** 
 242:Source/tasks.c **** /*-----------------------------------------------------------*/
 243:Source/tasks.c **** 
 244:Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 245:Source/tasks.c **** 
 246:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 247:Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 248:Source/tasks.c **** 	microcontroller architecture. */
 249:Source/tasks.c **** 
 250:Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 251:Source/tasks.c **** 	state task. */
 252:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
 253:Source/tasks.c **** 	{																													\
 254:Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )																		\
 255:Source/tasks.c **** 		{																												\
 256:Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );																		\
 257:Source/tasks.c **** 		}																												\
 258:Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 259:Source/tasks.c **** 
 260:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 261:Source/tasks.c **** 
 262:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
 263:Source/tasks.c **** 	{																													\
 264:Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */												\
 265:Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
 266:Source/tasks.c **** 		{																												\
 267:Source/tasks.c **** 			configASSERT( uxTopReadyPriority );																			\
 268:Source/tasks.c **** 			--uxTopReadyPriority;																						\
 269:Source/tasks.c **** 		}																												\
 270:Source/tasks.c **** 																														\
 271:Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
 272:Source/tasks.c **** 		the	same priority get an equal share of the processor time. */													\
 273:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
 274:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 275:Source/tasks.c **** 
 276:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 277:Source/tasks.c **** 
 278:Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 279:Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 280:Source/tasks.c **** 	being used. */
 281:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 282:Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 283:Source/tasks.c **** 
 284:Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 285:Source/tasks.c **** 
 286:Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 287:Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 288:Source/tasks.c **** 	architecture being used. */
 289:Source/tasks.c **** 
 290:Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 291:Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 292:Source/tasks.c **** 
 293:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 294:Source/tasks.c **** 
 295:Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 296:Source/tasks.c **** 	{																								\
 297:Source/tasks.c **** 	unsigned portBASE_TYPE uxTopPriority;															\
 298:Source/tasks.c **** 																									\
 299:Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */							\
 300:Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 301:Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 302:Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 303:Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 304:Source/tasks.c **** 
 305:Source/tasks.c **** 	/*-----------------------------------------------------------*/
 306:Source/tasks.c **** 
 307:Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 308:Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 309:Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 310:Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )													\
 311:Source/tasks.c **** 	{																								\
 312:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
 313:Source/tasks.c **** 		{																							\
 314:Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
 315:Source/tasks.c **** 		}																							\
 316:Source/tasks.c **** 	}
 317:Source/tasks.c **** 
 318:Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 319:Source/tasks.c **** 
 320:Source/tasks.c **** /*-----------------------------------------------------------*/
 321:Source/tasks.c **** 
 322:Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 323:Source/tasks.c **** count overflows. */
 324:Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 325:Source/tasks.c **** {																									\
 326:Source/tasks.c **** 	xList *pxTemp;																					\
 327:Source/tasks.c **** 																									\
 328:Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 329:Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 330:Source/tasks.c **** 																									\
 331:Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 332:Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 333:Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 334:Source/tasks.c **** 	xNumOfOverflows++;																				\
 335:Source/tasks.c **** 																									\
 336:Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )											\
 337:Source/tasks.c **** 	{																								\
 338:Source/tasks.c **** 		/* The new current delayed list is empty.  Set												\
 339:Source/tasks.c **** 		xNextTaskUnblockTime to the maximum possible value so it is									\
 340:Source/tasks.c **** 		extremely unlikely that the																	\
 341:Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until								\
 342:Source/tasks.c **** 		there is an item in the delayed list. */													\
 343:Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;														\
 344:Source/tasks.c **** 	}																								\
 345:Source/tasks.c **** 	else																							\
 346:Source/tasks.c **** 	{																								\
 347:Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of								\
 348:Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at								\
 349:Source/tasks.c **** 		which the task at the head of the delayed list should be removed							\
 350:Source/tasks.c **** 		from the Blocked state. */																	\
 351:Source/tasks.c **** 		pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );						\
 352:Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );				\
 353:Source/tasks.c **** 	}																								\
 354:Source/tasks.c **** }
 355:Source/tasks.c **** 
 356:Source/tasks.c **** /*-----------------------------------------------------------*/
 357:Source/tasks.c **** 
 358:Source/tasks.c **** /*
 359:Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 360:Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 361:Source/tasks.c ****  */
 362:Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																				\
 363:Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
 364:Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
 365:Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) 
 366:Source/tasks.c **** /*-----------------------------------------------------------*/
 367:Source/tasks.c **** 
 368:Source/tasks.c **** /*
 369:Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 370:Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 371:Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 372:Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 373:Source/tasks.c ****  */
 374:Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 375:Source/tasks.c **** 
 376:Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 377:Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName );
 378:Source/tasks.c **** extern void vApplicationTickHook( void );
 379:Source/tasks.c **** 
 380:Source/tasks.c **** /* File private functions. --------------------------------*/
 381:Source/tasks.c **** 
 382:Source/tasks.c **** /*
 383:Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 384:Source/tasks.c ****  * into the TCB structure.
 385:Source/tasks.c ****  */
 386:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 387:Source/tasks.c **** 
 388:Source/tasks.c **** /*
 389:Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 390:Source/tasks.c ****  * automatically upon the creation of the first task.
 391:Source/tasks.c ****  */
 392:Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 393:Source/tasks.c **** 
 394:Source/tasks.c **** /*
 395:Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 396:Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 397:Source/tasks.c ****  * creation of the first user task.
 398:Source/tasks.c ****  *
 399:Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 400:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 401:Source/tasks.c ****  *
 402:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 403:Source/tasks.c ****  *
 404:Source/tasks.c ****  */
 405:Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 406:Source/tasks.c **** 
 407:Source/tasks.c **** /*
 408:Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 409:Source/tasks.c ****  * including the stack pointed to by the TCB.
 410:Source/tasks.c ****  *
 411:Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 412:Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 413:Source/tasks.c ****  */
 414:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 415:Source/tasks.c **** 
 416:Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 417:Source/tasks.c **** 
 418:Source/tasks.c **** #endif
 419:Source/tasks.c **** 
 420:Source/tasks.c **** /*
 421:Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 422:Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 423:Source/tasks.c ****  * and its TCB deleted.
 424:Source/tasks.c ****  */
 425:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 426:Source/tasks.c **** 
 427:Source/tasks.c **** /*
 428:Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 429:Source/tasks.c ****  * either the current or the overflow delayed task list.
 430:Source/tasks.c ****  */
 431:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 432:Source/tasks.c **** 
 433:Source/tasks.c **** /*
 434:Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 435:Source/tasks.c ****  * allocation was successful.
 436:Source/tasks.c ****  */
 437:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 438:Source/tasks.c **** 
 439:Source/tasks.c **** /*
 440:Source/tasks.c ****  * Fills an xTaskStatusType structure with information on each task that is
 441:Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 442:Source/tasks.c ****  * a suspended list, etc.).
 443:Source/tasks.c ****  *
 444:Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 445:Source/tasks.c ****  * NORMAL APPLICATION CODE.
 446:Source/tasks.c ****  */
 447:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 448:Source/tasks.c **** 
 449:Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
 450:Source/tasks.c **** 
 451:Source/tasks.c **** #endif
 452:Source/tasks.c **** 
 453:Source/tasks.c **** /*
 454:Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 455:Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 456:Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 457:Source/tasks.c ****  */
 458:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 459:Source/tasks.c **** 
 460:Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_
 461:Source/tasks.c **** 
 462:Source/tasks.c **** #endif
 463:Source/tasks.c **** 
 464:Source/tasks.c **** /*
 465:Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 466:Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 467:Source/tasks.c ****  *
 468:Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 469:Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 470:Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 471:Source/tasks.c ****  * set to a value other than 1.
 472:Source/tasks.c ****  */
 473:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 474:Source/tasks.c **** 
 475:Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 476:Source/tasks.c **** 
 477:Source/tasks.c **** #endif
 478:Source/tasks.c **** 
 479:Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 480:Source/tasks.c **** {
 149              		.loc 1 480 0
 150              		.cfi_startproc
 151              		@ args = 16, pretend = 0, frame = 32
 152              		@ frame_needed = 1, uses_anonymous_args = 0
 153 0000 80B5     		push	{r7, lr}
 154              	.LCFI0:
 155              		.cfi_def_cfa_offset 8
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8AB0     		sub	sp, sp, #40
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 48
 161 0004 02AF     		add	r7, sp, #8
 162              	.LCFI2:
 163              		.cfi_def_cfa 7, 40
 164 0006 F860     		str	r0, [r7, #12]
 165 0008 B960     		str	r1, [r7, #8]
 166 000a 3B60     		str	r3, [r7, #0]
 167 000c 1346     		mov	r3, r2	@ movhi
 168 000e FB80     		strh	r3, [r7, #6]	@ movhi
 481:Source/tasks.c **** signed portBASE_TYPE xReturn;
 482:Source/tasks.c **** tskTCB * pxNewTCB;
 483:Source/tasks.c **** 
 484:Source/tasks.c **** 	configASSERT( pxTaskCode );
 169              		.loc 1 484 0
 170 0010 FB68     		ldr	r3, [r7, #12]
 171 0012 002B     		cmp	r3, #0
 172 0014 02D1     		bne	.L2
 173              		.loc 1 484 0 is_stmt 0 discriminator 1
 174 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 175              	.L3:
 176              		.loc 1 484 0 discriminator 2
 177 001a FEE7     		b	.L3
 178              	.L2:
 485:Source/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 179              		.loc 1 485 0 is_stmt 1
 180 001c BB6A     		ldr	r3, [r7, #40]
 181 001e 042B     		cmp	r3, #4
 182 0020 02D9     		bls	.L4
 183              		.loc 1 485 0 is_stmt 0 discriminator 1
 184 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 185              	.L5:
 186              		.loc 1 485 0 discriminator 2
 187 0026 FEE7     		b	.L5
 188              	.L4:
 486:Source/tasks.c **** 
 487:Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 488:Source/tasks.c **** 	checking that the allocation was successful. */
 489:Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 189              		.loc 1 489 0 is_stmt 1
 190 0028 FB88     		ldrh	r3, [r7, #6]
 191 002a 1846     		mov	r0, r3
 192 002c 396B     		ldr	r1, [r7, #48]
 193 002e FFF7FEFF 		bl	prvAllocateTCBAndStack
 194 0032 B861     		str	r0, [r7, #24]
 490:Source/tasks.c **** 
 491:Source/tasks.c **** 	if( pxNewTCB != NULL )
 195              		.loc 1 491 0
 196 0034 BB69     		ldr	r3, [r7, #24]
 197 0036 002B     		cmp	r3, #0
 198 0038 00F0A380 		beq	.L6
 199              	.LBB2:
 492:Source/tasks.c **** 	{
 493:Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 494:Source/tasks.c **** 
 495:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 496:Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 497:Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 498:Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 499:Source/tasks.c **** 			{
 500:Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 501:Source/tasks.c **** 			}
 502:Source/tasks.c **** 			else
 503:Source/tasks.c **** 			{
 504:Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 505:Source/tasks.c **** 			}
 506:Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 507:Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 508:Source/tasks.c **** 
 509:Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 510:Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 511:Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 512:Source/tasks.c **** 		required by the port. */
 513:Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 514:Source/tasks.c **** 		{
 515:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 200              		.loc 1 515 0
 201 003c BB69     		ldr	r3, [r7, #24]
 202 003e 1A6B     		ldr	r2, [r3, #48]
 203 0040 FB88     		ldrh	r3, [r7, #6]
 204 0042 03F1FF33 		add	r3, r3, #-1
 205 0046 4FEA8303 		lsl	r3, r3, #2
 206 004a D318     		adds	r3, r2, r3
 207 004c 7B61     		str	r3, [r7, #20]
 516:Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 208              		.loc 1 516 0
 209 004e 7B69     		ldr	r3, [r7, #20]
 210 0050 23F00703 		bic	r3, r3, #7
 211 0054 7B61     		str	r3, [r7, #20]
 517:Source/tasks.c **** 
 518:Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 519:Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 212              		.loc 1 519 0
 213 0056 7B69     		ldr	r3, [r7, #20]
 214 0058 03F00703 		and	r3, r3, #7
 215 005c 002B     		cmp	r3, #0
 216 005e 02D0     		beq	.L7
 217              		.loc 1 519 0 is_stmt 0 discriminator 1
 218 0060 FFF7FEFF 		bl	ulPortSetInterruptMask
 219              	.L8:
 220              		.loc 1 519 0 discriminator 2
 221 0064 FEE7     		b	.L8
 222              	.L7:
 520:Source/tasks.c **** 		}
 521:Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 522:Source/tasks.c **** 		{
 523:Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 524:Source/tasks.c **** 
 525:Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 526:Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 527:Source/tasks.c **** 
 528:Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 529:Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 530:Source/tasks.c **** 			other extreme of the stack space. */
 531:Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 532:Source/tasks.c **** 		}
 533:Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 534:Source/tasks.c **** 
 535:Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 536:Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 223              		.loc 1 536 0 is_stmt 1
 224 0066 FB88     		ldrh	r3, [r7, #6]
 225 0068 0093     		str	r3, [sp, #0]
 226 006a B869     		ldr	r0, [r7, #24]
 227 006c B968     		ldr	r1, [r7, #8]
 228 006e BA6A     		ldr	r2, [r7, #40]
 229 0070 7B6B     		ldr	r3, [r7, #52]
 230 0072 FFF7FEFF 		bl	prvInitialiseTCBVariables
 537:Source/tasks.c **** 
 538:Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 539:Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 540:Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 541:Source/tasks.c **** 		the	top of stack variable is updated. */
 542:Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 543:Source/tasks.c **** 		{
 544:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 545:Source/tasks.c **** 		}
 546:Source/tasks.c **** 		#else /* portUSING_MPU_WRAPPERS */
 547:Source/tasks.c **** 		{
 548:Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 231              		.loc 1 548 0
 232 0076 7869     		ldr	r0, [r7, #20]
 233 0078 F968     		ldr	r1, [r7, #12]
 234 007a 3A68     		ldr	r2, [r7, #0]
 235 007c FFF7FEFF 		bl	pxPortInitialiseStack
 236 0080 0246     		mov	r2, r0
 237 0082 BB69     		ldr	r3, [r7, #24]
 238 0084 1A60     		str	r2, [r3, #0]
 549:Source/tasks.c **** 		}
 550:Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS */
 551:Source/tasks.c **** 
 552:Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 239              		.loc 1 552 0
 240 0086 FB6A     		ldr	r3, [r7, #44]
 241 0088 002B     		cmp	r3, #0
 242 008a 02D0     		beq	.L9
 553:Source/tasks.c **** 		{
 554:Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 555:Source/tasks.c **** 			task can use this as a handle to delete the task later if
 556:Source/tasks.c **** 			required.*/
 557:Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 243              		.loc 1 557 0
 244 008c FB6A     		ldr	r3, [r7, #44]
 245 008e BA69     		ldr	r2, [r7, #24]
 246 0090 1A60     		str	r2, [r3, #0]
 247              	.L9:
 558:Source/tasks.c **** 		}
 559:Source/tasks.c **** 
 560:Source/tasks.c **** 		/* Ensure interrupts don't access the task lists while they are being
 561:Source/tasks.c **** 		updated. */
 562:Source/tasks.c **** 		taskENTER_CRITICAL();
 248              		.loc 1 562 0
 249 0092 FFF7FEFF 		bl	vPortEnterCritical
 563:Source/tasks.c **** 		{
 564:Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 250              		.loc 1 564 0
 251 0096 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 252 009a C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 253 009e 1B68     		ldr	r3, [r3, #0]
 254 00a0 03F10102 		add	r2, r3, #1
 255 00a4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 256 00a8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 257 00ac 1A60     		str	r2, [r3, #0]
 565:Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 258              		.loc 1 565 0
 259 00ae 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 260 00b2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 261 00b6 1B68     		ldr	r3, [r3, #0]
 262 00b8 002B     		cmp	r3, #0
 263 00ba 0FD1     		bne	.L10
 566:Source/tasks.c **** 			{
 567:Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 568:Source/tasks.c **** 				the suspended state - make this the current task. */
 569:Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 264              		.loc 1 569 0
 265 00bc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 266 00c0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 267 00c4 BA69     		ldr	r2, [r7, #24]
 268 00c6 1A60     		str	r2, [r3, #0]
 570:Source/tasks.c **** 
 571:Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 269              		.loc 1 571 0
 270 00c8 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 271 00cc C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 272 00d0 1B68     		ldr	r3, [r3, #0]
 273 00d2 012B     		cmp	r3, #1
 274 00d4 18D1     		bne	.L11
 572:Source/tasks.c **** 				{
 573:Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 574:Source/tasks.c **** 					initialisation required.  We will not recover if this call
 575:Source/tasks.c **** 					fails, but we will report the failure. */
 576:Source/tasks.c **** 					prvInitialiseTaskLists();
 275              		.loc 1 576 0
 276 00d6 FFF7FEFF 		bl	prvInitialiseTaskLists
 277 00da 15E0     		b	.L11
 278              	.L10:
 577:Source/tasks.c **** 				}
 578:Source/tasks.c **** 			}
 579:Source/tasks.c **** 			else
 580:Source/tasks.c **** 			{
 581:Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 582:Source/tasks.c **** 				current task if it is the highest priority task to be created
 583:Source/tasks.c **** 				so far. */
 584:Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 279              		.loc 1 584 0
 280 00dc 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 281 00e0 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 282 00e4 1B68     		ldr	r3, [r3, #0]
 283 00e6 002B     		cmp	r3, #0
 284 00e8 0ED1     		bne	.L11
 585:Source/tasks.c **** 				{
 586:Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 285              		.loc 1 586 0
 286 00ea 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 287 00ee C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 288 00f2 1B68     		ldr	r3, [r3, #0]
 289 00f4 DA6A     		ldr	r2, [r3, #44]
 290 00f6 BB6A     		ldr	r3, [r7, #40]
 291 00f8 9A42     		cmp	r2, r3
 292 00fa 05D8     		bhi	.L11
 587:Source/tasks.c **** 					{
 588:Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 293              		.loc 1 588 0
 294 00fc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 295 0100 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 296 0104 BA69     		ldr	r2, [r7, #24]
 297 0106 1A60     		str	r2, [r3, #0]
 298              	.L11:
 589:Source/tasks.c **** 					}
 590:Source/tasks.c **** 				}
 591:Source/tasks.c **** 			}
 592:Source/tasks.c **** 
 593:Source/tasks.c **** 			uxTaskNumber++;
 299              		.loc 1 593 0
 300 0108 40F20003 		movw	r3, #:lower16:uxTaskNumber
 301 010c C0F20003 		movt	r3, #:upper16:uxTaskNumber
 302 0110 1B68     		ldr	r3, [r3, #0]
 303 0112 03F10102 		add	r2, r3, #1
 304 0116 40F20003 		movw	r3, #:lower16:uxTaskNumber
 305 011a C0F20003 		movt	r3, #:upper16:uxTaskNumber
 306 011e 1A60     		str	r2, [r3, #0]
 594:Source/tasks.c **** 
 595:Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 596:Source/tasks.c **** 			{
 597:Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 598:Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 307              		.loc 1 598 0
 308 0120 40F20003 		movw	r3, #:lower16:uxTaskNumber
 309 0124 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 310 0128 1A68     		ldr	r2, [r3, #0]
 311 012a BB69     		ldr	r3, [r7, #24]
 312 012c 1A64     		str	r2, [r3, #64]
 599:Source/tasks.c **** 			}
 600:Source/tasks.c **** 			#endif /* configUSE_TRACE_FACILITY */
 601:Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 602:Source/tasks.c **** 
 603:Source/tasks.c **** 			prvAddTaskToReadyList( pxNewTCB );
 313              		.loc 1 603 0
 314 012e BB69     		ldr	r3, [r7, #24]
 315 0130 DA6A     		ldr	r2, [r3, #44]
 316 0132 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 317 0136 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 318 013a 1B68     		ldr	r3, [r3, #0]
 319 013c 9A42     		cmp	r2, r3
 320 013e 06D9     		bls	.L12
 321              		.loc 1 603 0 is_stmt 0 discriminator 1
 322 0140 BB69     		ldr	r3, [r7, #24]
 323 0142 DA6A     		ldr	r2, [r3, #44]
 324 0144 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 325 0148 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 326 014c 1A60     		str	r2, [r3, #0]
 327              	.L12:
 328              		.loc 1 603 0 discriminator 2
 329 014e BB69     		ldr	r3, [r7, #24]
 330 0150 DA6A     		ldr	r2, [r3, #44]
 331 0152 1346     		mov	r3, r2
 332 0154 4FEA8303 		lsl	r3, r3, #2
 333 0158 9B18     		adds	r3, r3, r2
 334 015a 4FEA8303 		lsl	r3, r3, #2
 335 015e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 336 0162 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 337 0166 9A18     		adds	r2, r3, r2
 338 0168 BB69     		ldr	r3, [r7, #24]
 339 016a 03F10403 		add	r3, r3, #4
 340 016e 1046     		mov	r0, r2
 341 0170 1946     		mov	r1, r3
 342 0172 FFF7FEFF 		bl	vListInsertEnd
 604:Source/tasks.c **** 
 605:Source/tasks.c **** 			xReturn = pdPASS;
 343              		.loc 1 605 0 is_stmt 1 discriminator 2
 344 0176 4FF00103 		mov	r3, #1
 345 017a FB61     		str	r3, [r7, #28]
 606:Source/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 607:Source/tasks.c **** 		}
 608:Source/tasks.c **** 		taskEXIT_CRITICAL();
 346              		.loc 1 608 0 discriminator 2
 347 017c FFF7FEFF 		bl	vPortExitCritical
 348 0180 02E0     		b	.L13
 349              	.L6:
 350              	.LBE2:
 609:Source/tasks.c **** 	}
 610:Source/tasks.c **** 	else
 611:Source/tasks.c **** 	{
 612:Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 351              		.loc 1 612 0
 352 0182 4FF0FF33 		mov	r3, #-1
 353 0186 FB61     		str	r3, [r7, #28]
 354              	.L13:
 613:Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 614:Source/tasks.c **** 	}
 615:Source/tasks.c **** 
 616:Source/tasks.c **** 	if( xReturn == pdPASS )
 355              		.loc 1 616 0
 356 0188 FB69     		ldr	r3, [r7, #28]
 357 018a 012B     		cmp	r3, #1
 358 018c 11D1     		bne	.L14
 617:Source/tasks.c **** 	{
 618:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 359              		.loc 1 618 0
 360 018e 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 361 0192 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 362 0196 1B68     		ldr	r3, [r3, #0]
 363 0198 002B     		cmp	r3, #0
 364 019a 0AD0     		beq	.L14
 619:Source/tasks.c **** 		{
 620:Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 621:Source/tasks.c **** 			then it should run now. */
 622:Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 365              		.loc 1 622 0
 366 019c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 367 01a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 368 01a4 1B68     		ldr	r3, [r3, #0]
 369 01a6 DA6A     		ldr	r2, [r3, #44]
 370 01a8 BB6A     		ldr	r3, [r7, #40]
 371 01aa 9A42     		cmp	r2, r3
 372 01ac 01D2     		bcs	.L14
 623:Source/tasks.c **** 			{
 624:Source/tasks.c **** 				portYIELD_WITHIN_API();
 373              		.loc 1 624 0
 374 01ae FFF7FEFF 		bl	vPortYield
 375              	.L14:
 625:Source/tasks.c **** 			}
 626:Source/tasks.c **** 		}
 627:Source/tasks.c **** 	}
 628:Source/tasks.c **** 
 629:Source/tasks.c **** 	return xReturn;
 376              		.loc 1 629 0
 377 01b2 FB69     		ldr	r3, [r7, #28]
 630:Source/tasks.c **** }
 378              		.loc 1 630 0
 379 01b4 1846     		mov	r0, r3
 380 01b6 07F12007 		add	r7, r7, #32
 381 01ba BD46     		mov	sp, r7
 382 01bc 80BD     		pop	{r7, pc}
 383              		.cfi_endproc
 384              	.LFE110:
 386 01be 00BF     		.section	.text.vTaskDelete,"ax",%progbits
 387              		.align	2
 388              		.global	vTaskDelete
 389              		.thumb
 390              		.thumb_func
 392              	vTaskDelete:
 393              	.LFB111:
 631:Source/tasks.c **** /*-----------------------------------------------------------*/
 632:Source/tasks.c **** 
 633:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 634:Source/tasks.c **** 
 635:Source/tasks.c **** 	void vTaskDelete( xTaskHandle xTaskToDelete )
 636:Source/tasks.c **** 	{
 394              		.loc 1 636 0
 395              		.cfi_startproc
 396              		@ args = 0, pretend = 0, frame = 16
 397              		@ frame_needed = 1, uses_anonymous_args = 0
 398 0000 80B5     		push	{r7, lr}
 399              	.LCFI3:
 400              		.cfi_def_cfa_offset 8
 401              		.cfi_offset 7, -8
 402              		.cfi_offset 14, -4
 403 0002 84B0     		sub	sp, sp, #16
 404              	.LCFI4:
 405              		.cfi_def_cfa_offset 24
 406 0004 00AF     		add	r7, sp, #0
 407              	.LCFI5:
 408              		.cfi_def_cfa_register 7
 409 0006 7860     		str	r0, [r7, #4]
 637:Source/tasks.c **** 	tskTCB *pxTCB;
 638:Source/tasks.c **** 
 639:Source/tasks.c **** 		taskENTER_CRITICAL();
 410              		.loc 1 639 0
 411 0008 FFF7FEFF 		bl	vPortEnterCritical
 640:Source/tasks.c **** 		{
 641:Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 642:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 412              		.loc 1 642 0
 413 000c 7B68     		ldr	r3, [r7, #4]
 414 000e 002B     		cmp	r3, #0
 415 0010 05D1     		bne	.L17
 416              		.loc 1 642 0 is_stmt 0 discriminator 1
 417 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 418 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 419 001a 1B68     		ldr	r3, [r3, #0]
 420 001c 00E0     		b	.L18
 421              	.L17:
 422              		.loc 1 642 0 discriminator 2
 423 001e 7B68     		ldr	r3, [r7, #4]
 424              	.L18:
 425              		.loc 1 642 0 discriminator 3
 426 0020 FB60     		str	r3, [r7, #12]
 643:Source/tasks.c **** 
 644:Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 645:Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 646:Source/tasks.c **** 			the termination list and free up any memory allocated by the
 647:Source/tasks.c **** 			scheduler for the TCB and stack. */
 648:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 427              		.loc 1 648 0 is_stmt 1 discriminator 3
 428 0022 FB68     		ldr	r3, [r7, #12]
 429 0024 03F10403 		add	r3, r3, #4
 430 0028 1846     		mov	r0, r3
 431 002a FFF7FEFF 		bl	uxListRemove
 649:Source/tasks.c **** 			{
 650:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 651:Source/tasks.c **** 			}
 652:Source/tasks.c **** 
 653:Source/tasks.c **** 			/* Is the task waiting on an event also? */
 654:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 432              		.loc 1 654 0 discriminator 3
 433 002e FB68     		ldr	r3, [r7, #12]
 434 0030 9B6A     		ldr	r3, [r3, #40]
 435 0032 002B     		cmp	r3, #0
 436 0034 05D0     		beq	.L19
 655:Source/tasks.c **** 			{
 656:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 437              		.loc 1 656 0
 438 0036 FB68     		ldr	r3, [r7, #12]
 439 0038 03F11803 		add	r3, r3, #24
 440 003c 1846     		mov	r0, r3
 441 003e FFF7FEFF 		bl	uxListRemove
 442              	.L19:
 657:Source/tasks.c **** 			}
 658:Source/tasks.c **** 
 659:Source/tasks.c **** 			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 443              		.loc 1 659 0
 444 0042 FB68     		ldr	r3, [r7, #12]
 445 0044 03F10403 		add	r3, r3, #4
 446 0048 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 447 004c C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 448 0050 1946     		mov	r1, r3
 449 0052 FFF7FEFF 		bl	vListInsertEnd
 660:Source/tasks.c **** 
 661:Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 662:Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 663:Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 664:Source/tasks.c **** 			++uxTasksDeleted;
 450              		.loc 1 664 0
 451 0056 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 452 005a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 453 005e 1B68     		ldr	r3, [r3, #0]
 454 0060 03F10102 		add	r2, r3, #1
 455 0064 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 456 0068 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 457 006c 1A60     		str	r2, [r3, #0]
 665:Source/tasks.c **** 
 666:Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 667:Source/tasks.c **** 			can detect that the task lists need re-generating. */
 668:Source/tasks.c **** 			uxTaskNumber++;
 458              		.loc 1 668 0
 459 006e 40F20003 		movw	r3, #:lower16:uxTaskNumber
 460 0072 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 461 0076 1B68     		ldr	r3, [r3, #0]
 462 0078 03F10102 		add	r2, r3, #1
 463 007c 40F20003 		movw	r3, #:lower16:uxTaskNumber
 464 0080 C0F20003 		movt	r3, #:upper16:uxTaskNumber
 465 0084 1A60     		str	r2, [r3, #0]
 669:Source/tasks.c **** 
 670:Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 671:Source/tasks.c **** 		}
 672:Source/tasks.c **** 		taskEXIT_CRITICAL();
 466              		.loc 1 672 0
 467 0086 FFF7FEFF 		bl	vPortExitCritical
 673:Source/tasks.c **** 
 674:Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 675:Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 468              		.loc 1 675 0
 469 008a 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 470 008e C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 471 0092 1B68     		ldr	r3, [r3, #0]
 472 0094 002B     		cmp	r3, #0
 473 0096 09D0     		beq	.L16
 676:Source/tasks.c **** 		{
 677:Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 474              		.loc 1 677 0
 475 0098 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 476 009c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 477 00a0 1B68     		ldr	r3, [r3, #0]
 478 00a2 FA68     		ldr	r2, [r7, #12]
 479 00a4 9A42     		cmp	r2, r3
 480 00a6 01D1     		bne	.L16
 678:Source/tasks.c **** 			{
 679:Source/tasks.c **** 				portYIELD_WITHIN_API();
 481              		.loc 1 679 0
 482 00a8 FFF7FEFF 		bl	vPortYield
 483              	.L16:
 680:Source/tasks.c **** 			}
 681:Source/tasks.c **** 		}
 682:Source/tasks.c **** 	}
 484              		.loc 1 682 0
 485 00ac 07F11007 		add	r7, r7, #16
 486 00b0 BD46     		mov	sp, r7
 487 00b2 80BD     		pop	{r7, pc}
 488              		.cfi_endproc
 489              	.LFE111:
 491              		.section	.text.vTaskDelayUntil,"ax",%progbits
 492              		.align	2
 493              		.global	vTaskDelayUntil
 494              		.thumb
 495              		.thumb_func
 497              	vTaskDelayUntil:
 498              	.LFB112:
 683:Source/tasks.c **** 
 684:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
 685:Source/tasks.c **** /*-----------------------------------------------------------*/
 686:Source/tasks.c **** 
 687:Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 688:Source/tasks.c **** 
 689:Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 690:Source/tasks.c **** 	{
 499              		.loc 1 690 0
 500              		.cfi_startproc
 501              		@ args = 0, pretend = 0, frame = 24
 502              		@ frame_needed = 1, uses_anonymous_args = 0
 503 0000 80B5     		push	{r7, lr}
 504              	.LCFI6:
 505              		.cfi_def_cfa_offset 8
 506              		.cfi_offset 7, -8
 507              		.cfi_offset 14, -4
 508 0002 86B0     		sub	sp, sp, #24
 509              	.LCFI7:
 510              		.cfi_def_cfa_offset 32
 511 0004 00AF     		add	r7, sp, #0
 512              	.LCFI8:
 513              		.cfi_def_cfa_register 7
 514 0006 7860     		str	r0, [r7, #4]
 515 0008 3960     		str	r1, [r7, #0]
 691:Source/tasks.c **** 	portTickType xTimeToWake;
 692:Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 516              		.loc 1 692 0
 517 000a 4FF00003 		mov	r3, #0
 518 000e 7B61     		str	r3, [r7, #20]
 693:Source/tasks.c **** 
 694:Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 519              		.loc 1 694 0
 520 0010 7B68     		ldr	r3, [r7, #4]
 521 0012 002B     		cmp	r3, #0
 522 0014 02D1     		bne	.L22
 523              		.loc 1 694 0 is_stmt 0 discriminator 1
 524 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 525              	.L23:
 526              		.loc 1 694 0 discriminator 2
 527 001a FEE7     		b	.L23
 528              	.L22:
 695:Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 529              		.loc 1 695 0 is_stmt 1
 530 001c 3B68     		ldr	r3, [r7, #0]
 531 001e 002B     		cmp	r3, #0
 532 0020 02D1     		bne	.L24
 533              		.loc 1 695 0 is_stmt 0 discriminator 1
 534 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 535              	.L25:
 536              		.loc 1 695 0 discriminator 2
 537 0026 FEE7     		b	.L25
 538              	.L24:
 696:Source/tasks.c **** 
 697:Source/tasks.c **** 		vTaskSuspendAll();
 539              		.loc 1 697 0 is_stmt 1
 540 0028 FFF7FEFF 		bl	vTaskSuspendAll
 541              	.LBB3:
 698:Source/tasks.c **** 		{
 699:Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
 700:Source/tasks.c **** 			block. */
 701:Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 542              		.loc 1 701 0
 543 002c 40F20003 		movw	r3, #:lower16:xTickCount
 544 0030 C0F20003 		movt	r3, #:upper16:xTickCount
 545 0034 1B68     		ldr	r3, [r3, #0]
 546 0036 3B61     		str	r3, [r7, #16]
 702:Source/tasks.c **** 
 703:Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 704:Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 547              		.loc 1 704 0
 548 0038 7B68     		ldr	r3, [r7, #4]
 549 003a 1A68     		ldr	r2, [r3, #0]
 550 003c 3B68     		ldr	r3, [r7, #0]
 551 003e D318     		adds	r3, r2, r3
 552 0040 FB60     		str	r3, [r7, #12]
 705:Source/tasks.c **** 
 706:Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 553              		.loc 1 706 0
 554 0042 7B68     		ldr	r3, [r7, #4]
 555 0044 1A68     		ldr	r2, [r3, #0]
 556 0046 3B69     		ldr	r3, [r7, #16]
 557 0048 9A42     		cmp	r2, r3
 558 004a 0CD9     		bls	.L26
 707:Source/tasks.c **** 			{
 708:Source/tasks.c **** 				/* The tick count has overflowed since this function was
 709:Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 710:Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 711:Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 712:Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 713:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 559              		.loc 1 713 0
 560 004c 7B68     		ldr	r3, [r7, #4]
 561 004e 1A68     		ldr	r2, [r3, #0]
 562 0050 FB68     		ldr	r3, [r7, #12]
 563 0052 9A42     		cmp	r2, r3
 564 0054 13D9     		bls	.L27
 565              		.loc 1 713 0 is_stmt 0 discriminator 1
 566 0056 FA68     		ldr	r2, [r7, #12]
 567 0058 3B69     		ldr	r3, [r7, #16]
 568 005a 9A42     		cmp	r2, r3
 569 005c 0FD9     		bls	.L27
 714:Source/tasks.c **** 				{
 715:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 570              		.loc 1 715 0 is_stmt 1
 571 005e 4FF00103 		mov	r3, #1
 572 0062 7B61     		str	r3, [r7, #20]
 573 0064 0BE0     		b	.L27
 574              	.L26:
 716:Source/tasks.c **** 				}
 717:Source/tasks.c **** 			}
 718:Source/tasks.c **** 			else
 719:Source/tasks.c **** 			{
 720:Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 721:Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 722:Source/tasks.c **** 				tick time is less than the wake time. */
 723:Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 575              		.loc 1 723 0
 576 0066 7B68     		ldr	r3, [r7, #4]
 577 0068 1A68     		ldr	r2, [r3, #0]
 578 006a FB68     		ldr	r3, [r7, #12]
 579 006c 9A42     		cmp	r2, r3
 580 006e 03D8     		bhi	.L28
 581              		.loc 1 723 0 is_stmt 0 discriminator 1
 582 0070 FA68     		ldr	r2, [r7, #12]
 583 0072 3B69     		ldr	r3, [r7, #16]
 584 0074 9A42     		cmp	r2, r3
 585 0076 02D9     		bls	.L27
 586              	.L28:
 724:Source/tasks.c **** 				{
 725:Source/tasks.c **** 					xShouldDelay = pdTRUE;
 587              		.loc 1 725 0 is_stmt 1
 588 0078 4FF00103 		mov	r3, #1
 589 007c 7B61     		str	r3, [r7, #20]
 590              	.L27:
 726:Source/tasks.c **** 				}
 727:Source/tasks.c **** 			}
 728:Source/tasks.c **** 
 729:Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 730:Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 591              		.loc 1 730 0
 592 007e 7B68     		ldr	r3, [r7, #4]
 593 0080 FA68     		ldr	r2, [r7, #12]
 594 0082 1A60     		str	r2, [r3, #0]
 731:Source/tasks.c **** 
 732:Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 595              		.loc 1 732 0
 596 0084 7B69     		ldr	r3, [r7, #20]
 597 0086 002B     		cmp	r3, #0
 598 0088 0CD0     		beq	.L29
 733:Source/tasks.c **** 			{
 734:Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 735:Source/tasks.c **** 
 736:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 737:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 738:Source/tasks.c **** 				both lists. */
 739:Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 599              		.loc 1 739 0
 600 008a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 601 008e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 602 0092 1B68     		ldr	r3, [r3, #0]
 603 0094 03F10403 		add	r3, r3, #4
 604 0098 1846     		mov	r0, r3
 605 009a FFF7FEFF 		bl	uxListRemove
 740:Source/tasks.c **** 				{
 741:Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 742:Source/tasks.c **** 					no need to check, and the port reset macro can be called
 743:Source/tasks.c **** 					directly. */
 744:Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 745:Source/tasks.c **** 				}
 746:Source/tasks.c **** 
 747:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 606              		.loc 1 747 0
 607 009e F868     		ldr	r0, [r7, #12]
 608 00a0 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 609              	.L29:
 610              	.LBE3:
 748:Source/tasks.c **** 			}
 749:Source/tasks.c **** 		}
 750:Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 611              		.loc 1 750 0
 612 00a4 FFF7FEFF 		bl	xTaskResumeAll
 613 00a8 B860     		str	r0, [r7, #8]
 751:Source/tasks.c **** 
 752:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 753:Source/tasks.c **** 		have put ourselves to sleep. */
 754:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 614              		.loc 1 754 0
 615 00aa BB68     		ldr	r3, [r7, #8]
 616 00ac 002B     		cmp	r3, #0
 617 00ae 01D1     		bne	.L21
 755:Source/tasks.c **** 		{
 756:Source/tasks.c **** 			portYIELD_WITHIN_API();
 618              		.loc 1 756 0
 619 00b0 FFF7FEFF 		bl	vPortYield
 620              	.L21:
 757:Source/tasks.c **** 		}
 758:Source/tasks.c **** 	}
 621              		.loc 1 758 0
 622 00b4 07F11807 		add	r7, r7, #24
 623 00b8 BD46     		mov	sp, r7
 624 00ba 80BD     		pop	{r7, pc}
 625              		.cfi_endproc
 626              	.LFE112:
 628              		.section	.text.vTaskDelay,"ax",%progbits
 629              		.align	2
 630              		.global	vTaskDelay
 631              		.thumb
 632              		.thumb_func
 634              	vTaskDelay:
 635              	.LFB113:
 759:Source/tasks.c **** 
 760:Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
 761:Source/tasks.c **** /*-----------------------------------------------------------*/
 762:Source/tasks.c **** 
 763:Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 764:Source/tasks.c **** 
 765:Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 766:Source/tasks.c **** 	{
 636              		.loc 1 766 0
 637              		.cfi_startproc
 638              		@ args = 0, pretend = 0, frame = 16
 639              		@ frame_needed = 1, uses_anonymous_args = 0
 640 0000 80B5     		push	{r7, lr}
 641              	.LCFI9:
 642              		.cfi_def_cfa_offset 8
 643              		.cfi_offset 7, -8
 644              		.cfi_offset 14, -4
 645 0002 84B0     		sub	sp, sp, #16
 646              	.LCFI10:
 647              		.cfi_def_cfa_offset 24
 648 0004 00AF     		add	r7, sp, #0
 649              	.LCFI11:
 650              		.cfi_def_cfa_register 7
 651 0006 7860     		str	r0, [r7, #4]
 767:Source/tasks.c **** 	portTickType xTimeToWake;
 768:Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 652              		.loc 1 768 0
 653 0008 4FF00003 		mov	r3, #0
 654 000c FB60     		str	r3, [r7, #12]
 769:Source/tasks.c **** 
 770:Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 771:Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 655              		.loc 1 771 0
 656 000e 7B68     		ldr	r3, [r7, #4]
 657 0010 002B     		cmp	r3, #0
 658 0012 19D0     		beq	.L32
 772:Source/tasks.c **** 		{
 773:Source/tasks.c **** 			vTaskSuspendAll();
 659              		.loc 1 773 0
 660 0014 FFF7FEFF 		bl	vTaskSuspendAll
 774:Source/tasks.c **** 			{
 775:Source/tasks.c **** 				traceTASK_DELAY();
 776:Source/tasks.c **** 
 777:Source/tasks.c **** 				/* A task that is removed from the event list while the
 778:Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 779:Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 780:Source/tasks.c **** 				is resumed.
 781:Source/tasks.c **** 
 782:Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 783:Source/tasks.c **** 				executing task. */
 784:Source/tasks.c **** 
 785:Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 786:Source/tasks.c **** 				not a problem. */
 787:Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 661              		.loc 1 787 0
 662 0018 40F20003 		movw	r3, #:lower16:xTickCount
 663 001c C0F20003 		movt	r3, #:upper16:xTickCount
 664 0020 1A68     		ldr	r2, [r3, #0]
 665 0022 7B68     		ldr	r3, [r7, #4]
 666 0024 D318     		adds	r3, r2, r3
 667 0026 BB60     		str	r3, [r7, #8]
 788:Source/tasks.c **** 
 789:Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 790:Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 791:Source/tasks.c **** 				both lists. */
 792:Source/tasks.c **** 				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 668              		.loc 1 792 0
 669 0028 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 670 002c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 671 0030 1B68     		ldr	r3, [r3, #0]
 672 0032 03F10403 		add	r3, r3, #4
 673 0036 1846     		mov	r0, r3
 674 0038 FFF7FEFF 		bl	uxListRemove
 793:Source/tasks.c **** 				{
 794:Source/tasks.c **** 					/* The current task must be in a ready list, so there is
 795:Source/tasks.c **** 					no need to check, and the port reset macro can be called
 796:Source/tasks.c **** 					directly. */
 797:Source/tasks.c **** 					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 798:Source/tasks.c **** 				}
 799:Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 675              		.loc 1 799 0
 676 003c B868     		ldr	r0, [r7, #8]
 677 003e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 800:Source/tasks.c **** 			}
 801:Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 678              		.loc 1 801 0
 679 0042 FFF7FEFF 		bl	xTaskResumeAll
 680 0046 F860     		str	r0, [r7, #12]
 681              	.L32:
 802:Source/tasks.c **** 		}
 803:Source/tasks.c **** 
 804:Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 805:Source/tasks.c **** 		have put ourselves to sleep. */
 806:Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 682              		.loc 1 806 0
 683 0048 FB68     		ldr	r3, [r7, #12]
 684 004a 002B     		cmp	r3, #0
 685 004c 01D1     		bne	.L31
 807:Source/tasks.c **** 		{
 808:Source/tasks.c **** 			portYIELD_WITHIN_API();
 686              		.loc 1 808 0
 687 004e FFF7FEFF 		bl	vPortYield
 688              	.L31:
 809:Source/tasks.c **** 		}
 810:Source/tasks.c **** 	}
 689              		.loc 1 810 0
 690 0052 07F11007 		add	r7, r7, #16
 691 0056 BD46     		mov	sp, r7
 692 0058 80BD     		pop	{r7, pc}
 693              		.cfi_endproc
 694              	.LFE113:
 696 005a 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 697              		.align	2
 698              		.global	uxTaskPriorityGet
 699              		.thumb
 700              		.thumb_func
 702              	uxTaskPriorityGet:
 703              	.LFB114:
 811:Source/tasks.c **** 
 812:Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
 813:Source/tasks.c **** /*-----------------------------------------------------------*/
 814:Source/tasks.c **** 
 815:Source/tasks.c **** #if ( INCLUDE_eTaskGetState == 1 )
 816:Source/tasks.c **** 
 817:Source/tasks.c **** 	eTaskState eTaskGetState( xTaskHandle xTask )
 818:Source/tasks.c **** 	{
 819:Source/tasks.c **** 	eTaskState eReturn;
 820:Source/tasks.c **** 	xList *pxStateList;
 821:Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 822:Source/tasks.c **** 
 823:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 824:Source/tasks.c **** 		{
 825:Source/tasks.c **** 			/* The task calling this function is querying its own state. */
 826:Source/tasks.c **** 			eReturn = eRunning;
 827:Source/tasks.c **** 		}
 828:Source/tasks.c **** 		else
 829:Source/tasks.c **** 		{
 830:Source/tasks.c **** 			taskENTER_CRITICAL();
 831:Source/tasks.c **** 			{
 832:Source/tasks.c **** 				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
 833:Source/tasks.c **** 			}
 834:Source/tasks.c **** 			taskEXIT_CRITICAL();
 835:Source/tasks.c **** 
 836:Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 837:Source/tasks.c **** 			{
 838:Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
 839:Source/tasks.c **** 				lists. */
 840:Source/tasks.c **** 				eReturn = eBlocked;
 841:Source/tasks.c **** 			}
 842:Source/tasks.c **** 
 843:Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
 844:Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 845:Source/tasks.c **** 				{
 846:Source/tasks.c **** 					/* The task being queried is referenced from the suspended
 847:Source/tasks.c **** 					list. */
 848:Source/tasks.c **** 					eReturn = eSuspended;
 849:Source/tasks.c **** 				}
 850:Source/tasks.c **** 			#endif
 851:Source/tasks.c **** 
 852:Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
 853:Source/tasks.c **** 				else if( pxStateList == &xTasksWaitingTermination )
 854:Source/tasks.c **** 				{
 855:Source/tasks.c **** 					/* The task being queried is referenced from the deleted
 856:Source/tasks.c **** 					tasks list. */
 857:Source/tasks.c **** 					eReturn = eDeleted;
 858:Source/tasks.c **** 				}
 859:Source/tasks.c **** 			#endif
 860:Source/tasks.c **** 
 861:Source/tasks.c **** 			else
 862:Source/tasks.c **** 			{
 863:Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
 864:Source/tasks.c **** 				Ready (including pending ready) state. */
 865:Source/tasks.c **** 				eReturn = eReady;
 866:Source/tasks.c **** 			}
 867:Source/tasks.c **** 		}
 868:Source/tasks.c **** 
 869:Source/tasks.c **** 		return eReturn;
 870:Source/tasks.c **** 	}
 871:Source/tasks.c **** 
 872:Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
 873:Source/tasks.c **** /*-----------------------------------------------------------*/
 874:Source/tasks.c **** 
 875:Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 876:Source/tasks.c **** 
 877:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
 878:Source/tasks.c **** 	{
 704              		.loc 1 878 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 16
 707              		@ frame_needed = 1, uses_anonymous_args = 0
 708 0000 80B5     		push	{r7, lr}
 709              	.LCFI12:
 710              		.cfi_def_cfa_offset 8
 711              		.cfi_offset 7, -8
 712              		.cfi_offset 14, -4
 713 0002 84B0     		sub	sp, sp, #16
 714              	.LCFI13:
 715              		.cfi_def_cfa_offset 24
 716 0004 00AF     		add	r7, sp, #0
 717              	.LCFI14:
 718              		.cfi_def_cfa_register 7
 719 0006 7860     		str	r0, [r7, #4]
 879:Source/tasks.c **** 	tskTCB *pxTCB;
 880:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 881:Source/tasks.c **** 
 882:Source/tasks.c **** 		taskENTER_CRITICAL();
 720              		.loc 1 882 0
 721 0008 FFF7FEFF 		bl	vPortEnterCritical
 883:Source/tasks.c **** 		{
 884:Source/tasks.c **** 			/* If null is passed in here then we are changing the
 885:Source/tasks.c **** 			priority of the calling function. */
 886:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 722              		.loc 1 886 0
 723 000c 7B68     		ldr	r3, [r7, #4]
 724 000e 002B     		cmp	r3, #0
 725 0010 05D1     		bne	.L35
 726              		.loc 1 886 0 is_stmt 0 discriminator 1
 727 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 728 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 729 001a 1B68     		ldr	r3, [r3, #0]
 730 001c 00E0     		b	.L36
 731              	.L35:
 732              		.loc 1 886 0 discriminator 2
 733 001e 7B68     		ldr	r3, [r7, #4]
 734              	.L36:
 735              		.loc 1 886 0 discriminator 3
 736 0020 FB60     		str	r3, [r7, #12]
 887:Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 737              		.loc 1 887 0 is_stmt 1 discriminator 3
 738 0022 FB68     		ldr	r3, [r7, #12]
 739 0024 DB6A     		ldr	r3, [r3, #44]
 740 0026 BB60     		str	r3, [r7, #8]
 888:Source/tasks.c **** 		}
 889:Source/tasks.c **** 		taskEXIT_CRITICAL();
 741              		.loc 1 889 0 discriminator 3
 742 0028 FFF7FEFF 		bl	vPortExitCritical
 890:Source/tasks.c **** 
 891:Source/tasks.c **** 		return uxReturn;
 743              		.loc 1 891 0 discriminator 3
 744 002c BB68     		ldr	r3, [r7, #8]
 892:Source/tasks.c **** 	}
 745              		.loc 1 892 0 discriminator 3
 746 002e 1846     		mov	r0, r3
 747 0030 07F11007 		add	r7, r7, #16
 748 0034 BD46     		mov	sp, r7
 749 0036 80BD     		pop	{r7, pc}
 750              		.cfi_endproc
 751              	.LFE114:
 753              		.section	.text.vTaskPrioritySet,"ax",%progbits
 754              		.align	2
 755              		.global	vTaskPrioritySet
 756              		.thumb
 757              		.thumb_func
 759              	vTaskPrioritySet:
 760              	.LFB115:
 893:Source/tasks.c **** 
 894:Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
 895:Source/tasks.c **** /*-----------------------------------------------------------*/
 896:Source/tasks.c **** 
 897:Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 898:Source/tasks.c **** 
 899:Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
 900:Source/tasks.c **** 	{
 761              		.loc 1 900 0
 762              		.cfi_startproc
 763              		@ args = 0, pretend = 0, frame = 24
 764              		@ frame_needed = 1, uses_anonymous_args = 0
 765 0000 80B5     		push	{r7, lr}
 766              	.LCFI15:
 767              		.cfi_def_cfa_offset 8
 768              		.cfi_offset 7, -8
 769              		.cfi_offset 14, -4
 770 0002 86B0     		sub	sp, sp, #24
 771              	.LCFI16:
 772              		.cfi_def_cfa_offset 32
 773 0004 00AF     		add	r7, sp, #0
 774              	.LCFI17:
 775              		.cfi_def_cfa_register 7
 776 0006 7860     		str	r0, [r7, #4]
 777 0008 3960     		str	r1, [r7, #0]
 901:Source/tasks.c **** 	tskTCB *pxTCB;
 902:Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
 903:Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 778              		.loc 1 903 0
 779 000a 4FF00003 		mov	r3, #0
 780 000e 7B61     		str	r3, [r7, #20]
 904:Source/tasks.c **** 
 905:Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 781              		.loc 1 905 0
 782 0010 3B68     		ldr	r3, [r7, #0]
 783 0012 042B     		cmp	r3, #4
 784 0014 02D9     		bls	.L39
 785              		.loc 1 905 0 is_stmt 0 discriminator 1
 786 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 787              	.L40:
 788              		.loc 1 905 0 discriminator 2
 789 001a FEE7     		b	.L40
 790              	.L39:
 906:Source/tasks.c **** 
 907:Source/tasks.c **** 		/* Ensure the new priority is valid. */
 908:Source/tasks.c **** 		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 791              		.loc 1 908 0 is_stmt 1
 792 001c 3B68     		ldr	r3, [r7, #0]
 793 001e 042B     		cmp	r3, #4
 794 0020 02D9     		bls	.L41
 909:Source/tasks.c **** 		{
 910:Source/tasks.c **** 			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 795              		.loc 1 910 0
 796 0022 4FF00403 		mov	r3, #4
 797 0026 3B60     		str	r3, [r7, #0]
 798              	.L41:
 911:Source/tasks.c **** 		}
 912:Source/tasks.c **** 
 913:Source/tasks.c **** 		taskENTER_CRITICAL();
 799              		.loc 1 913 0
 800 0028 FFF7FEFF 		bl	vPortEnterCritical
 914:Source/tasks.c **** 		{
 915:Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
 916:Source/tasks.c **** 			task that is being changed. */
 917:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 801              		.loc 1 917 0
 802 002c 7B68     		ldr	r3, [r7, #4]
 803 002e 002B     		cmp	r3, #0
 804 0030 05D1     		bne	.L42
 805              		.loc 1 917 0 is_stmt 0 discriminator 1
 806 0032 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 807 0036 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 808 003a 1B68     		ldr	r3, [r3, #0]
 809 003c 00E0     		b	.L43
 810              	.L42:
 811              		.loc 1 917 0 discriminator 2
 812 003e 7B68     		ldr	r3, [r7, #4]
 813              	.L43:
 814              		.loc 1 917 0 discriminator 3
 815 0040 3B61     		str	r3, [r7, #16]
 918:Source/tasks.c **** 
 919:Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 920:Source/tasks.c **** 
 921:Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 922:Source/tasks.c **** 			{
 923:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 816              		.loc 1 923 0 is_stmt 1 discriminator 3
 817 0042 3B69     		ldr	r3, [r7, #16]
 818 0044 9B6C     		ldr	r3, [r3, #72]
 819 0046 FB60     		str	r3, [r7, #12]
 924:Source/tasks.c **** 			}
 925:Source/tasks.c **** 			#else
 926:Source/tasks.c **** 			{
 927:Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
 928:Source/tasks.c **** 			}
 929:Source/tasks.c **** 			#endif
 930:Source/tasks.c **** 
 931:Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 820              		.loc 1 931 0 discriminator 3
 821 0048 FA68     		ldr	r2, [r7, #12]
 822 004a 3B68     		ldr	r3, [r7, #0]
 823 004c 9A42     		cmp	r2, r3
 824 004e 7DD0     		beq	.L44
 932:Source/tasks.c **** 			{
 933:Source/tasks.c **** 				/* The priority change may have readied a task of higher
 934:Source/tasks.c **** 				priority than the calling task. */
 935:Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 825              		.loc 1 935 0
 826 0050 3A68     		ldr	r2, [r7, #0]
 827 0052 FB68     		ldr	r3, [r7, #12]
 828 0054 9A42     		cmp	r2, r3
 829 0056 14D9     		bls	.L45
 936:Source/tasks.c **** 				{
 937:Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 830              		.loc 1 937 0
 831 0058 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 832 005c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 833 0060 1B68     		ldr	r3, [r3, #0]
 834 0062 3A69     		ldr	r2, [r7, #16]
 835 0064 9A42     		cmp	r2, r3
 836 0066 17D0     		beq	.L46
 938:Source/tasks.c **** 					{
 939:Source/tasks.c **** 						/* The priority of a task other than the currently
 940:Source/tasks.c **** 						running task is being raised.  Is the priority being
 941:Source/tasks.c **** 						raised above that of the running task? */
 942:Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 837              		.loc 1 942 0
 838 0068 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 839 006c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 840 0070 1B68     		ldr	r3, [r3, #0]
 841 0072 DA6A     		ldr	r2, [r3, #44]
 842 0074 3B68     		ldr	r3, [r7, #0]
 843 0076 9A42     		cmp	r2, r3
 844 0078 0ED8     		bhi	.L46
 943:Source/tasks.c **** 						{
 944:Source/tasks.c **** 							xYieldRequired = pdTRUE;
 845              		.loc 1 944 0
 846 007a 4FF00103 		mov	r3, #1
 847 007e 7B61     		str	r3, [r7, #20]
 848 0080 0AE0     		b	.L46
 849              	.L45:
 945:Source/tasks.c **** 						}
 946:Source/tasks.c **** 					}
 947:Source/tasks.c **** 					else
 948:Source/tasks.c **** 					{
 949:Source/tasks.c **** 						/* The priority of the running task is being raised,
 950:Source/tasks.c **** 						but the running task must already be the highest
 951:Source/tasks.c **** 						priority task able to run so no yield is required. */
 952:Source/tasks.c **** 					}
 953:Source/tasks.c **** 				}
 954:Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 850              		.loc 1 954 0
 851 0082 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 852 0086 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 853 008a 1B68     		ldr	r3, [r3, #0]
 854 008c 3A69     		ldr	r2, [r7, #16]
 855 008e 9A42     		cmp	r2, r3
 856 0090 02D1     		bne	.L46
 955:Source/tasks.c **** 				{
 956:Source/tasks.c **** 					/* Setting the priority of the running task down means
 957:Source/tasks.c **** 					there may now be another task of higher priority that
 958:Source/tasks.c **** 					is ready to execute. */
 959:Source/tasks.c **** 					xYieldRequired = pdTRUE;
 857              		.loc 1 959 0
 858 0092 4FF00103 		mov	r3, #1
 859 0096 7B61     		str	r3, [r7, #20]
 860              	.L46:
 960:Source/tasks.c **** 				}
 961:Source/tasks.c **** 				else
 962:Source/tasks.c **** 				{
 963:Source/tasks.c **** 					/* Setting the priority of any other task down does not
 964:Source/tasks.c **** 					require a yield as the running task must be above the
 965:Source/tasks.c **** 					new priority of the task being modified. */
 966:Source/tasks.c **** 				}
 967:Source/tasks.c **** 
 968:Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
 969:Source/tasks.c **** 				before its uxPriority member is changed so the
 970:Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
 971:Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 861              		.loc 1 971 0
 862 0098 3B69     		ldr	r3, [r7, #16]
 863 009a DB6A     		ldr	r3, [r3, #44]
 864 009c BB60     		str	r3, [r7, #8]
 972:Source/tasks.c **** 
 973:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 974:Source/tasks.c **** 				{
 975:Source/tasks.c **** 					/* Only change the priority being used if the task is not
 976:Source/tasks.c **** 					currently using an inherited priority. */
 977:Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 865              		.loc 1 977 0
 866 009e 3B69     		ldr	r3, [r7, #16]
 867 00a0 9A6C     		ldr	r2, [r3, #72]
 868 00a2 3B69     		ldr	r3, [r7, #16]
 869 00a4 DB6A     		ldr	r3, [r3, #44]
 870 00a6 9A42     		cmp	r2, r3
 871 00a8 02D1     		bne	.L47
 978:Source/tasks.c **** 					{
 979:Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 872              		.loc 1 979 0
 873 00aa 3B69     		ldr	r3, [r7, #16]
 874 00ac 3A68     		ldr	r2, [r7, #0]
 875 00ae DA62     		str	r2, [r3, #44]
 876              	.L47:
 980:Source/tasks.c **** 					}
 981:Source/tasks.c **** 
 982:Source/tasks.c **** 					/* The base priority gets set whatever. */
 983:Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 877              		.loc 1 983 0
 878 00b0 3B69     		ldr	r3, [r7, #16]
 879 00b2 3A68     		ldr	r2, [r7, #0]
 880 00b4 9A64     		str	r2, [r3, #72]
 984:Source/tasks.c **** 				}
 985:Source/tasks.c **** 				#else
 986:Source/tasks.c **** 				{
 987:Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 988:Source/tasks.c **** 				}
 989:Source/tasks.c **** 				#endif
 990:Source/tasks.c **** 
 991:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - 
 881              		.loc 1 991 0
 882 00b6 3B68     		ldr	r3, [r7, #0]
 883 00b8 C3F10502 		rsb	r2, r3, #5
 884 00bc 3B69     		ldr	r3, [r7, #16]
 885 00be 9A61     		str	r2, [r3, #24]
 992:Source/tasks.c **** 
 993:Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 994:Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 995:Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 996:Source/tasks.c **** 				in the list appropriate to its new priority. */
 997:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGeneri
 886              		.loc 1 997 0
 887 00c0 3B69     		ldr	r3, [r7, #16]
 888 00c2 5969     		ldr	r1, [r3, #20]
 889 00c4 BA68     		ldr	r2, [r7, #8]
 890 00c6 1346     		mov	r3, r2
 891 00c8 4FEA8303 		lsl	r3, r3, #2
 892 00cc 9B18     		adds	r3, r3, r2
 893 00ce 4FEA8303 		lsl	r3, r3, #2
 894 00d2 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 895 00d6 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 896 00da 9B18     		adds	r3, r3, r2
 897 00dc 9942     		cmp	r1, r3
 898 00de 02D1     		bne	.L48
 899              		.loc 1 997 0 is_stmt 0 discriminator 1
 900 00e0 4FF00103 		mov	r3, #1
 901 00e4 01E0     		b	.L49
 902              	.L48:
 903              		.loc 1 997 0 discriminator 2
 904 00e6 4FF00003 		mov	r3, #0
 905              	.L49:
 906              		.loc 1 997 0 discriminator 3
 907 00ea 002B     		cmp	r3, #0
 908 00ec 29D0     		beq	.L50
 998:Source/tasks.c **** 				{
 999:Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1000:Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1001:Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1002:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 909              		.loc 1 1002 0 is_stmt 1
 910 00ee 3B69     		ldr	r3, [r7, #16]
 911 00f0 03F10403 		add	r3, r3, #4
 912 00f4 1846     		mov	r0, r3
 913 00f6 FFF7FEFF 		bl	uxListRemove
1003:Source/tasks.c **** 					{
1004:Source/tasks.c **** 						/* It is known that the task is in its ready list so
1005:Source/tasks.c **** 						there is no need to check again and the port level
1006:Source/tasks.c **** 						reset macro can be called directly. */
1007:Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1008:Source/tasks.c **** 					}
1009:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 914              		.loc 1 1009 0
 915 00fa 3B69     		ldr	r3, [r7, #16]
 916 00fc DA6A     		ldr	r2, [r3, #44]
 917 00fe 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 918 0102 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 919 0106 1B68     		ldr	r3, [r3, #0]
 920 0108 9A42     		cmp	r2, r3
 921 010a 06D9     		bls	.L51
 922              		.loc 1 1009 0 is_stmt 0 discriminator 1
 923 010c 3B69     		ldr	r3, [r7, #16]
 924 010e DA6A     		ldr	r2, [r3, #44]
 925 0110 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 926 0114 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 927 0118 1A60     		str	r2, [r3, #0]
 928              	.L51:
 929              		.loc 1 1009 0 discriminator 2
 930 011a 3B69     		ldr	r3, [r7, #16]
 931 011c DA6A     		ldr	r2, [r3, #44]
 932 011e 1346     		mov	r3, r2
 933 0120 4FEA8303 		lsl	r3, r3, #2
 934 0124 9B18     		adds	r3, r3, r2
 935 0126 4FEA8303 		lsl	r3, r3, #2
 936 012a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 937 012e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 938 0132 9A18     		adds	r2, r3, r2
 939 0134 3B69     		ldr	r3, [r7, #16]
 940 0136 03F10403 		add	r3, r3, #4
 941 013a 1046     		mov	r0, r2
 942 013c 1946     		mov	r1, r3
 943 013e FFF7FEFF 		bl	vListInsertEnd
 944              	.L50:
1010:Source/tasks.c **** 				}
1011:Source/tasks.c **** 
1012:Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 945              		.loc 1 1012 0 is_stmt 1
 946 0142 7B69     		ldr	r3, [r7, #20]
 947 0144 012B     		cmp	r3, #1
 948 0146 01D1     		bne	.L44
1013:Source/tasks.c **** 				{
1014:Source/tasks.c **** 					portYIELD_WITHIN_API();
 949              		.loc 1 1014 0
 950 0148 FFF7FEFF 		bl	vPortYield
 951              	.L44:
1015:Source/tasks.c **** 				}
1016:Source/tasks.c **** 
1017:Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1018:Source/tasks.c **** 				optimised task selection is not being used. */
1019:Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1020:Source/tasks.c **** 			}
1021:Source/tasks.c **** 		}
1022:Source/tasks.c **** 		taskEXIT_CRITICAL();
 952              		.loc 1 1022 0
 953 014c FFF7FEFF 		bl	vPortExitCritical
1023:Source/tasks.c **** 	}
 954              		.loc 1 1023 0
 955 0150 07F11807 		add	r7, r7, #24
 956 0154 BD46     		mov	sp, r7
 957 0156 80BD     		pop	{r7, pc}
 958              		.cfi_endproc
 959              	.LFE115:
 961              		.section	.text.vTaskSuspend,"ax",%progbits
 962              		.align	2
 963              		.global	vTaskSuspend
 964              		.thumb
 965              		.thumb_func
 967              	vTaskSuspend:
 968              	.LFB116:
1024:Source/tasks.c **** 
1025:Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1026:Source/tasks.c **** /*-----------------------------------------------------------*/
1027:Source/tasks.c **** 
1028:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1029:Source/tasks.c **** 
1030:Source/tasks.c **** 	void vTaskSuspend( xTaskHandle xTaskToSuspend )
1031:Source/tasks.c **** 	{
 969              		.loc 1 1031 0
 970              		.cfi_startproc
 971              		@ args = 0, pretend = 0, frame = 16
 972              		@ frame_needed = 1, uses_anonymous_args = 0
 973 0000 80B5     		push	{r7, lr}
 974              	.LCFI18:
 975              		.cfi_def_cfa_offset 8
 976              		.cfi_offset 7, -8
 977              		.cfi_offset 14, -4
 978 0002 84B0     		sub	sp, sp, #16
 979              	.LCFI19:
 980              		.cfi_def_cfa_offset 24
 981 0004 00AF     		add	r7, sp, #0
 982              	.LCFI20:
 983              		.cfi_def_cfa_register 7
 984 0006 7860     		str	r0, [r7, #4]
1032:Source/tasks.c **** 	tskTCB *pxTCB;
1033:Source/tasks.c **** 
1034:Source/tasks.c **** 		taskENTER_CRITICAL();
 985              		.loc 1 1034 0
 986 0008 FFF7FEFF 		bl	vPortEnterCritical
1035:Source/tasks.c **** 		{
1036:Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1037:Source/tasks.c **** 			being suspended. */
1038:Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 987              		.loc 1 1038 0
 988 000c 7B68     		ldr	r3, [r7, #4]
 989 000e 002B     		cmp	r3, #0
 990 0010 05D1     		bne	.L53
 991              		.loc 1 1038 0 is_stmt 0 discriminator 1
 992 0012 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 993 0016 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 994 001a 1B68     		ldr	r3, [r3, #0]
 995 001c 00E0     		b	.L54
 996              	.L53:
 997              		.loc 1 1038 0 discriminator 2
 998 001e 7B68     		ldr	r3, [r7, #4]
 999              	.L54:
 1000              		.loc 1 1038 0 discriminator 3
 1001 0020 FB60     		str	r3, [r7, #12]
1039:Source/tasks.c **** 
1040:Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1041:Source/tasks.c **** 
1042:Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
1043:Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 1002              		.loc 1 1043 0 is_stmt 1 discriminator 3
 1003 0022 FB68     		ldr	r3, [r7, #12]
 1004 0024 03F10403 		add	r3, r3, #4
 1005 0028 1846     		mov	r0, r3
 1006 002a FFF7FEFF 		bl	uxListRemove
1044:Source/tasks.c **** 			{
1045:Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1046:Source/tasks.c **** 			}
1047:Source/tasks.c **** 
1048:Source/tasks.c **** 			/* Is the task waiting on an event also? */
1049:Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1007              		.loc 1 1049 0 discriminator 3
 1008 002e FB68     		ldr	r3, [r7, #12]
 1009 0030 9B6A     		ldr	r3, [r3, #40]
 1010 0032 002B     		cmp	r3, #0
 1011 0034 05D0     		beq	.L55
1050:Source/tasks.c **** 			{
1051:Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1012              		.loc 1 1051 0
 1013 0036 FB68     		ldr	r3, [r7, #12]
 1014 0038 03F11803 		add	r3, r3, #24
 1015 003c 1846     		mov	r0, r3
 1016 003e FFF7FEFF 		bl	uxListRemove
 1017              	.L55:
1052:Source/tasks.c **** 			}
1053:Source/tasks.c **** 
1054:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1018              		.loc 1 1054 0
 1019 0042 FB68     		ldr	r3, [r7, #12]
 1020 0044 03F10403 		add	r3, r3, #4
 1021 0048 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 1022 004c C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 1023 0050 1946     		mov	r1, r3
 1024 0052 FFF7FEFF 		bl	vListInsertEnd
1055:Source/tasks.c **** 		}
1056:Source/tasks.c **** 		taskEXIT_CRITICAL();
 1025              		.loc 1 1056 0
 1026 0056 FFF7FEFF 		bl	vPortExitCritical
1057:Source/tasks.c **** 
1058:Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1027              		.loc 1 1058 0
 1028 005a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1029 005e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1030 0062 1B68     		ldr	r3, [r3, #0]
 1031 0064 FA68     		ldr	r2, [r7, #12]
 1032 0066 9A42     		cmp	r2, r3
 1033 0068 1FD1     		bne	.L52
1059:Source/tasks.c **** 		{
1060:Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1034              		.loc 1 1060 0
 1035 006a 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1036 006e C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1037 0072 1B68     		ldr	r3, [r3, #0]
 1038 0074 002B     		cmp	r3, #0
 1039 0076 02D0     		beq	.L57
1061:Source/tasks.c **** 			{
1062:Source/tasks.c **** 				/* The current task has just been suspended. */
1063:Source/tasks.c **** 				portYIELD_WITHIN_API();
 1040              		.loc 1 1063 0
 1041 0078 FFF7FEFF 		bl	vPortYield
 1042 007c 15E0     		b	.L52
 1043              	.L57:
1064:Source/tasks.c **** 			}
1065:Source/tasks.c **** 			else
1066:Source/tasks.c **** 			{
1067:Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1068:Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1069:Source/tasks.c **** 				must be adjusted to point to a different task. */
1070:Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1044              		.loc 1 1070 0
 1045 007e 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1046 0082 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1047 0086 1A68     		ldr	r2, [r3, #0]
 1048 0088 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1049 008c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1050 0090 1B68     		ldr	r3, [r3, #0]
 1051 0092 9A42     		cmp	r2, r3
 1052 0094 07D1     		bne	.L58
1071:Source/tasks.c **** 				{
1072:Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1073:Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1074:Source/tasks.c **** 					be set to point to it no matter what its relative priority
1075:Source/tasks.c **** 					is. */
1076:Source/tasks.c **** 					pxCurrentTCB = NULL;
 1053              		.loc 1 1076 0
 1054 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1055 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1056 009e 4FF00002 		mov	r2, #0
 1057 00a2 1A60     		str	r2, [r3, #0]
 1058 00a4 01E0     		b	.L52
 1059              	.L58:
1077:Source/tasks.c **** 				}
1078:Source/tasks.c **** 				else
1079:Source/tasks.c **** 				{
1080:Source/tasks.c **** 					vTaskSwitchContext();
 1060              		.loc 1 1080 0
 1061 00a6 FFF7FEFF 		bl	vTaskSwitchContext
 1062              	.L52:
1081:Source/tasks.c **** 				}
1082:Source/tasks.c **** 			}
1083:Source/tasks.c **** 		}
1084:Source/tasks.c **** 	}
 1063              		.loc 1 1084 0
 1064 00aa 07F11007 		add	r7, r7, #16
 1065 00ae BD46     		mov	sp, r7
 1066 00b0 80BD     		pop	{r7, pc}
 1067              		.cfi_endproc
 1068              	.LFE116:
 1070 00b2 00BF     		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1071              		.align	2
 1072              		.global	xTaskIsTaskSuspended
 1073              		.thumb
 1074              		.thumb_func
 1076              	xTaskIsTaskSuspended:
 1077              	.LFB117:
1085:Source/tasks.c **** 
1086:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1087:Source/tasks.c **** /*-----------------------------------------------------------*/
1088:Source/tasks.c **** 
1089:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1090:Source/tasks.c **** 
1091:Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
1092:Source/tasks.c **** 	{
 1078              		.loc 1 1092 0
 1079              		.cfi_startproc
 1080              		@ args = 0, pretend = 0, frame = 16
 1081              		@ frame_needed = 1, uses_anonymous_args = 0
 1082 0000 80B5     		push	{r7, lr}
 1083              	.LCFI21:
 1084              		.cfi_def_cfa_offset 8
 1085              		.cfi_offset 7, -8
 1086              		.cfi_offset 14, -4
 1087 0002 84B0     		sub	sp, sp, #16
 1088              	.LCFI22:
 1089              		.cfi_def_cfa_offset 24
 1090 0004 00AF     		add	r7, sp, #0
 1091              	.LCFI23:
 1092              		.cfi_def_cfa_register 7
 1093 0006 7860     		str	r0, [r7, #4]
1093:Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1094              		.loc 1 1093 0
 1095 0008 4FF00003 		mov	r3, #0
 1096 000c FB60     		str	r3, [r7, #12]
1094:Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1097              		.loc 1 1094 0
 1098 000e 7B68     		ldr	r3, [r7, #4]
 1099 0010 BB60     		str	r3, [r7, #8]
1095:Source/tasks.c **** 
1096:Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1097:Source/tasks.c **** 		configASSERT( xTask );
 1100              		.loc 1 1097 0
 1101 0012 7B68     		ldr	r3, [r7, #4]
 1102 0014 002B     		cmp	r3, #0
 1103 0016 02D1     		bne	.L60
 1104              		.loc 1 1097 0 is_stmt 0 discriminator 1
 1105 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 1106              	.L61:
 1107              		.loc 1 1097 0 discriminator 2
 1108 001c FEE7     		b	.L61
 1109              	.L60:
1098:Source/tasks.c **** 
1099:Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
1100:Source/tasks.c **** 		suspended list? */
1101:Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1110              		.loc 1 1101 0 is_stmt 1
 1111 001e BB68     		ldr	r3, [r7, #8]
 1112 0020 5A69     		ldr	r2, [r3, #20]
 1113 0022 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 1114 0026 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 1115 002a 9A42     		cmp	r2, r3
 1116 002c 02D1     		bne	.L62
 1117              		.loc 1 1101 0 is_stmt 0 discriminator 1
 1118 002e 4FF00103 		mov	r3, #1
 1119 0032 01E0     		b	.L63
 1120              	.L62:
 1121              		.loc 1 1101 0 discriminator 2
 1122 0034 4FF00003 		mov	r3, #0
 1123              	.L63:
 1124              		.loc 1 1101 0 discriminator 3
 1125 0038 002B     		cmp	r3, #0
 1126 003a 15D0     		beq	.L64
1102:Source/tasks.c **** 		{
1103:Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1104:Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1127              		.loc 1 1104 0 is_stmt 1
 1128 003c BB68     		ldr	r3, [r7, #8]
 1129 003e 9A6A     		ldr	r2, [r3, #40]
 1130 0040 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1131 0044 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1132 0048 9A42     		cmp	r2, r3
 1133 004a 0DD0     		beq	.L64
1105:Source/tasks.c **** 			{
1106:Source/tasks.c **** 				/* Is it in the suspended list because it is in the
1107:Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
1108:Source/tasks.c **** 				list because it is blocked on a task with no timeout
1109:Source/tasks.c **** 				specified. */
1110:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1134              		.loc 1 1110 0
 1135 004c BB68     		ldr	r3, [r7, #8]
 1136 004e 9B6A     		ldr	r3, [r3, #40]
 1137 0050 002B     		cmp	r3, #0
 1138 0052 02D1     		bne	.L65
 1139              		.loc 1 1110 0 is_stmt 0 discriminator 1
 1140 0054 4FF00103 		mov	r3, #1
 1141 0058 01E0     		b	.L66
 1142              	.L65:
 1143              		.loc 1 1110 0 discriminator 2
 1144 005a 4FF00003 		mov	r3, #0
 1145              	.L66:
 1146              		.loc 1 1110 0 discriminator 3
 1147 005e 002B     		cmp	r3, #0
 1148 0060 02D0     		beq	.L64
1111:Source/tasks.c **** 				{
1112:Source/tasks.c **** 					xReturn = pdTRUE;
 1149              		.loc 1 1112 0 is_stmt 1
 1150 0062 4FF00103 		mov	r3, #1
 1151 0066 FB60     		str	r3, [r7, #12]
 1152              	.L64:
1113:Source/tasks.c **** 				}
1114:Source/tasks.c **** 			}
1115:Source/tasks.c **** 		}
1116:Source/tasks.c **** 
1117:Source/tasks.c **** 		return xReturn;
 1153              		.loc 1 1117 0
 1154 0068 FB68     		ldr	r3, [r7, #12]
1118:Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1155              		.loc 1 1118 0
 1156 006a 1846     		mov	r0, r3
 1157 006c 07F11007 		add	r7, r7, #16
 1158 0070 BD46     		mov	sp, r7
 1159 0072 80BD     		pop	{r7, pc}
 1160              		.cfi_endproc
 1161              	.LFE117:
 1163              		.section	.text.vTaskResume,"ax",%progbits
 1164              		.align	2
 1165              		.global	vTaskResume
 1166              		.thumb
 1167              		.thumb_func
 1169              	vTaskResume:
 1170              	.LFB118:
1119:Source/tasks.c **** 
1120:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1121:Source/tasks.c **** /*-----------------------------------------------------------*/
1122:Source/tasks.c **** 
1123:Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1124:Source/tasks.c **** 
1125:Source/tasks.c **** 	void vTaskResume( xTaskHandle xTaskToResume )
1126:Source/tasks.c **** 	{
 1171              		.loc 1 1126 0
 1172              		.cfi_startproc
 1173              		@ args = 0, pretend = 0, frame = 16
 1174              		@ frame_needed = 1, uses_anonymous_args = 0
 1175 0000 80B5     		push	{r7, lr}
 1176              	.LCFI24:
 1177              		.cfi_def_cfa_offset 8
 1178              		.cfi_offset 7, -8
 1179              		.cfi_offset 14, -4
 1180 0002 84B0     		sub	sp, sp, #16
 1181              	.LCFI25:
 1182              		.cfi_def_cfa_offset 24
 1183 0004 00AF     		add	r7, sp, #0
 1184              	.LCFI26:
 1185              		.cfi_def_cfa_register 7
 1186 0006 7860     		str	r0, [r7, #4]
1127:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
 1187              		.loc 1 1127 0
 1188 0008 7B68     		ldr	r3, [r7, #4]
 1189 000a FB60     		str	r3, [r7, #12]
1128:Source/tasks.c **** 
1129:Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1130:Source/tasks.c **** 		configASSERT( xTaskToResume );
 1190              		.loc 1 1130 0
 1191 000c 7B68     		ldr	r3, [r7, #4]
 1192 000e 002B     		cmp	r3, #0
 1193 0010 02D1     		bne	.L69
 1194              		.loc 1 1130 0 is_stmt 0 discriminator 1
 1195 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1196              	.L70:
 1197              		.loc 1 1130 0 discriminator 2
 1198 0016 FEE7     		b	.L70
 1199              	.L69:
1131:Source/tasks.c **** 
1132:Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1133:Source/tasks.c **** 		currently executing task. */
1134:Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1200              		.loc 1 1134 0 is_stmt 1
 1201 0018 FB68     		ldr	r3, [r7, #12]
 1202 001a 002B     		cmp	r3, #0
 1203 001c 47D0     		beq	.L68
 1204              		.loc 1 1134 0 is_stmt 0 discriminator 1
 1205 001e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1206 0022 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1207 0026 1B68     		ldr	r3, [r3, #0]
 1208 0028 FA68     		ldr	r2, [r7, #12]
 1209 002a 9A42     		cmp	r2, r3
 1210 002c 3FD0     		beq	.L68
1135:Source/tasks.c **** 		{
1136:Source/tasks.c **** 			taskENTER_CRITICAL();
 1211              		.loc 1 1136 0 is_stmt 1
 1212 002e FFF7FEFF 		bl	vPortEnterCritical
1137:Source/tasks.c **** 			{
1138:Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1213              		.loc 1 1138 0
 1214 0032 F868     		ldr	r0, [r7, #12]
 1215 0034 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1216 0038 0346     		mov	r3, r0
 1217 003a 012B     		cmp	r3, #1
 1218 003c 35D1     		bne	.L72
1139:Source/tasks.c **** 				{
1140:Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1141:Source/tasks.c **** 
1142:Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1143:Source/tasks.c **** 					lists even if the scheduler is suspended. */
1144:Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1219              		.loc 1 1144 0
 1220 003e FB68     		ldr	r3, [r7, #12]
 1221 0040 03F10403 		add	r3, r3, #4
 1222 0044 1846     		mov	r0, r3
 1223 0046 FFF7FEFF 		bl	uxListRemove
1145:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1224              		.loc 1 1145 0
 1225 004a FB68     		ldr	r3, [r7, #12]
 1226 004c DA6A     		ldr	r2, [r3, #44]
 1227 004e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1228 0052 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1229 0056 1B68     		ldr	r3, [r3, #0]
 1230 0058 9A42     		cmp	r2, r3
 1231 005a 06D9     		bls	.L73
 1232              		.loc 1 1145 0 is_stmt 0 discriminator 1
 1233 005c FB68     		ldr	r3, [r7, #12]
 1234 005e DA6A     		ldr	r2, [r3, #44]
 1235 0060 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1236 0064 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1237 0068 1A60     		str	r2, [r3, #0]
 1238              	.L73:
 1239              		.loc 1 1145 0 discriminator 2
 1240 006a FB68     		ldr	r3, [r7, #12]
 1241 006c DA6A     		ldr	r2, [r3, #44]
 1242 006e 1346     		mov	r3, r2
 1243 0070 4FEA8303 		lsl	r3, r3, #2
 1244 0074 9B18     		adds	r3, r3, r2
 1245 0076 4FEA8303 		lsl	r3, r3, #2
 1246 007a 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1247 007e C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1248 0082 9A18     		adds	r2, r3, r2
 1249 0084 FB68     		ldr	r3, [r7, #12]
 1250 0086 03F10403 		add	r3, r3, #4
 1251 008a 1046     		mov	r0, r2
 1252 008c 1946     		mov	r1, r3
 1253 008e FFF7FEFF 		bl	vListInsertEnd
1146:Source/tasks.c **** 
1147:Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1148:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1254              		.loc 1 1148 0 is_stmt 1 discriminator 2
 1255 0092 FB68     		ldr	r3, [r7, #12]
 1256 0094 DA6A     		ldr	r2, [r3, #44]
 1257 0096 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1258 009a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1259 009e 1B68     		ldr	r3, [r3, #0]
 1260 00a0 DB6A     		ldr	r3, [r3, #44]
 1261 00a2 9A42     		cmp	r2, r3
 1262 00a4 01D3     		bcc	.L72
1149:Source/tasks.c **** 					{
1150:Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1151:Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1152:Source/tasks.c **** 						portYIELD_WITHIN_API();
 1263              		.loc 1 1152 0
 1264 00a6 FFF7FEFF 		bl	vPortYield
 1265              	.L72:
1153:Source/tasks.c **** 					}
1154:Source/tasks.c **** 				}
1155:Source/tasks.c **** 			}
1156:Source/tasks.c **** 			taskEXIT_CRITICAL();
 1266              		.loc 1 1156 0
 1267 00aa FFF7FEFF 		bl	vPortExitCritical
 1268              	.L68:
1157:Source/tasks.c **** 		}
1158:Source/tasks.c **** 	}
 1269              		.loc 1 1158 0
 1270 00ae 07F11007 		add	r7, r7, #16
 1271 00b2 BD46     		mov	sp, r7
 1272 00b4 80BD     		pop	{r7, pc}
 1273              		.cfi_endproc
 1274              	.LFE118:
 1276 00b6 00BF     		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1277              		.align	2
 1278              		.global	xTaskResumeFromISR
 1279              		.thumb
 1280              		.thumb_func
 1282              	xTaskResumeFromISR:
 1283              	.LFB119:
1159:Source/tasks.c **** 
1160:Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1161:Source/tasks.c **** 
1162:Source/tasks.c **** /*-----------------------------------------------------------*/
1163:Source/tasks.c **** 
1164:Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1165:Source/tasks.c **** 
1166:Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
1167:Source/tasks.c **** 	{
 1284              		.loc 1 1167 0
 1285              		.cfi_startproc
 1286              		@ args = 0, pretend = 0, frame = 24
 1287              		@ frame_needed = 1, uses_anonymous_args = 0
 1288 0000 80B5     		push	{r7, lr}
 1289              	.LCFI27:
 1290              		.cfi_def_cfa_offset 8
 1291              		.cfi_offset 7, -8
 1292              		.cfi_offset 14, -4
 1293 0002 86B0     		sub	sp, sp, #24
 1294              	.LCFI28:
 1295              		.cfi_def_cfa_offset 32
 1296 0004 00AF     		add	r7, sp, #0
 1297              	.LCFI29:
 1298              		.cfi_def_cfa_register 7
 1299 0006 7860     		str	r0, [r7, #4]
1168:Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1300              		.loc 1 1168 0
 1301 0008 4FF00003 		mov	r3, #0
 1302 000c 7B61     		str	r3, [r7, #20]
1169:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
 1303              		.loc 1 1169 0
 1304 000e 7B68     		ldr	r3, [r7, #4]
 1305 0010 3B61     		str	r3, [r7, #16]
1170:Source/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1171:Source/tasks.c **** 
1172:Source/tasks.c **** 		configASSERT( xTaskToResume );
 1306              		.loc 1 1172 0
 1307 0012 7B68     		ldr	r3, [r7, #4]
 1308 0014 002B     		cmp	r3, #0
 1309 0016 02D1     		bne	.L75
 1310              		.loc 1 1172 0 is_stmt 0 discriminator 1
 1311 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 1312              	.L76:
 1313              		.loc 1 1172 0 discriminator 2
 1314 001c FEE7     		b	.L76
 1315              	.L75:
1173:Source/tasks.c **** 
1174:Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1175:Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1176:Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1177:Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1178:Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1179:Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1180:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1181:Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1182:Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1183:Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1184:Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1185:Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1186:Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1187:Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1188:Source/tasks.c **** 		provided on the following link:
1189:Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1190:Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1316              		.loc 1 1190 0 is_stmt 1
 1317 001e FFF7FEFF 		bl	vPortValidateInterruptPriority
1191:Source/tasks.c **** 
1192:Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1318              		.loc 1 1192 0
 1319 0022 FFF7FEFF 		bl	ulPortSetInterruptMask
 1320 0026 F860     		str	r0, [r7, #12]
1193:Source/tasks.c **** 		{
1194:Source/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1321              		.loc 1 1194 0
 1322 0028 3869     		ldr	r0, [r7, #16]
 1323 002a FFF7FEFF 		bl	xTaskIsTaskSuspended
 1324 002e 0346     		mov	r3, r0
 1325 0030 012B     		cmp	r3, #1
 1326 0032 48D1     		bne	.L77
1195:Source/tasks.c **** 			{
1196:Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1197:Source/tasks.c **** 
1198:Source/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1327              		.loc 1 1198 0
 1328 0034 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1329 0038 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1330 003c 1B68     		ldr	r3, [r3, #0]
 1331 003e 002B     		cmp	r3, #0
 1332 0040 37D1     		bne	.L78
1199:Source/tasks.c **** 				{
1200:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1333              		.loc 1 1200 0
 1334 0042 3B69     		ldr	r3, [r7, #16]
 1335 0044 DA6A     		ldr	r2, [r3, #44]
 1336 0046 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1337 004a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1338 004e 1B68     		ldr	r3, [r3, #0]
 1339 0050 DB6A     		ldr	r3, [r3, #44]
 1340 0052 9A42     		cmp	r2, r3
 1341 0054 02D3     		bcc	.L79
1201:Source/tasks.c **** 					{
1202:Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1342              		.loc 1 1202 0
 1343 0056 4FF00103 		mov	r3, #1
 1344 005a 7B61     		str	r3, [r7, #20]
 1345              	.L79:
1203:Source/tasks.c **** 					}
1204:Source/tasks.c **** 
1205:Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 1346              		.loc 1 1205 0
 1347 005c 3B69     		ldr	r3, [r7, #16]
 1348 005e 03F10403 		add	r3, r3, #4
 1349 0062 1846     		mov	r0, r3
 1350 0064 FFF7FEFF 		bl	uxListRemove
1206:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1351              		.loc 1 1206 0
 1352 0068 3B69     		ldr	r3, [r7, #16]
 1353 006a DA6A     		ldr	r2, [r3, #44]
 1354 006c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1355 0070 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1356 0074 1B68     		ldr	r3, [r3, #0]
 1357 0076 9A42     		cmp	r2, r3
 1358 0078 06D9     		bls	.L80
 1359              		.loc 1 1206 0 is_stmt 0 discriminator 1
 1360 007a 3B69     		ldr	r3, [r7, #16]
 1361 007c DA6A     		ldr	r2, [r3, #44]
 1362 007e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1363 0082 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1364 0086 1A60     		str	r2, [r3, #0]
 1365              	.L80:
 1366              		.loc 1 1206 0 discriminator 2
 1367 0088 3B69     		ldr	r3, [r7, #16]
 1368 008a DA6A     		ldr	r2, [r3, #44]
 1369 008c 1346     		mov	r3, r2
 1370 008e 4FEA8303 		lsl	r3, r3, #2
 1371 0092 9B18     		adds	r3, r3, r2
 1372 0094 4FEA8303 		lsl	r3, r3, #2
 1373 0098 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1374 009c C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1375 00a0 9A18     		adds	r2, r3, r2
 1376 00a2 3B69     		ldr	r3, [r7, #16]
 1377 00a4 03F10403 		add	r3, r3, #4
 1378 00a8 1046     		mov	r0, r2
 1379 00aa 1946     		mov	r1, r3
 1380 00ac FFF7FEFF 		bl	vListInsertEnd
 1381 00b0 09E0     		b	.L77
 1382              	.L78:
1207:Source/tasks.c **** 				}
1208:Source/tasks.c **** 				else
1209:Source/tasks.c **** 				{
1210:Source/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1211:Source/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1212:Source/tasks.c **** 					yield will be performed if necessary. */
1213:Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1383              		.loc 1 1213 0 is_stmt 1
 1384 00b2 3B69     		ldr	r3, [r7, #16]
 1385 00b4 03F11803 		add	r3, r3, #24
 1386 00b8 40F20000 		movw	r0, #:lower16:xPendingReadyList
 1387 00bc C0F20000 		movt	r0, #:upper16:xPendingReadyList
 1388 00c0 1946     		mov	r1, r3
 1389 00c2 FFF7FEFF 		bl	vListInsertEnd
 1390              	.L77:
1214:Source/tasks.c **** 				}
1215:Source/tasks.c **** 			}
1216:Source/tasks.c **** 		}
1217:Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1391              		.loc 1 1217 0
 1392 00c6 F868     		ldr	r0, [r7, #12]
 1393 00c8 FFF7FEFF 		bl	vPortClearInterruptMask
1218:Source/tasks.c **** 
1219:Source/tasks.c **** 		return xYieldRequired;
 1394              		.loc 1 1219 0
 1395 00cc 7B69     		ldr	r3, [r7, #20]
1220:Source/tasks.c **** 	}
 1396              		.loc 1 1220 0
 1397 00ce 1846     		mov	r0, r3
 1398 00d0 07F11807 		add	r7, r7, #24
 1399 00d4 BD46     		mov	sp, r7
 1400 00d6 80BD     		pop	{r7, pc}
 1401              		.cfi_endproc
 1402              	.LFE119:
 1404              		.section	.rodata
 1405              		.align	2
 1406              	.LC0:
 1407 0000 49444C45 		.ascii	"IDLE\000"
 1407      00
 1408 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1409              		.align	2
 1410              		.global	vTaskStartScheduler
 1411              		.thumb
 1412              		.thumb_func
 1414              	vTaskStartScheduler:
 1415              	.LFB120:
1221:Source/tasks.c **** 
1222:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1223:Source/tasks.c **** /*-----------------------------------------------------------*/
1224:Source/tasks.c **** 
1225:Source/tasks.c **** void vTaskStartScheduler( void )
1226:Source/tasks.c **** {
 1416              		.loc 1 1226 0
 1417              		.cfi_startproc
 1418              		@ args = 0, pretend = 0, frame = 8
 1419              		@ frame_needed = 1, uses_anonymous_args = 0
 1420 0000 80B5     		push	{r7, lr}
 1421              	.LCFI30:
 1422              		.cfi_def_cfa_offset 8
 1423              		.cfi_offset 7, -8
 1424              		.cfi_offset 14, -4
 1425 0002 86B0     		sub	sp, sp, #24
 1426              	.LCFI31:
 1427              		.cfi_def_cfa_offset 32
 1428 0004 04AF     		add	r7, sp, #16
 1429              	.LCFI32:
 1430              		.cfi_def_cfa 7, 16
1227:Source/tasks.c **** portBASE_TYPE xReturn;
1228:Source/tasks.c **** 
1229:Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1230:Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1231:Source/tasks.c **** 	{
1232:Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1233:Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1234:Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1235:Source/tasks.c **** 	}
1236:Source/tasks.c **** 	#else
1237:Source/tasks.c **** 	{
1238:Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1239:Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1431              		.loc 1 1239 0
 1432 0006 4FF00003 		mov	r3, #0
 1433 000a 0093     		str	r3, [sp, #0]
 1434 000c 4FF00003 		mov	r3, #0
 1435 0010 0193     		str	r3, [sp, #4]
 1436 0012 4FF00003 		mov	r3, #0
 1437 0016 0293     		str	r3, [sp, #8]
 1438 0018 4FF00003 		mov	r3, #0
 1439 001c 0393     		str	r3, [sp, #12]
 1440 001e 40F20000 		movw	r0, #:lower16:prvIdleTask
 1441 0022 C0F20000 		movt	r0, #:upper16:prvIdleTask
 1442 0026 40F20001 		movw	r1, #:lower16:.LC0
 1443 002a C0F20001 		movt	r1, #:upper16:.LC0
 1444 002e 4FF08202 		mov	r2, #130
 1445 0032 4FF00003 		mov	r3, #0
 1446 0036 FFF7FEFF 		bl	xTaskGenericCreate
 1447 003a 7860     		str	r0, [r7, #4]
1240:Source/tasks.c **** 	}
1241:Source/tasks.c **** 	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1242:Source/tasks.c **** 
1243:Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1244:Source/tasks.c **** 	{
1245:Source/tasks.c **** 		if( xReturn == pdPASS )
 1448              		.loc 1 1245 0
 1449 003c 7B68     		ldr	r3, [r7, #4]
 1450 003e 012B     		cmp	r3, #1
 1451 0040 02D1     		bne	.L83
1246:Source/tasks.c **** 		{
1247:Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1452              		.loc 1 1247 0
 1453 0042 FFF7FEFF 		bl	xTimerCreateTimerTask
 1454 0046 7860     		str	r0, [r7, #4]
 1455              	.L83:
1248:Source/tasks.c **** 		}
1249:Source/tasks.c **** 	}
1250:Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1251:Source/tasks.c **** 
1252:Source/tasks.c **** 	if( xReturn == pdPASS )
 1456              		.loc 1 1252 0
 1457 0048 7B68     		ldr	r3, [r7, #4]
 1458 004a 012B     		cmp	r3, #1
 1459 004c 12D1     		bne	.L84
1253:Source/tasks.c **** 	{
1254:Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1255:Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1256:Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1257:Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1258:Source/tasks.c **** 		starts to run. */
1259:Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1460              		.loc 1 1259 0
 1461 004e FFF7FEFF 		bl	ulPortSetInterruptMask
1260:Source/tasks.c **** 
1261:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1262:Source/tasks.c **** 		{
1263:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1264:Source/tasks.c **** 			structure specific to the task that will run first. */
1265:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1266:Source/tasks.c **** 		}
1267:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1268:Source/tasks.c **** 
1269:Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1462              		.loc 1 1269 0
 1463 0052 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1464 0056 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1465 005a 4FF00102 		mov	r2, #1
 1466 005e 1A60     		str	r2, [r3, #0]
1270:Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1467              		.loc 1 1270 0
 1468 0060 40F20003 		movw	r3, #:lower16:xTickCount
 1469 0064 C0F20003 		movt	r3, #:upper16:xTickCount
 1470 0068 4FF00002 		mov	r2, #0
 1471 006c 1A60     		str	r2, [r3, #0]
1271:Source/tasks.c **** 
1272:Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1273:Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1274:Source/tasks.c **** 		the run time counter time base. */
1275:Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1276:Source/tasks.c **** 
1277:Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1278:Source/tasks.c **** 		portable interface. */
1279:Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1472              		.loc 1 1279 0
 1473 006e FFF7FEFF 		bl	xPortStartScheduler
 1474 0072 05E0     		b	.L82
 1475              	.L84:
1280:Source/tasks.c **** 		{
1281:Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1282:Source/tasks.c **** 			function will not return. */
1283:Source/tasks.c **** 		}
1284:Source/tasks.c **** 		else
1285:Source/tasks.c **** 		{
1286:Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1287:Source/tasks.c **** 		}
1288:Source/tasks.c **** 	}
1289:Source/tasks.c **** 	else
1290:Source/tasks.c **** 	{
1291:Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1292:Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1293:Source/tasks.c **** 		or the timer task. */
1294:Source/tasks.c **** 		configASSERT( xReturn );
 1476              		.loc 1 1294 0
 1477 0074 7B68     		ldr	r3, [r7, #4]
 1478 0076 002B     		cmp	r3, #0
 1479 0078 02D1     		bne	.L82
 1480              		.loc 1 1294 0 is_stmt 0 discriminator 1
 1481 007a FFF7FEFF 		bl	ulPortSetInterruptMask
 1482              	.L86:
 1483              		.loc 1 1294 0 discriminator 2
 1484 007e FEE7     		b	.L86
 1485              	.L82:
1295:Source/tasks.c **** 	}
1296:Source/tasks.c **** }
 1486              		.loc 1 1296 0 is_stmt 1
 1487 0080 07F10807 		add	r7, r7, #8
 1488 0084 BD46     		mov	sp, r7
 1489 0086 80BD     		pop	{r7, pc}
 1490              		.cfi_endproc
 1491              	.LFE120:
 1493              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1494              		.align	2
 1495              		.global	vTaskEndScheduler
 1496              		.thumb
 1497              		.thumb_func
 1499              	vTaskEndScheduler:
 1500              	.LFB121:
1297:Source/tasks.c **** /*-----------------------------------------------------------*/
1298:Source/tasks.c **** 
1299:Source/tasks.c **** void vTaskEndScheduler( void )
1300:Source/tasks.c **** {
 1501              		.loc 1 1300 0
 1502              		.cfi_startproc
 1503              		@ args = 0, pretend = 0, frame = 0
 1504              		@ frame_needed = 1, uses_anonymous_args = 0
 1505 0000 80B5     		push	{r7, lr}
 1506              	.LCFI33:
 1507              		.cfi_def_cfa_offset 8
 1508              		.cfi_offset 7, -8
 1509              		.cfi_offset 14, -4
 1510 0002 00AF     		add	r7, sp, #0
 1511              	.LCFI34:
 1512              		.cfi_def_cfa_register 7
1301:Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1302:Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1303:Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1304:Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1513              		.loc 1 1304 0
 1514 0004 FFF7FEFF 		bl	ulPortSetInterruptMask
1305:Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1515              		.loc 1 1305 0
 1516 0008 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 1517 000c C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 1518 0010 4FF00002 		mov	r2, #0
 1519 0014 1A60     		str	r2, [r3, #0]
1306:Source/tasks.c **** 	vPortEndScheduler();
 1520              		.loc 1 1306 0
 1521 0016 FFF7FEFF 		bl	vPortEndScheduler
1307:Source/tasks.c **** }
 1522              		.loc 1 1307 0
 1523 001a 80BD     		pop	{r7, pc}
 1524              		.cfi_endproc
 1525              	.LFE121:
 1527              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1528              		.align	2
 1529              		.global	vTaskSuspendAll
 1530              		.thumb
 1531              		.thumb_func
 1533              	vTaskSuspendAll:
 1534              	.LFB122:
1308:Source/tasks.c **** /*----------------------------------------------------------*/
1309:Source/tasks.c **** 
1310:Source/tasks.c **** void vTaskSuspendAll( void )
1311:Source/tasks.c **** {
 1535              		.loc 1 1311 0
 1536              		.cfi_startproc
 1537              		@ args = 0, pretend = 0, frame = 0
 1538              		@ frame_needed = 1, uses_anonymous_args = 0
 1539              		@ link register save eliminated.
 1540 0000 80B4     		push	{r7}
 1541              	.LCFI35:
 1542              		.cfi_def_cfa_offset 4
 1543              		.cfi_offset 7, -4
 1544 0002 00AF     		add	r7, sp, #0
 1545              	.LCFI36:
 1546              		.cfi_def_cfa_register 7
1312:Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1313:Source/tasks.c **** 	portBASE_TYPE. */
1314:Source/tasks.c **** 	++uxSchedulerSuspended;
 1547              		.loc 1 1314 0
 1548 0004 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1549 0008 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1550 000c 1B68     		ldr	r3, [r3, #0]
 1551 000e 03F10102 		add	r2, r3, #1
 1552 0012 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1553 0016 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1554 001a 1A60     		str	r2, [r3, #0]
1315:Source/tasks.c **** }
 1555              		.loc 1 1315 0
 1556 001c BD46     		mov	sp, r7
 1557 001e 80BC     		pop	{r7}
 1558 0020 7047     		bx	lr
 1559              		.cfi_endproc
 1560              	.LFE122:
 1562 0022 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1563              		.align	2
 1564              		.global	xTaskResumeAll
 1565              		.thumb
 1566              		.thumb_func
 1568              	xTaskResumeAll:
 1569              	.LFB123:
1316:Source/tasks.c **** /*----------------------------------------------------------*/
1317:Source/tasks.c **** 
1318:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1319:Source/tasks.c **** 
1320:Source/tasks.c **** 	static portTickType prvGetExpectedIdleTime( void )
1321:Source/tasks.c **** 	{
1322:Source/tasks.c **** 	portTickType xReturn;
1323:Source/tasks.c **** 
1324:Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1325:Source/tasks.c **** 		{
1326:Source/tasks.c **** 			xReturn = 0;
1327:Source/tasks.c **** 		}
1328:Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1329:Source/tasks.c **** 		{
1330:Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1331:Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1332:Source/tasks.c **** 			processed. */
1333:Source/tasks.c **** 			xReturn = 0;
1334:Source/tasks.c **** 		}
1335:Source/tasks.c **** 		else
1336:Source/tasks.c **** 		{
1337:Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
1338:Source/tasks.c **** 		}
1339:Source/tasks.c **** 
1340:Source/tasks.c **** 		return xReturn;
1341:Source/tasks.c **** 	}
1342:Source/tasks.c **** 
1343:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1344:Source/tasks.c **** /*----------------------------------------------------------*/
1345:Source/tasks.c **** 
1346:Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1347:Source/tasks.c **** {
 1570              		.loc 1 1347 0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 8
 1573              		@ frame_needed = 1, uses_anonymous_args = 0
 1574 0000 80B5     		push	{r7, lr}
 1575              	.LCFI37:
 1576              		.cfi_def_cfa_offset 8
 1577              		.cfi_offset 7, -8
 1578              		.cfi_offset 14, -4
 1579 0002 82B0     		sub	sp, sp, #8
 1580              	.LCFI38:
 1581              		.cfi_def_cfa_offset 16
 1582 0004 00AF     		add	r7, sp, #0
 1583              	.LCFI39:
 1584              		.cfi_def_cfa_register 7
1348:Source/tasks.c **** tskTCB *pxTCB;
1349:Source/tasks.c **** portBASE_TYPE xAlreadyYielded = pdFALSE;
 1585              		.loc 1 1349 0
 1586 0006 4FF00003 		mov	r3, #0
 1587 000a 7B60     		str	r3, [r7, #4]
1350:Source/tasks.c **** 
1351:Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1352:Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1353:Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1588              		.loc 1 1353 0
 1589 000c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1590 0010 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1591 0014 1B68     		ldr	r3, [r3, #0]
 1592 0016 002B     		cmp	r3, #0
 1593 0018 02D1     		bne	.L90
 1594              		.loc 1 1353 0 is_stmt 0 discriminator 1
 1595 001a FFF7FEFF 		bl	ulPortSetInterruptMask
 1596              	.L91:
 1597              		.loc 1 1353 0 discriminator 2
 1598 001e FEE7     		b	.L91
 1599              	.L90:
1354:Source/tasks.c **** 
1355:Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1356:Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1357:Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1358:Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1359:Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1360:Source/tasks.c **** 	taskENTER_CRITICAL();
 1600              		.loc 1 1360 0 is_stmt 1
 1601 0020 FFF7FEFF 		bl	vPortEnterCritical
1361:Source/tasks.c **** 	{
1362:Source/tasks.c **** 		--uxSchedulerSuspended;
 1602              		.loc 1 1362 0
 1603 0024 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1604 0028 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1605 002c 1B68     		ldr	r3, [r3, #0]
 1606 002e 03F1FF32 		add	r2, r3, #-1
 1607 0032 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1608 0036 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1609 003a 1A60     		str	r2, [r3, #0]
1363:Source/tasks.c **** 
1364:Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1610              		.loc 1 1364 0
 1611 003c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 1612 0040 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 1613 0044 1B68     		ldr	r3, [r3, #0]
 1614 0046 002B     		cmp	r3, #0
 1615 0048 40F08B80 		bne	.L92
1365:Source/tasks.c **** 		{
1366:Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1616              		.loc 1 1366 0
 1617 004c 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1618 0050 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1619 0054 1B68     		ldr	r3, [r3, #0]
 1620 0056 002B     		cmp	r3, #0
 1621 0058 00F08380 		beq	.L92
1367:Source/tasks.c **** 			{
1368:Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1369:Source/tasks.c **** 				appropriate ready list. */
1370:Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1622              		.loc 1 1370 0
 1623 005c 47E0     		b	.L93
 1624              	.L95:
1371:Source/tasks.c **** 				{
1372:Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1625              		.loc 1 1372 0
 1626 005e 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1627 0062 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1628 0066 DB68     		ldr	r3, [r3, #12]
 1629 0068 DB68     		ldr	r3, [r3, #12]
 1630 006a 3B60     		str	r3, [r7, #0]
1373:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1631              		.loc 1 1373 0
 1632 006c 3B68     		ldr	r3, [r7, #0]
 1633 006e 03F11803 		add	r3, r3, #24
 1634 0072 1846     		mov	r0, r3
 1635 0074 FFF7FEFF 		bl	uxListRemove
1374:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 1636              		.loc 1 1374 0
 1637 0078 3B68     		ldr	r3, [r7, #0]
 1638 007a 03F10403 		add	r3, r3, #4
 1639 007e 1846     		mov	r0, r3
 1640 0080 FFF7FEFF 		bl	uxListRemove
1375:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1641              		.loc 1 1375 0
 1642 0084 3B68     		ldr	r3, [r7, #0]
 1643 0086 DA6A     		ldr	r2, [r3, #44]
 1644 0088 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1645 008c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1646 0090 1B68     		ldr	r3, [r3, #0]
 1647 0092 9A42     		cmp	r2, r3
 1648 0094 06D9     		bls	.L94
 1649              		.loc 1 1375 0 is_stmt 0 discriminator 1
 1650 0096 3B68     		ldr	r3, [r7, #0]
 1651 0098 DA6A     		ldr	r2, [r3, #44]
 1652 009a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 1653 009e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 1654 00a2 1A60     		str	r2, [r3, #0]
 1655              	.L94:
 1656              		.loc 1 1375 0 discriminator 2
 1657 00a4 3B68     		ldr	r3, [r7, #0]
 1658 00a6 DA6A     		ldr	r2, [r3, #44]
 1659 00a8 1346     		mov	r3, r2
 1660 00aa 4FEA8303 		lsl	r3, r3, #2
 1661 00ae 9B18     		adds	r3, r3, r2
 1662 00b0 4FEA8303 		lsl	r3, r3, #2
 1663 00b4 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1664 00b8 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1665 00bc 9A18     		adds	r2, r3, r2
 1666 00be 3B68     		ldr	r3, [r7, #0]
 1667 00c0 03F10403 		add	r3, r3, #4
 1668 00c4 1046     		mov	r0, r2
 1669 00c6 1946     		mov	r1, r3
 1670 00c8 FFF7FEFF 		bl	vListInsertEnd
1376:Source/tasks.c **** 
1377:Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1378:Source/tasks.c **** 					the current task then we should yield. */
1379:Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1671              		.loc 1 1379 0 is_stmt 1 discriminator 2
 1672 00cc 3B68     		ldr	r3, [r7, #0]
 1673 00ce DA6A     		ldr	r2, [r3, #44]
 1674 00d0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 1675 00d4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 1676 00d8 1B68     		ldr	r3, [r3, #0]
 1677 00da DB6A     		ldr	r3, [r3, #44]
 1678 00dc 9A42     		cmp	r2, r3
 1679 00de 06D3     		bcc	.L93
1380:Source/tasks.c **** 					{
1381:Source/tasks.c **** 						xYieldPending = pdTRUE;
 1680              		.loc 1 1381 0
 1681 00e0 40F20003 		movw	r3, #:lower16:xYieldPending
 1682 00e4 C0F20003 		movt	r3, #:upper16:xYieldPending
 1683 00e8 4FF00102 		mov	r2, #1
 1684 00ec 1A60     		str	r2, [r3, #0]
 1685              	.L93:
1370:Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1686              		.loc 1 1370 0 discriminator 1
 1687 00ee 40F20003 		movw	r3, #:lower16:xPendingReadyList
 1688 00f2 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 1689 00f6 1B68     		ldr	r3, [r3, #0]
 1690 00f8 002B     		cmp	r3, #0
 1691 00fa B0D1     		bne	.L95
1382:Source/tasks.c **** 					}
1383:Source/tasks.c **** 				}
1384:Source/tasks.c **** 
1385:Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1386:Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1387:Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1388:Source/tasks.c **** 				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1692              		.loc 1 1388 0
 1693 00fc 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1694 0100 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1695 0104 1B68     		ldr	r3, [r3, #0]
 1696 0106 002B     		cmp	r3, #0
 1697 0108 1FD0     		beq	.L96
1389:Source/tasks.c **** 				{
1390:Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1698              		.loc 1 1390 0
 1699 010a 17E0     		b	.L97
 1700              	.L99:
1391:Source/tasks.c **** 					{
1392:Source/tasks.c **** 						if( xTaskIncrementTick() != pdFALSE )
 1701              		.loc 1 1392 0
 1702 010c FFF7FEFF 		bl	xTaskIncrementTick
 1703 0110 0346     		mov	r3, r0
 1704 0112 002B     		cmp	r3, #0
 1705 0114 06D0     		beq	.L98
1393:Source/tasks.c **** 						{
1394:Source/tasks.c **** 							xYieldPending = pdTRUE;
 1706              		.loc 1 1394 0
 1707 0116 40F20003 		movw	r3, #:lower16:xYieldPending
 1708 011a C0F20003 		movt	r3, #:upper16:xYieldPending
 1709 011e 4FF00102 		mov	r2, #1
 1710 0122 1A60     		str	r2, [r3, #0]
 1711              	.L98:
1395:Source/tasks.c **** 						}
1396:Source/tasks.c **** 						--uxPendedTicks;
 1712              		.loc 1 1396 0
 1713 0124 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1714 0128 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1715 012c 1B68     		ldr	r3, [r3, #0]
 1716 012e 03F1FF32 		add	r2, r3, #-1
 1717 0132 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1718 0136 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1719 013a 1A60     		str	r2, [r3, #0]
 1720              	.L97:
1390:Source/tasks.c **** 					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 1721              		.loc 1 1390 0 discriminator 1
 1722 013c 40F20003 		movw	r3, #:lower16:uxPendedTicks
 1723 0140 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 1724 0144 1B68     		ldr	r3, [r3, #0]
 1725 0146 002B     		cmp	r3, #0
 1726 0148 E0D1     		bne	.L99
 1727              	.L96:
1397:Source/tasks.c **** 					}
1398:Source/tasks.c **** 				}
1399:Source/tasks.c **** 
1400:Source/tasks.c **** 				if( xYieldPending == pdTRUE )
 1728              		.loc 1 1400 0
 1729 014a 40F20003 		movw	r3, #:lower16:xYieldPending
 1730 014e C0F20003 		movt	r3, #:upper16:xYieldPending
 1731 0152 1B68     		ldr	r3, [r3, #0]
 1732 0154 012B     		cmp	r3, #1
 1733 0156 04D1     		bne	.L92
1401:Source/tasks.c **** 				{
1402:Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1734              		.loc 1 1402 0
 1735 0158 4FF00103 		mov	r3, #1
 1736 015c 7B60     		str	r3, [r7, #4]
1403:Source/tasks.c **** 					portYIELD_WITHIN_API();
 1737              		.loc 1 1403 0
 1738 015e FFF7FEFF 		bl	vPortYield
 1739              	.L92:
1404:Source/tasks.c **** 				}
1405:Source/tasks.c **** 			}
1406:Source/tasks.c **** 		}
1407:Source/tasks.c **** 	}
1408:Source/tasks.c **** 	taskEXIT_CRITICAL();
 1740              		.loc 1 1408 0
 1741 0162 FFF7FEFF 		bl	vPortExitCritical
1409:Source/tasks.c **** 
1410:Source/tasks.c **** 	return xAlreadyYielded;
 1742              		.loc 1 1410 0
 1743 0166 7B68     		ldr	r3, [r7, #4]
1411:Source/tasks.c **** }
 1744              		.loc 1 1411 0
 1745 0168 1846     		mov	r0, r3
 1746 016a 07F10807 		add	r7, r7, #8
 1747 016e BD46     		mov	sp, r7
 1748 0170 80BD     		pop	{r7, pc}
 1749              		.cfi_endproc
 1750              	.LFE123:
 1752 0172 00BF     		.section	.text.xTaskGetTickCount,"ax",%progbits
 1753              		.align	2
 1754              		.global	xTaskGetTickCount
 1755              		.thumb
 1756              		.thumb_func
 1758              	xTaskGetTickCount:
 1759              	.LFB124:
1412:Source/tasks.c **** /*-----------------------------------------------------------*/
1413:Source/tasks.c **** 
1414:Source/tasks.c **** portTickType xTaskGetTickCount( void )
1415:Source/tasks.c **** {
 1760              		.loc 1 1415 0
 1761              		.cfi_startproc
 1762              		@ args = 0, pretend = 0, frame = 8
 1763              		@ frame_needed = 1, uses_anonymous_args = 0
 1764 0000 80B5     		push	{r7, lr}
 1765              	.LCFI40:
 1766              		.cfi_def_cfa_offset 8
 1767              		.cfi_offset 7, -8
 1768              		.cfi_offset 14, -4
 1769 0002 82B0     		sub	sp, sp, #8
 1770              	.LCFI41:
 1771              		.cfi_def_cfa_offset 16
 1772 0004 00AF     		add	r7, sp, #0
 1773              	.LCFI42:
 1774              		.cfi_def_cfa_register 7
1416:Source/tasks.c **** portTickType xTicks;
1417:Source/tasks.c **** 
1418:Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1419:Source/tasks.c **** 	taskENTER_CRITICAL();
 1775              		.loc 1 1419 0
 1776 0006 FFF7FEFF 		bl	vPortEnterCritical
1420:Source/tasks.c **** 	{
1421:Source/tasks.c **** 		xTicks = xTickCount;
 1777              		.loc 1 1421 0
 1778 000a 40F20003 		movw	r3, #:lower16:xTickCount
 1779 000e C0F20003 		movt	r3, #:upper16:xTickCount
 1780 0012 1B68     		ldr	r3, [r3, #0]
 1781 0014 7B60     		str	r3, [r7, #4]
1422:Source/tasks.c **** 	}
1423:Source/tasks.c **** 	taskEXIT_CRITICAL();
 1782              		.loc 1 1423 0
 1783 0016 FFF7FEFF 		bl	vPortExitCritical
1424:Source/tasks.c **** 
1425:Source/tasks.c **** 	return xTicks;
 1784              		.loc 1 1425 0
 1785 001a 7B68     		ldr	r3, [r7, #4]
1426:Source/tasks.c **** }
 1786              		.loc 1 1426 0
 1787 001c 1846     		mov	r0, r3
 1788 001e 07F10807 		add	r7, r7, #8
 1789 0022 BD46     		mov	sp, r7
 1790 0024 80BD     		pop	{r7, pc}
 1791              		.cfi_endproc
 1792              	.LFE124:
 1794 0026 00BF     		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1795              		.align	2
 1796              		.global	xTaskGetTickCountFromISR
 1797              		.thumb
 1798              		.thumb_func
 1800              	xTaskGetTickCountFromISR:
 1801              	.LFB125:
1427:Source/tasks.c **** /*-----------------------------------------------------------*/
1428:Source/tasks.c **** 
1429:Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1430:Source/tasks.c **** {
 1802              		.loc 1 1430 0
 1803              		.cfi_startproc
 1804              		@ args = 0, pretend = 0, frame = 8
 1805              		@ frame_needed = 1, uses_anonymous_args = 0
 1806 0000 80B5     		push	{r7, lr}
 1807              	.LCFI43:
 1808              		.cfi_def_cfa_offset 8
 1809              		.cfi_offset 7, -8
 1810              		.cfi_offset 14, -4
 1811 0002 82B0     		sub	sp, sp, #8
 1812              	.LCFI44:
 1813              		.cfi_def_cfa_offset 16
 1814 0004 00AF     		add	r7, sp, #0
 1815              	.LCFI45:
 1816              		.cfi_def_cfa_register 7
1431:Source/tasks.c **** portTickType xReturn;
1432:Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1433:Source/tasks.c **** 
1434:Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1435:Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1436:Source/tasks.c **** 	above the maximum system call priority are keep permanently enabled, even
1437:Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1438:Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1439:Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1440:Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1441:Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
1442:Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1443:Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
1444:Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1445:Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1446:Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
1447:Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1448:Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1817              		.loc 1 1448 0
 1818 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
1449:Source/tasks.c **** 
1450:Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1819              		.loc 1 1450 0
 1820 000a FFF7FEFF 		bl	ulPortSetInterruptMask
 1821 000e 7860     		str	r0, [r7, #4]
1451:Source/tasks.c **** 	xReturn = xTickCount;
 1822              		.loc 1 1451 0
 1823 0010 40F20003 		movw	r3, #:lower16:xTickCount
 1824 0014 C0F20003 		movt	r3, #:upper16:xTickCount
 1825 0018 1B68     		ldr	r3, [r3, #0]
 1826 001a 3B60     		str	r3, [r7, #0]
1452:Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1827              		.loc 1 1452 0
 1828 001c 7868     		ldr	r0, [r7, #4]
 1829 001e FFF7FEFF 		bl	vPortClearInterruptMask
1453:Source/tasks.c **** 
1454:Source/tasks.c **** 	return xReturn;
 1830              		.loc 1 1454 0
 1831 0022 3B68     		ldr	r3, [r7, #0]
1455:Source/tasks.c **** }
 1832              		.loc 1 1455 0
 1833 0024 1846     		mov	r0, r3
 1834 0026 07F10807 		add	r7, r7, #8
 1835 002a BD46     		mov	sp, r7
 1836 002c 80BD     		pop	{r7, pc}
 1837              		.cfi_endproc
 1838              	.LFE125:
 1840 002e 00BF     		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1841              		.align	2
 1842              		.global	uxTaskGetNumberOfTasks
 1843              		.thumb
 1844              		.thumb_func
 1846              	uxTaskGetNumberOfTasks:
 1847              	.LFB126:
1456:Source/tasks.c **** /*-----------------------------------------------------------*/
1457:Source/tasks.c **** 
1458:Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1459:Source/tasks.c **** {
 1848              		.loc 1 1459 0
 1849              		.cfi_startproc
 1850              		@ args = 0, pretend = 0, frame = 0
 1851              		@ frame_needed = 1, uses_anonymous_args = 0
 1852              		@ link register save eliminated.
 1853 0000 80B4     		push	{r7}
 1854              	.LCFI46:
 1855              		.cfi_def_cfa_offset 4
 1856              		.cfi_offset 7, -4
 1857 0002 00AF     		add	r7, sp, #0
 1858              	.LCFI47:
 1859              		.cfi_def_cfa_register 7
1460:Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1461:Source/tasks.c **** 	portBASE_TYPE. */
1462:Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1860              		.loc 1 1462 0
 1861 0004 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1862 0008 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1863 000c 1B68     		ldr	r3, [r3, #0]
1463:Source/tasks.c **** }
 1864              		.loc 1 1463 0
 1865 000e 1846     		mov	r0, r3
 1866 0010 BD46     		mov	sp, r7
 1867 0012 80BC     		pop	{r7}
 1868 0014 7047     		bx	lr
 1869              		.cfi_endproc
 1870              	.LFE126:
 1872 0016 00BF     		.section	.text.uxTaskGetSystemState,"ax",%progbits
 1873              		.align	2
 1874              		.global	uxTaskGetSystemState
 1875              		.thumb
 1876              		.thumb_func
 1878              	uxTaskGetSystemState:
 1879              	.LFB127:
1464:Source/tasks.c **** /*-----------------------------------------------------------*/
1465:Source/tasks.c **** 
1466:Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1467:Source/tasks.c **** 
1468:Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1469:Source/tasks.c **** 	{
1470:Source/tasks.c **** 	tskTCB *pxTCB;
1471:Source/tasks.c **** 
1472:Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1473:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1474:Source/tasks.c **** 		configASSERT( pxTCB );
1475:Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1476:Source/tasks.c **** 	}
1477:Source/tasks.c **** 
1478:Source/tasks.c **** #endif /* INCLUDE_pcTaskGetTaskName */
1479:Source/tasks.c **** /*-----------------------------------------------------------*/
1480:Source/tasks.c **** 
1481:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1482:Source/tasks.c **** 
1483:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetSystemState( xTaskStatusType *pxTaskStatusArray, unsigned portBASE
1484:Source/tasks.c **** 	{
 1880              		.loc 1 1484 0
 1881              		.cfi_startproc
 1882              		@ args = 0, pretend = 0, frame = 24
 1883              		@ frame_needed = 1, uses_anonymous_args = 0
 1884 0000 80B5     		push	{r7, lr}
 1885              	.LCFI48:
 1886              		.cfi_def_cfa_offset 8
 1887              		.cfi_offset 7, -8
 1888              		.cfi_offset 14, -4
 1889 0002 86B0     		sub	sp, sp, #24
 1890              	.LCFI49:
 1891              		.cfi_def_cfa_offset 32
 1892 0004 00AF     		add	r7, sp, #0
 1893              	.LCFI50:
 1894              		.cfi_def_cfa_register 7
 1895 0006 F860     		str	r0, [r7, #12]
 1896 0008 B960     		str	r1, [r7, #8]
 1897 000a 7A60     		str	r2, [r7, #4]
1485:Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0, uxQueue = configMAX_PRIORITIES;
 1898              		.loc 1 1485 0
 1899 000c 4FF00003 		mov	r3, #0
 1900 0010 7B61     		str	r3, [r7, #20]
 1901 0012 4FF00503 		mov	r3, #5
 1902 0016 3B61     		str	r3, [r7, #16]
1486:Source/tasks.c **** 
1487:Source/tasks.c **** 		vTaskSuspendAll();
 1903              		.loc 1 1487 0
 1904 0018 FFF7FEFF 		bl	vTaskSuspendAll
1488:Source/tasks.c **** 		{
1489:Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
1490:Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
 1905              		.loc 1 1490 0
 1906 001c 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 1907 0020 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 1908 0024 1B68     		ldr	r3, [r3, #0]
 1909 0026 BA68     		ldr	r2, [r7, #8]
 1910 0028 9A42     		cmp	r2, r3
 1911 002a 74D3     		bcc	.L108
 1912              	.L109:
1491:Source/tasks.c **** 			{
1492:Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1493:Source/tasks.c **** 				task in the Ready state. */
1494:Source/tasks.c **** 				do
1495:Source/tasks.c **** 				{
1496:Source/tasks.c **** 					uxQueue--;
 1913              		.loc 1 1496 0 discriminator 1
 1914 002c 3B69     		ldr	r3, [r7, #16]
 1915 002e 03F1FF33 		add	r3, r3, #-1
 1916 0032 3B61     		str	r3, [r7, #16]
1497:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[
 1917              		.loc 1 1497 0 discriminator 1
 1918 0034 7B69     		ldr	r3, [r7, #20]
 1919 0036 4FEA4313 		lsl	r3, r3, #5
 1920 003a FA68     		ldr	r2, [r7, #12]
 1921 003c D118     		adds	r1, r2, r3
 1922 003e 3A69     		ldr	r2, [r7, #16]
 1923 0040 1346     		mov	r3, r2
 1924 0042 4FEA8303 		lsl	r3, r3, #2
 1925 0046 9B18     		adds	r3, r3, r2
 1926 0048 4FEA8303 		lsl	r3, r3, #2
 1927 004c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 1928 0050 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 1929 0054 9B18     		adds	r3, r3, r2
 1930 0056 0846     		mov	r0, r1
 1931 0058 1946     		mov	r1, r3
 1932 005a 4FF00102 		mov	r2, #1
 1933 005e FFF7FEFF 		bl	prvListTaskWithinSingleList
 1934 0062 0346     		mov	r3, r0
 1935 0064 7A69     		ldr	r2, [r7, #20]
 1936 0066 D318     		adds	r3, r2, r3
 1937 0068 7B61     		str	r3, [r7, #20]
1498:Source/tasks.c **** 
1499:Source/tasks.c **** 				} while( uxQueue > ( unsigned portBASE_TYPE ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception 
 1938              		.loc 1 1499 0 discriminator 1
 1939 006a 3B69     		ldr	r3, [r7, #16]
 1940 006c 002B     		cmp	r3, #0
 1941 006e DDD1     		bne	.L109
1500:Source/tasks.c **** 
1501:Source/tasks.c **** 				/* Fill in an xTaskStatusType structure with information on each
1502:Source/tasks.c **** 				task in the Blocked state. */
1503:Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxDelayedT
 1942              		.loc 1 1503 0
 1943 0070 7B69     		ldr	r3, [r7, #20]
 1944 0072 4FEA4313 		lsl	r3, r3, #5
 1945 0076 FA68     		ldr	r2, [r7, #12]
 1946 0078 D218     		adds	r2, r2, r3
 1947 007a 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 1948 007e C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 1949 0082 1B68     		ldr	r3, [r3, #0]
 1950 0084 1046     		mov	r0, r2
 1951 0086 1946     		mov	r1, r3
 1952 0088 4FF00202 		mov	r2, #2
 1953 008c FFF7FEFF 		bl	prvListTaskWithinSingleList
 1954 0090 0346     		mov	r3, r0
 1955 0092 7A69     		ldr	r2, [r7, #20]
 1956 0094 D318     		adds	r3, r2, r3
 1957 0096 7B61     		str	r3, [r7, #20]
1504:Source/tasks.c **** 				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( xList * ) pxOverflow
 1958              		.loc 1 1504 0
 1959 0098 7B69     		ldr	r3, [r7, #20]
 1960 009a 4FEA4313 		lsl	r3, r3, #5
 1961 009e FA68     		ldr	r2, [r7, #12]
 1962 00a0 D218     		adds	r2, r2, r3
 1963 00a2 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 1964 00a6 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 1965 00aa 1B68     		ldr	r3, [r3, #0]
 1966 00ac 1046     		mov	r0, r2
 1967 00ae 1946     		mov	r1, r3
 1968 00b0 4FF00202 		mov	r2, #2
 1969 00b4 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1970 00b8 0346     		mov	r3, r0
 1971 00ba 7A69     		ldr	r2, [r7, #20]
 1972 00bc D318     		adds	r3, r2, r3
 1973 00be 7B61     		str	r3, [r7, #20]
1505:Source/tasks.c **** 
1506:Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
1507:Source/tasks.c **** 				{
1508:Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1509:Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
1510:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermina
 1974              		.loc 1 1510 0
 1975 00c0 7B69     		ldr	r3, [r7, #20]
 1976 00c2 4FEA4313 		lsl	r3, r3, #5
 1977 00c6 FA68     		ldr	r2, [r7, #12]
 1978 00c8 D318     		adds	r3, r2, r3
 1979 00ca 1846     		mov	r0, r3
 1980 00cc 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 1981 00d0 C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 1982 00d4 4FF00402 		mov	r2, #4
 1983 00d8 FFF7FEFF 		bl	prvListTaskWithinSingleList
 1984 00dc 0346     		mov	r3, r0
 1985 00de 7A69     		ldr	r2, [r7, #20]
 1986 00e0 D318     		adds	r3, r2, r3
 1987 00e2 7B61     		str	r3, [r7, #20]
1511:Source/tasks.c **** 				}
1512:Source/tasks.c **** 				#endif
1513:Source/tasks.c **** 
1514:Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
1515:Source/tasks.c **** 				{
1516:Source/tasks.c **** 					/* Fill in an xTaskStatusType structure with information on
1517:Source/tasks.c **** 					each task in the Suspended state. */
1518:Source/tasks.c **** 					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, 
 1988              		.loc 1 1518 0
 1989 00e4 7B69     		ldr	r3, [r7, #20]
 1990 00e6 4FEA4313 		lsl	r3, r3, #5
 1991 00ea FA68     		ldr	r2, [r7, #12]
 1992 00ec D318     		adds	r3, r2, r3
 1993 00ee 1846     		mov	r0, r3
 1994 00f0 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 1995 00f4 C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 1996 00f8 4FF00302 		mov	r2, #3
 1997 00fc FFF7FEFF 		bl	prvListTaskWithinSingleList
 1998 0100 0346     		mov	r3, r0
 1999 0102 7A69     		ldr	r2, [r7, #20]
 2000 0104 D318     		adds	r3, r2, r3
 2001 0106 7B61     		str	r3, [r7, #20]
1519:Source/tasks.c **** 				}
1520:Source/tasks.c **** 				#endif
1521:Source/tasks.c **** 
1522:Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
1523:Source/tasks.c **** 				{
1524:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
1525:Source/tasks.c **** 					{
1526:Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1527:Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1528:Source/tasks.c **** 						#else
1529:Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1530:Source/tasks.c **** 						#endif
1531:Source/tasks.c **** 					}
1532:Source/tasks.c **** 				}
1533:Source/tasks.c **** 				#else
1534:Source/tasks.c **** 				{
1535:Source/tasks.c **** 					if( pulTotalRunTime != NULL )
 2002              		.loc 1 1535 0
 2003 0108 7B68     		ldr	r3, [r7, #4]
 2004 010a 002B     		cmp	r3, #0
 2005 010c 03D0     		beq	.L108
1536:Source/tasks.c **** 					{
1537:Source/tasks.c **** 						*pulTotalRunTime = 0;
 2006              		.loc 1 1537 0
 2007 010e 7B68     		ldr	r3, [r7, #4]
 2008 0110 4FF00002 		mov	r2, #0
 2009 0114 1A60     		str	r2, [r3, #0]
 2010              	.L108:
1538:Source/tasks.c **** 					}
1539:Source/tasks.c **** 				}
1540:Source/tasks.c **** 				#endif
1541:Source/tasks.c **** 			}
1542:Source/tasks.c **** 		}
1543:Source/tasks.c **** 		( void ) xTaskResumeAll();
 2011              		.loc 1 1543 0
 2012 0116 FFF7FEFF 		bl	xTaskResumeAll
1544:Source/tasks.c **** 
1545:Source/tasks.c **** 		return uxTask;
 2013              		.loc 1 1545 0
 2014 011a 7B69     		ldr	r3, [r7, #20]
1546:Source/tasks.c **** 	}
 2015              		.loc 1 1546 0
 2016 011c 1846     		mov	r0, r3
 2017 011e 07F11807 		add	r7, r7, #24
 2018 0122 BD46     		mov	sp, r7
 2019 0124 80BD     		pop	{r7, pc}
 2020              		.cfi_endproc
 2021              	.LFE127:
 2023 0126 00BF     		.section	.text.xTaskIncrementTick,"ax",%progbits
 2024              		.align	2
 2025              		.global	xTaskIncrementTick
 2026              		.thumb
 2027              		.thumb_func
 2029              	xTaskIncrementTick:
 2030              	.LFB128:
1547:Source/tasks.c **** 
1548:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
1549:Source/tasks.c **** /*----------------------------------------------------------*/
1550:Source/tasks.c **** 
1551:Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1552:Source/tasks.c **** 
1553:Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1554:Source/tasks.c **** 	{
1555:Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1556:Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1557:Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1558:Source/tasks.c **** 		return xIdleTaskHandle;
1559:Source/tasks.c **** 	}
1560:Source/tasks.c **** 
1561:Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1562:Source/tasks.c **** /*----------------------------------------------------------*/
1563:Source/tasks.c **** 
1564:Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
1565:Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
1566:Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1567:Source/tasks.c **** 1. */
1568:Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1569:Source/tasks.c **** 
1570:Source/tasks.c **** 	void vTaskStepTick( portTickType xTicksToJump )
1571:Source/tasks.c **** 	{
1572:Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
1573:Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
1574:Source/tasks.c **** 		each stepped tick. */
1575:Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1576:Source/tasks.c **** 		xTickCount += xTicksToJump;
1577:Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
1578:Source/tasks.c **** 	}
1579:Source/tasks.c **** 
1580:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
1581:Source/tasks.c **** /*----------------------------------------------------------*/
1582:Source/tasks.c **** 
1583:Source/tasks.c **** portBASE_TYPE xTaskIncrementTick( void )
1584:Source/tasks.c **** {
 2031              		.loc 1 1584 0
 2032              		.cfi_startproc
 2033              		@ args = 0, pretend = 0, frame = 24
 2034              		@ frame_needed = 1, uses_anonymous_args = 0
 2035 0000 80B5     		push	{r7, lr}
 2036              	.LCFI51:
 2037              		.cfi_def_cfa_offset 8
 2038              		.cfi_offset 7, -8
 2039              		.cfi_offset 14, -4
 2040 0002 86B0     		sub	sp, sp, #24
 2041              	.LCFI52:
 2042              		.cfi_def_cfa_offset 32
 2043 0004 00AF     		add	r7, sp, #0
 2044              	.LCFI53:
 2045              		.cfi_def_cfa_register 7
1585:Source/tasks.c **** tskTCB * pxTCB;
1586:Source/tasks.c **** portTickType xItemValue;
1587:Source/tasks.c **** portBASE_TYPE xSwitchRequired = pdFALSE;
 2046              		.loc 1 1587 0
 2047 0006 4FF00003 		mov	r3, #0
 2048 000a 7B61     		str	r3, [r7, #20]
1588:Source/tasks.c **** 
1589:Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1590:Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1591:Source/tasks.c **** 	tasks to be unblocked. */
1592:Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1593:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2049              		.loc 1 1593 0
 2050 000c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2051 0010 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2052 0014 1B68     		ldr	r3, [r3, #0]
 2053 0016 002B     		cmp	r3, #0
 2054 0018 40F00281 		bne	.L112
1594:Source/tasks.c **** 	{
1595:Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
1596:Source/tasks.c **** 		delayed lists if it wraps to 0. */
1597:Source/tasks.c **** 		++xTickCount;
 2055              		.loc 1 1597 0
 2056 001c 40F20003 		movw	r3, #:lower16:xTickCount
 2057 0020 C0F20003 		movt	r3, #:upper16:xTickCount
 2058 0024 1B68     		ldr	r3, [r3, #0]
 2059 0026 03F10102 		add	r2, r3, #1
 2060 002a 40F20003 		movw	r3, #:lower16:xTickCount
 2061 002e C0F20003 		movt	r3, #:upper16:xTickCount
 2062 0032 1A60     		str	r2, [r3, #0]
 2063              	.LBB4:
1598:Source/tasks.c **** 
1599:Source/tasks.c **** 		{
1600:Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1601:Source/tasks.c **** 			block. */
1602:Source/tasks.c **** 			const portTickType xConstTickCount = xTickCount;
 2064              		.loc 1 1602 0
 2065 0034 40F20003 		movw	r3, #:lower16:xTickCount
 2066 0038 C0F20003 		movt	r3, #:upper16:xTickCount
 2067 003c 1B68     		ldr	r3, [r3, #0]
 2068 003e 3B61     		str	r3, [r7, #16]
1603:Source/tasks.c **** 
1604:Source/tasks.c **** 			if( xConstTickCount == ( portTickType ) 0U )
 2069              		.loc 1 1604 0
 2070 0040 3B69     		ldr	r3, [r7, #16]
 2071 0042 002B     		cmp	r3, #0
 2072 0044 52D1     		bne	.L113
 2073              	.LBB5:
1605:Source/tasks.c **** 			{
1606:Source/tasks.c **** 				taskSWITCH_DELAYED_LISTS();
 2074              		.loc 1 1606 0
 2075 0046 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2076 004a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2077 004e 1B68     		ldr	r3, [r3, #0]
 2078 0050 1B68     		ldr	r3, [r3, #0]
 2079 0052 002B     		cmp	r3, #0
 2080 0054 02D0     		beq	.L114
 2081              		.loc 1 1606 0 is_stmt 0 discriminator 1
 2082 0056 FFF7FEFF 		bl	ulPortSetInterruptMask
 2083              	.L115:
 2084              		.loc 1 1606 0 discriminator 3
 2085 005a FEE7     		b	.L115
 2086              	.L114:
 2087              		.loc 1 1606 0 discriminator 2
 2088 005c 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2089 0060 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2090 0064 1B68     		ldr	r3, [r3, #0]
 2091 0066 FB60     		str	r3, [r7, #12]
 2092 0068 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2093 006c C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2094 0070 1A68     		ldr	r2, [r3, #0]
 2095 0072 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2096 0076 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2097 007a 1A60     		str	r2, [r3, #0]
 2098 007c 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 2099 0080 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 2100 0084 FA68     		ldr	r2, [r7, #12]
 2101 0086 1A60     		str	r2, [r3, #0]
 2102 0088 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2103 008c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2104 0090 1B68     		ldr	r3, [r3, #0]
 2105 0092 03F10102 		add	r2, r3, #1
 2106 0096 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2107 009a C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2108 009e 1A60     		str	r2, [r3, #0]
 2109 00a0 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2110 00a4 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2111 00a8 1B68     		ldr	r3, [r3, #0]
 2112 00aa 1B68     		ldr	r3, [r3, #0]
 2113 00ac 002B     		cmp	r3, #0
 2114 00ae 02D1     		bne	.L116
 2115              		.loc 1 1606 0 discriminator 4
 2116 00b0 4FF00103 		mov	r3, #1
 2117 00b4 01E0     		b	.L117
 2118              	.L116:
 2119              		.loc 1 1606 0 discriminator 5
 2120 00b6 4FF00003 		mov	r3, #0
 2121              	.L117:
 2122              		.loc 1 1606 0 discriminator 6
 2123 00ba 002B     		cmp	r3, #0
 2124 00bc 07D0     		beq	.L118
 2125              		.loc 1 1606 0 discriminator 7
 2126 00be 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2127 00c2 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2128 00c6 4FF0FF32 		mov	r2, #-1
 2129 00ca 1A60     		str	r2, [r3, #0]
 2130 00cc 0EE0     		b	.L113
 2131              	.L118:
 2132              		.loc 1 1606 0 discriminator 8
 2133 00ce 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2134 00d2 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2135 00d6 1B68     		ldr	r3, [r3, #0]
 2136 00d8 DB68     		ldr	r3, [r3, #12]
 2137 00da DB68     		ldr	r3, [r3, #12]
 2138 00dc BB60     		str	r3, [r7, #8]
 2139 00de BB68     		ldr	r3, [r7, #8]
 2140 00e0 5A68     		ldr	r2, [r3, #4]
 2141 00e2 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2142 00e6 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2143 00ea 1A60     		str	r2, [r3, #0]
 2144              	.L113:
 2145              	.LBE5:
1607:Source/tasks.c **** 			}
1608:Source/tasks.c **** 
1609:Source/tasks.c **** 			/* See if this tick has made a timeout expire.  Tasks are stored in the
1610:Source/tasks.c **** 			queue in the order of their wake time - meaning once one tasks has been
1611:Source/tasks.c **** 			found whose block time has not expired there is no need not look any
1612:Source/tasks.c **** 			further	down the list. */
1613:Source/tasks.c **** 			if( xConstTickCount >= xNextTaskUnblockTime )
 2146              		.loc 1 1613 0 is_stmt 1
 2147 00ec 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2148 00f0 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2149 00f4 1B68     		ldr	r3, [r3, #0]
 2150 00f6 3A69     		ldr	r2, [r7, #16]
 2151 00f8 9A42     		cmp	r2, r3
 2152 00fa 70D3     		bcc	.L119
 2153 00fc 00E0     		b	.L127
 2154              	.L132:
1614:Source/tasks.c **** 			{
1615:Source/tasks.c **** 				for( ;; )
1616:Source/tasks.c **** 				{
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1618:Source/tasks.c **** 					{
1619:Source/tasks.c **** 						/* The delayed list is empty.  Set xNextTaskUnblockTime to
1620:Source/tasks.c **** 						the	maximum possible value so it is extremely unlikely that
1621:Source/tasks.c **** 						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
1622:Source/tasks.c **** 						next time through. */
1623:Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
1624:Source/tasks.c **** 						break;
1625:Source/tasks.c **** 					}
1626:Source/tasks.c **** 					else
1627:Source/tasks.c **** 					{
1628:Source/tasks.c **** 						/* The delayed list is not empty, get the value of the item
1629:Source/tasks.c **** 						at the head of the delayed list.  This is the time at which
1630:Source/tasks.c **** 						the task at the head of the delayed list must be removed
1631:Source/tasks.c **** 						from the Blocked state. */
1632:Source/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1633:Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1634:Source/tasks.c **** 
1635:Source/tasks.c **** 						if( xConstTickCount < xItemValue )
1636:Source/tasks.c **** 						{
1637:Source/tasks.c **** 							/* It is not time to unblock this item yet, but the item
1638:Source/tasks.c **** 							value is the time at which the task at the head of the
1639:Source/tasks.c **** 							blocked list must be removed from the Blocked state -
1640:Source/tasks.c **** 							so record the item value in xNextTaskUnblockTime. */
1641:Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
1642:Source/tasks.c **** 							break;
1643:Source/tasks.c **** 						}
1644:Source/tasks.c **** 
1645:Source/tasks.c **** 						/* It is time to remove the item from the Blocked state. */
1646:Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
1647:Source/tasks.c **** 
1648:Source/tasks.c **** 						/* Is the task waiting on an event also?  If so remove it
1649:Source/tasks.c **** 						from the event list. */
1650:Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1651:Source/tasks.c **** 						{
1652:Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1653:Source/tasks.c **** 						}
1654:Source/tasks.c **** 
1655:Source/tasks.c **** 						/* Place the unblocked task into the appropriate ready
1656:Source/tasks.c **** 						list. */
1657:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
1658:Source/tasks.c **** 
1659:Source/tasks.c **** 						/* A task being unblocked cannot cause an immediate context
1660:Source/tasks.c **** 						switch if preemption is turned off. */
1661:Source/tasks.c **** 						#if (  configUSE_PREEMPTION == 1 )
1662:Source/tasks.c **** 						{
1663:Source/tasks.c **** 							/* Preemption is on, but a context switch should only
1664:Source/tasks.c **** 							be performed if the unblocked task has a priority that
1665:Source/tasks.c **** 							is equal to or higher than the currently executing
1666:Source/tasks.c **** 							task. */
1667:Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1668:Source/tasks.c **** 							{
1669:Source/tasks.c **** 								xSwitchRequired = pdTRUE;
1670:Source/tasks.c **** 							}
1671:Source/tasks.c **** 						}
1672:Source/tasks.c **** 						#endif /* configUSE_PREEMPTION */
1673:Source/tasks.c **** 					}
1674:Source/tasks.c **** 				}
 2155              		.loc 1 1674 0
 2156 00fe 00BF     		nop
 2157              	.L127:
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2158              		.loc 1 1617 0
 2159 0100 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2160 0104 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2161 0108 1B68     		ldr	r3, [r3, #0]
 2162 010a 1B68     		ldr	r3, [r3, #0]
 2163 010c 002B     		cmp	r3, #0
 2164 010e 02D1     		bne	.L120
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2165              		.loc 1 1617 0 is_stmt 0 discriminator 1
 2166 0110 4FF00103 		mov	r3, #1
 2167 0114 01E0     		b	.L121
 2168              	.L120:
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2169              		.loc 1 1617 0 discriminator 2
 2170 0116 4FF00003 		mov	r3, #0
 2171              	.L121:
1617:Source/tasks.c **** 					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2172              		.loc 1 1617 0 discriminator 3
 2173 011a 002B     		cmp	r3, #0
 2174 011c 07D0     		beq	.L122
1623:Source/tasks.c **** 						xNextTaskUnblockTime = portMAX_DELAY;
 2175              		.loc 1 1623 0 is_stmt 1
 2176 011e 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2177 0122 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2178 0126 4FF0FF32 		mov	r2, #-1
 2179 012a 1A60     		str	r2, [r3, #0]
1624:Source/tasks.c **** 						break;
 2180              		.loc 1 1624 0
 2181 012c 57E0     		b	.L119
 2182              	.L122:
1632:Source/tasks.c **** 						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2183              		.loc 1 1632 0
 2184 012e 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 2185 0132 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 2186 0136 1B68     		ldr	r3, [r3, #0]
 2187 0138 DB68     		ldr	r3, [r3, #12]
 2188 013a DB68     		ldr	r3, [r3, #12]
 2189 013c BB60     		str	r3, [r7, #8]
1633:Source/tasks.c **** 						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2190              		.loc 1 1633 0
 2191 013e BB68     		ldr	r3, [r7, #8]
 2192 0140 5B68     		ldr	r3, [r3, #4]
 2193 0142 7B60     		str	r3, [r7, #4]
1635:Source/tasks.c **** 						if( xConstTickCount < xItemValue )
 2194              		.loc 1 1635 0
 2195 0144 3A69     		ldr	r2, [r7, #16]
 2196 0146 7B68     		ldr	r3, [r7, #4]
 2197 0148 9A42     		cmp	r2, r3
 2198 014a 06D2     		bcs	.L123
1641:Source/tasks.c **** 							xNextTaskUnblockTime = xItemValue;
 2199              		.loc 1 1641 0
 2200 014c 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 2201 0150 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 2202 0154 7A68     		ldr	r2, [r7, #4]
 2203 0156 1A60     		str	r2, [r3, #0]
1642:Source/tasks.c **** 							break;
 2204              		.loc 1 1642 0
 2205 0158 41E0     		b	.L119
 2206              	.L123:
1646:Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 2207              		.loc 1 1646 0
 2208 015a BB68     		ldr	r3, [r7, #8]
 2209 015c 03F10403 		add	r3, r3, #4
 2210 0160 1846     		mov	r0, r3
 2211 0162 FFF7FEFF 		bl	uxListRemove
1650:Source/tasks.c **** 						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2212              		.loc 1 1650 0
 2213 0166 BB68     		ldr	r3, [r7, #8]
 2214 0168 9B6A     		ldr	r3, [r3, #40]
 2215 016a 002B     		cmp	r3, #0
 2216 016c 05D0     		beq	.L124
1652:Source/tasks.c **** 							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2217              		.loc 1 1652 0
 2218 016e BB68     		ldr	r3, [r7, #8]
 2219 0170 03F11803 		add	r3, r3, #24
 2220 0174 1846     		mov	r0, r3
 2221 0176 FFF7FEFF 		bl	uxListRemove
 2222              	.L124:
1657:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2223              		.loc 1 1657 0
 2224 017a BB68     		ldr	r3, [r7, #8]
 2225 017c DA6A     		ldr	r2, [r3, #44]
 2226 017e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2227 0182 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2228 0186 1B68     		ldr	r3, [r3, #0]
 2229 0188 9A42     		cmp	r2, r3
 2230 018a 06D9     		bls	.L125
1657:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2231              		.loc 1 1657 0 is_stmt 0 discriminator 1
 2232 018c BB68     		ldr	r3, [r7, #8]
 2233 018e DA6A     		ldr	r2, [r3, #44]
 2234 0190 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2235 0194 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2236 0198 1A60     		str	r2, [r3, #0]
 2237              	.L125:
1657:Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
 2238              		.loc 1 1657 0 discriminator 2
 2239 019a BB68     		ldr	r3, [r7, #8]
 2240 019c DA6A     		ldr	r2, [r3, #44]
 2241 019e 1346     		mov	r3, r2
 2242 01a0 4FEA8303 		lsl	r3, r3, #2
 2243 01a4 9B18     		adds	r3, r3, r2
 2244 01a6 4FEA8303 		lsl	r3, r3, #2
 2245 01aa 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2246 01ae C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2247 01b2 9A18     		adds	r2, r3, r2
 2248 01b4 BB68     		ldr	r3, [r7, #8]
 2249 01b6 03F10403 		add	r3, r3, #4
 2250 01ba 1046     		mov	r0, r2
 2251 01bc 1946     		mov	r1, r3
 2252 01be FFF7FEFF 		bl	vListInsertEnd
1667:Source/tasks.c **** 							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2253              		.loc 1 1667 0 is_stmt 1 discriminator 2
 2254 01c2 BB68     		ldr	r3, [r7, #8]
 2255 01c4 DA6A     		ldr	r2, [r3, #44]
 2256 01c6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2257 01ca C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2258 01ce 1B68     		ldr	r3, [r3, #0]
 2259 01d0 DB6A     		ldr	r3, [r3, #44]
 2260 01d2 9A42     		cmp	r2, r3
 2261 01d4 93D3     		bcc	.L132
1669:Source/tasks.c **** 								xSwitchRequired = pdTRUE;
 2262              		.loc 1 1669 0
 2263 01d6 4FF00103 		mov	r3, #1
 2264 01da 7B61     		str	r3, [r7, #20]
 2265              		.loc 1 1674 0
 2266 01dc 8FE7     		b	.L132
 2267              	.L119:
 2268              	.LBE4:
1675:Source/tasks.c **** 			}
1676:Source/tasks.c **** 		}
1677:Source/tasks.c **** 
1678:Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
1679:Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
1680:Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
1681:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1682:Source/tasks.c **** 		{
1683:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned p
 2269              		.loc 1 1683 0
 2270 01de 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2271 01e2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2272 01e6 1B68     		ldr	r3, [r3, #0]
 2273 01e8 D96A     		ldr	r1, [r3, #44]
 2274 01ea 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2275 01ee C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2276 01f2 0B46     		mov	r3, r1
 2277 01f4 4FEA8303 		lsl	r3, r3, #2
 2278 01f8 5B18     		adds	r3, r3, r1
 2279 01fa 4FEA8303 		lsl	r3, r3, #2
 2280 01fe D318     		adds	r3, r2, r3
 2281 0200 1B68     		ldr	r3, [r3, #0]
 2282 0202 012B     		cmp	r3, #1
 2283 0204 02D9     		bls	.L128
1684:Source/tasks.c **** 			{
1685:Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2284              		.loc 1 1685 0
 2285 0206 4FF00103 		mov	r3, #1
 2286 020a 7B61     		str	r3, [r7, #20]
 2287              	.L128:
1686:Source/tasks.c **** 			}
1687:Source/tasks.c **** 		}
1688:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1689:Source/tasks.c **** 		
1690:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1691:Source/tasks.c **** 		{
1692:Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
1693:Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
1694:Source/tasks.c **** 			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
 2288              		.loc 1 1694 0
 2289 020c 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2290 0210 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2291 0214 1B68     		ldr	r3, [r3, #0]
 2292 0216 002B     		cmp	r3, #0
 2293 0218 10D1     		bne	.L129
1695:Source/tasks.c **** 			{
1696:Source/tasks.c **** 				vApplicationTickHook();
 2294              		.loc 1 1696 0
 2295 021a FFF7FEFF 		bl	vApplicationTickHook
 2296 021e 0DE0     		b	.L129
 2297              	.L112:
1697:Source/tasks.c **** 			}
1698:Source/tasks.c **** 		}
1699:Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */		
1700:Source/tasks.c **** 	}
1701:Source/tasks.c **** 	else
1702:Source/tasks.c **** 	{
1703:Source/tasks.c **** 		++uxPendedTicks;
 2298              		.loc 1 1703 0
 2299 0220 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2300 0224 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2301 0228 1B68     		ldr	r3, [r3, #0]
 2302 022a 03F10102 		add	r2, r3, #1
 2303 022e 40F20003 		movw	r3, #:lower16:uxPendedTicks
 2304 0232 C0F20003 		movt	r3, #:upper16:uxPendedTicks
 2305 0236 1A60     		str	r2, [r3, #0]
1704:Source/tasks.c **** 
1705:Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1706:Source/tasks.c **** 		scheduler is locked. */
1707:Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1708:Source/tasks.c **** 		{
1709:Source/tasks.c **** 			vApplicationTickHook();
 2306              		.loc 1 1709 0
 2307 0238 FFF7FEFF 		bl	vApplicationTickHook
 2308              	.L129:
1710:Source/tasks.c **** 		}
1711:Source/tasks.c **** 		#endif
1712:Source/tasks.c **** 	}
1713:Source/tasks.c **** 
1714:Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
1715:Source/tasks.c **** 	{
1716:Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 2309              		.loc 1 1716 0
 2310 023c 40F20003 		movw	r3, #:lower16:xYieldPending
 2311 0240 C0F20003 		movt	r3, #:upper16:xYieldPending
 2312 0244 1B68     		ldr	r3, [r3, #0]
 2313 0246 002B     		cmp	r3, #0
 2314 0248 02D0     		beq	.L130
1717:Source/tasks.c **** 		{
1718:Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 2315              		.loc 1 1718 0
 2316 024a 4FF00103 		mov	r3, #1
 2317 024e 7B61     		str	r3, [r7, #20]
 2318              	.L130:
1719:Source/tasks.c **** 		}
1720:Source/tasks.c **** 	}
1721:Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
1722:Source/tasks.c **** 
1723:Source/tasks.c **** 	return xSwitchRequired;
 2319              		.loc 1 1723 0
 2320 0250 7B69     		ldr	r3, [r7, #20]
1724:Source/tasks.c **** }
 2321              		.loc 1 1724 0
 2322 0252 1846     		mov	r0, r3
 2323 0254 07F11807 		add	r7, r7, #24
 2324 0258 BD46     		mov	sp, r7
 2325 025a 80BD     		pop	{r7, pc}
 2326              		.cfi_endproc
 2327              	.LFE128:
 2329              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2330              		.align	2
 2331              		.global	vTaskSwitchContext
 2332              		.thumb
 2333              		.thumb_func
 2335              	vTaskSwitchContext:
 2336              	.LFB129:
1725:Source/tasks.c **** /*-----------------------------------------------------------*/
1726:Source/tasks.c **** 
1727:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1728:Source/tasks.c **** 
1729:Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1730:Source/tasks.c **** 	{
1731:Source/tasks.c **** 	tskTCB *xTCB;
1732:Source/tasks.c **** 
1733:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1734:Source/tasks.c **** 		if( xTask == NULL )
1735:Source/tasks.c **** 		{
1736:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1737:Source/tasks.c **** 		}
1738:Source/tasks.c **** 		else
1739:Source/tasks.c **** 		{
1740:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1741:Source/tasks.c **** 		}
1742:Source/tasks.c **** 
1743:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1744:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1745:Source/tasks.c **** 		taskENTER_CRITICAL();
1746:Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1747:Source/tasks.c **** 		taskEXIT_CRITICAL();
1748:Source/tasks.c **** 	}
1749:Source/tasks.c **** 
1750:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1751:Source/tasks.c **** /*-----------------------------------------------------------*/
1752:Source/tasks.c **** 
1753:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1754:Source/tasks.c **** 
1755:Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1756:Source/tasks.c **** 	{
1757:Source/tasks.c **** 	tskTCB *xTCB;
1758:Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1759:Source/tasks.c **** 
1760:Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1761:Source/tasks.c **** 		if( xTask == NULL )
1762:Source/tasks.c **** 		{
1763:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1764:Source/tasks.c **** 		}
1765:Source/tasks.c **** 		else
1766:Source/tasks.c **** 		{
1767:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1768:Source/tasks.c **** 		}
1769:Source/tasks.c **** 
1770:Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1771:Source/tasks.c **** 		the value can be accessed from an interrupt. */
1772:Source/tasks.c **** 		taskENTER_CRITICAL();
1773:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1774:Source/tasks.c **** 		taskEXIT_CRITICAL();
1775:Source/tasks.c **** 
1776:Source/tasks.c **** 		return xReturn;
1777:Source/tasks.c **** 	}
1778:Source/tasks.c **** 
1779:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1780:Source/tasks.c **** /*-----------------------------------------------------------*/
1781:Source/tasks.c **** 
1782:Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1783:Source/tasks.c **** 
1784:Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1785:Source/tasks.c **** 	{
1786:Source/tasks.c **** 	tskTCB *xTCB;
1787:Source/tasks.c **** 	portBASE_TYPE xReturn;
1788:Source/tasks.c **** 
1789:Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1790:Source/tasks.c **** 		if( xTask == NULL )
1791:Source/tasks.c **** 		{
1792:Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1793:Source/tasks.c **** 		}
1794:Source/tasks.c **** 		else
1795:Source/tasks.c **** 		{
1796:Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1797:Source/tasks.c **** 		}
1798:Source/tasks.c **** 
1799:Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1800:Source/tasks.c **** 		{
1801:Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1802:Source/tasks.c **** 		}
1803:Source/tasks.c **** 		else
1804:Source/tasks.c **** 		{
1805:Source/tasks.c **** 			xReturn = pdFAIL;
1806:Source/tasks.c **** 		}
1807:Source/tasks.c **** 
1808:Source/tasks.c **** 		return xReturn;
1809:Source/tasks.c **** 	}
1810:Source/tasks.c **** 
1811:Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
1812:Source/tasks.c **** /*-----------------------------------------------------------*/
1813:Source/tasks.c **** 
1814:Source/tasks.c **** void vTaskSwitchContext( void )
1815:Source/tasks.c **** {
 2337              		.loc 1 1815 0
 2338              		.cfi_startproc
 2339              		@ args = 0, pretend = 0, frame = 8
 2340              		@ frame_needed = 1, uses_anonymous_args = 0
 2341 0000 80B5     		push	{r7, lr}
 2342              	.LCFI54:
 2343              		.cfi_def_cfa_offset 8
 2344              		.cfi_offset 7, -8
 2345              		.cfi_offset 14, -4
 2346 0002 82B0     		sub	sp, sp, #8
 2347              	.LCFI55:
 2348              		.cfi_def_cfa_offset 16
 2349 0004 00AF     		add	r7, sp, #0
 2350              	.LCFI56:
 2351              		.cfi_def_cfa_register 7
1816:Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2352              		.loc 1 1816 0
 2353 0006 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2354 000a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2355 000e 1B68     		ldr	r3, [r3, #0]
 2356 0010 002B     		cmp	r3, #0
 2357 0012 07D0     		beq	.L134
1817:Source/tasks.c **** 	{
1818:Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1819:Source/tasks.c **** 		switch. */
1820:Source/tasks.c **** 		xYieldPending = pdTRUE;
 2358              		.loc 1 1820 0
 2359 0014 40F20003 		movw	r3, #:lower16:xYieldPending
 2360 0018 C0F20003 		movt	r3, #:upper16:xYieldPending
 2361 001c 4FF00102 		mov	r2, #1
 2362 0020 1A60     		str	r2, [r3, #0]
 2363 0022 9AE0     		b	.L133
 2364              	.L134:
1821:Source/tasks.c **** 	}
1822:Source/tasks.c **** 	else
1823:Source/tasks.c **** 	{
1824:Source/tasks.c **** 		xYieldPending = pdFALSE;
 2365              		.loc 1 1824 0
 2366 0024 40F20003 		movw	r3, #:lower16:xYieldPending
 2367 0028 C0F20003 		movt	r3, #:upper16:xYieldPending
 2368 002c 4FF00002 		mov	r2, #0
 2369 0030 1A60     		str	r2, [r3, #0]
1825:Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1826:Source/tasks.c **** 
1827:Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1828:Source/tasks.c **** 		{
1829:Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1830:Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1831:Source/tasks.c **** 				#else
1832:Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1833:Source/tasks.c **** 				#endif
1834:Source/tasks.c **** 
1835:Source/tasks.c **** 				/* Add the amount of time the task has been running to the
1836:Source/tasks.c **** 				accumulated	time so far.  The time the task started running was
1837:Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
1838:Source/tasks.c **** 				protection here	so count values are only valid until the timer
1839:Source/tasks.c **** 				overflows.  The guard against negative values is to protect
1840:Source/tasks.c **** 				against suspect run time stat counter implementations - which
1841:Source/tasks.c **** 				are provided by the application, not the kernel. */
1842:Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
1843:Source/tasks.c **** 				{
1844:Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
1845:Source/tasks.c **** 				}
1846:Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
1847:Source/tasks.c **** 		}
1848:Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
1849:Source/tasks.c **** 
1850:Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 2370              		.loc 1 1850 0
 2371 0032 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2372 0036 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2373 003a 1B68     		ldr	r3, [r3, #0]
 2374 003c 1A68     		ldr	r2, [r3, #0]
 2375 003e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2376 0042 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2377 0046 1B68     		ldr	r3, [r3, #0]
 2378 0048 1B6B     		ldr	r3, [r3, #48]
 2379 004a 9A42     		cmp	r2, r3
 2380 004c 0FD8     		bhi	.L136
 2381              		.loc 1 1850 0 is_stmt 0 discriminator 1
 2382 004e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2383 0052 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2384 0056 1A68     		ldr	r2, [r3, #0]
 2385 0058 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2386 005c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2387 0060 1B68     		ldr	r3, [r3, #0]
 2388 0062 03F13403 		add	r3, r3, #52
 2389 0066 1046     		mov	r0, r2
 2390 0068 1946     		mov	r1, r3
 2391 006a FFF7FEFF 		bl	vApplicationStackOverflowHook
 2392              	.L136:
 2393              	.LBB6:
1851:Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 2394              		.loc 1 1851 0 is_stmt 1
 2395 006e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2396 0072 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2397 0076 1B68     		ldr	r3, [r3, #0]
 2398 0078 1B6B     		ldr	r3, [r3, #48]
 2399 007a 1846     		mov	r0, r3
 2400 007c 40F20001 		movw	r1, #:lower16:ucExpectedStackBytes.8450
 2401 0080 C0F20001 		movt	r1, #:upper16:ucExpectedStackBytes.8450
 2402 0084 4FF01402 		mov	r2, #20
 2403 0088 FFF7FEFF 		bl	memcmp
 2404 008c 0346     		mov	r3, r0
 2405 008e 002B     		cmp	r3, #0
 2406 0090 26D0     		beq	.L138
 2407              		.loc 1 1851 0 is_stmt 0 discriminator 1
 2408 0092 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2409 0096 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2410 009a 1A68     		ldr	r2, [r3, #0]
 2411 009c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2412 00a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2413 00a4 1B68     		ldr	r3, [r3, #0]
 2414 00a6 03F13403 		add	r3, r3, #52
 2415 00aa 1046     		mov	r0, r2
 2416 00ac 1946     		mov	r1, r3
 2417 00ae FFF7FEFF 		bl	vApplicationStackOverflowHook
 2418              	.LBE6:
1852:Source/tasks.c **** 
1853:Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2419              		.loc 1 1853 0 is_stmt 1 discriminator 1
 2420 00b2 15E0     		b	.L138
 2421              	.L141:
 2422              		.loc 1 1853 0 is_stmt 0 discriminator 5
 2423 00b4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2424 00b8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2425 00bc 1B68     		ldr	r3, [r3, #0]
 2426 00be 002B     		cmp	r3, #0
 2427 00c0 02D1     		bne	.L139
 2428              		.loc 1 1853 0 discriminator 2
 2429 00c2 FFF7FEFF 		bl	ulPortSetInterruptMask
 2430              	.L140:
 2431              		.loc 1 1853 0 discriminator 4
 2432 00c6 FEE7     		b	.L140
 2433              	.L139:
 2434              		.loc 1 1853 0 discriminator 3
 2435 00c8 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2436 00cc C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2437 00d0 1B68     		ldr	r3, [r3, #0]
 2438 00d2 03F1FF32 		add	r2, r3, #-1
 2439 00d6 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2440 00da C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2441 00de 1A60     		str	r2, [r3, #0]
 2442              	.L138:
 2443              		.loc 1 1853 0 discriminator 1
 2444 00e0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2445 00e4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2446 00e8 1968     		ldr	r1, [r3, #0]
 2447 00ea 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2448 00ee C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2449 00f2 0B46     		mov	r3, r1
 2450 00f4 4FEA8303 		lsl	r3, r3, #2
 2451 00f8 5B18     		adds	r3, r3, r1
 2452 00fa 4FEA8303 		lsl	r3, r3, #2
 2453 00fe D318     		adds	r3, r2, r3
 2454 0100 1B68     		ldr	r3, [r3, #0]
 2455 0102 002B     		cmp	r3, #0
 2456 0104 D6D0     		beq	.L141
 2457              	.LBB7:
 2458              		.loc 1 1853 0 discriminator 6
 2459 0106 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2460 010a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2461 010e 1A68     		ldr	r2, [r3, #0]
 2462 0110 1346     		mov	r3, r2
 2463 0112 4FEA8303 		lsl	r3, r3, #2
 2464 0116 9B18     		adds	r3, r3, r2
 2465 0118 4FEA8303 		lsl	r3, r3, #2
 2466 011c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2467 0120 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2468 0124 9B18     		adds	r3, r3, r2
 2469 0126 7B60     		str	r3, [r7, #4]
 2470 0128 7B68     		ldr	r3, [r7, #4]
 2471 012a 5B68     		ldr	r3, [r3, #4]
 2472 012c 5A68     		ldr	r2, [r3, #4]
 2473 012e 7B68     		ldr	r3, [r7, #4]
 2474 0130 5A60     		str	r2, [r3, #4]
 2475 0132 7B68     		ldr	r3, [r7, #4]
 2476 0134 5A68     		ldr	r2, [r3, #4]
 2477 0136 7B68     		ldr	r3, [r7, #4]
 2478 0138 03F10803 		add	r3, r3, #8
 2479 013c 9A42     		cmp	r2, r3
 2480 013e 04D1     		bne	.L142
 2481              		.loc 1 1853 0 discriminator 7
 2482 0140 7B68     		ldr	r3, [r7, #4]
 2483 0142 5B68     		ldr	r3, [r3, #4]
 2484 0144 5A68     		ldr	r2, [r3, #4]
 2485 0146 7B68     		ldr	r3, [r7, #4]
 2486 0148 5A60     		str	r2, [r3, #4]
 2487              	.L142:
 2488              		.loc 1 1853 0 discriminator 8
 2489 014a 7B68     		ldr	r3, [r7, #4]
 2490 014c 5B68     		ldr	r3, [r3, #4]
 2491 014e DA68     		ldr	r2, [r3, #12]
 2492 0150 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2493 0154 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2494 0158 1A60     		str	r2, [r3, #0]
 2495              	.L133:
 2496              	.LBE7:
1854:Source/tasks.c **** 
1855:Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1856:Source/tasks.c **** 
1857:Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1858:Source/tasks.c **** 		{
1859:Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1860:Source/tasks.c **** 			structure specific to this task. */
1861:Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1862:Source/tasks.c **** 		}
1863:Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1864:Source/tasks.c **** 	}
1865:Source/tasks.c **** }
 2497              		.loc 1 1865 0 is_stmt 1
 2498 015a 07F10807 		add	r7, r7, #8
 2499 015e BD46     		mov	sp, r7
 2500 0160 80BD     		pop	{r7, pc}
 2501              		.cfi_endproc
 2502              	.LFE129:
 2504 0162 00BF     		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2505              		.align	2
 2506              		.global	vTaskPlaceOnEventList
 2507              		.thumb
 2508              		.thumb_func
 2510              	vTaskPlaceOnEventList:
 2511              	.LFB130:
1866:Source/tasks.c **** /*-----------------------------------------------------------*/
1867:Source/tasks.c **** 
1868:Source/tasks.c **** void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
1869:Source/tasks.c **** {
 2512              		.loc 1 1869 0
 2513              		.cfi_startproc
 2514              		@ args = 0, pretend = 0, frame = 16
 2515              		@ frame_needed = 1, uses_anonymous_args = 0
 2516 0000 80B5     		push	{r7, lr}
 2517              	.LCFI57:
 2518              		.cfi_def_cfa_offset 8
 2519              		.cfi_offset 7, -8
 2520              		.cfi_offset 14, -4
 2521 0002 84B0     		sub	sp, sp, #16
 2522              	.LCFI58:
 2523              		.cfi_def_cfa_offset 24
 2524 0004 00AF     		add	r7, sp, #0
 2525              	.LCFI59:
 2526              		.cfi_def_cfa_register 7
 2527 0006 7860     		str	r0, [r7, #4]
 2528 0008 3960     		str	r1, [r7, #0]
1870:Source/tasks.c **** portTickType xTimeToWake;
1871:Source/tasks.c **** 
1872:Source/tasks.c **** 	configASSERT( pxEventList );
 2529              		.loc 1 1872 0
 2530 000a 7B68     		ldr	r3, [r7, #4]
 2531 000c 002B     		cmp	r3, #0
 2532 000e 02D1     		bne	.L144
 2533              		.loc 1 1872 0 is_stmt 0 discriminator 1
 2534 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2535              	.L145:
 2536              		.loc 1 1872 0 discriminator 2
 2537 0014 FEE7     		b	.L145
 2538              	.L144:
1873:Source/tasks.c **** 
1874:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1875:Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1876:Source/tasks.c **** 
1877:Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1878:Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1879:Source/tasks.c **** 	is the first to be woken by the event. */
1880:Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2539              		.loc 1 1880 0 is_stmt 1
 2540 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2541 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2542 001e 1B68     		ldr	r3, [r3, #0]
 2543 0020 03F11803 		add	r3, r3, #24
 2544 0024 7868     		ldr	r0, [r7, #4]
 2545 0026 1946     		mov	r1, r3
 2546 0028 FFF7FEFF 		bl	vListInsert
1881:Source/tasks.c **** 
1882:Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1883:Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1884:Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1885:Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 2547              		.loc 1 1885 0
 2548 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2549 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2550 0034 1B68     		ldr	r3, [r3, #0]
 2551 0036 03F10403 		add	r3, r3, #4
 2552 003a 1846     		mov	r0, r3
 2553 003c FFF7FEFF 		bl	uxListRemove
1886:Source/tasks.c **** 	{
1887:Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
1888:Source/tasks.c **** 		check, and the port reset macro can be called directly. */
1889:Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1890:Source/tasks.c **** 	}
1891:Source/tasks.c **** 
1892:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1893:Source/tasks.c **** 	{
1894:Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2554              		.loc 1 1894 0
 2555 0040 3B68     		ldr	r3, [r7, #0]
 2556 0042 B3F1FF3F 		cmp	r3, #-1
 2557 0046 0ED1     		bne	.L146
1895:Source/tasks.c **** 		{
1896:Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1897:Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1898:Source/tasks.c **** 			indefinitely. */
1899:Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 2558              		.loc 1 1899 0
 2559 0048 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2560 004c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2561 0050 1B68     		ldr	r3, [r3, #0]
 2562 0052 03F10403 		add	r3, r3, #4
 2563 0056 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 2564 005a C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 2565 005e 1946     		mov	r1, r3
 2566 0060 FFF7FEFF 		bl	vListInsertEnd
 2567 0064 0AE0     		b	.L143
 2568              	.L146:
1900:Source/tasks.c **** 		}
1901:Source/tasks.c **** 		else
1902:Source/tasks.c **** 		{
1903:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1904:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1905:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2569              		.loc 1 1905 0
 2570 0066 40F20003 		movw	r3, #:lower16:xTickCount
 2571 006a C0F20003 		movt	r3, #:upper16:xTickCount
 2572 006e 1A68     		ldr	r2, [r3, #0]
 2573 0070 3B68     		ldr	r3, [r7, #0]
 2574 0072 D318     		adds	r3, r2, r3
 2575 0074 FB60     		str	r3, [r7, #12]
1906:Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2576              		.loc 1 1906 0
 2577 0076 F868     		ldr	r0, [r7, #12]
 2578 0078 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2579              	.L143:
1907:Source/tasks.c **** 		}
1908:Source/tasks.c **** 	}
1909:Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
1910:Source/tasks.c **** 	{
1911:Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1912:Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1913:Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1914:Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1915:Source/tasks.c **** 	}
1916:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
1917:Source/tasks.c **** }
 2580              		.loc 1 1917 0
 2581 007c 07F11007 		add	r7, r7, #16
 2582 0080 BD46     		mov	sp, r7
 2583 0082 80BD     		pop	{r7, pc}
 2584              		.cfi_endproc
 2585              	.LFE130:
 2587              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2588              		.align	2
 2589              		.global	vTaskPlaceOnEventListRestricted
 2590              		.thumb
 2591              		.thumb_func
 2593              	vTaskPlaceOnEventListRestricted:
 2594              	.LFB131:
1918:Source/tasks.c **** /*-----------------------------------------------------------*/
1919:Source/tasks.c **** 
1920:Source/tasks.c **** #if configUSE_TIMERS == 1
1921:Source/tasks.c **** 
1922:Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
1923:Source/tasks.c **** 	{
 2595              		.loc 1 1923 0
 2596              		.cfi_startproc
 2597              		@ args = 0, pretend = 0, frame = 16
 2598              		@ frame_needed = 1, uses_anonymous_args = 0
 2599 0000 80B5     		push	{r7, lr}
 2600              	.LCFI60:
 2601              		.cfi_def_cfa_offset 8
 2602              		.cfi_offset 7, -8
 2603              		.cfi_offset 14, -4
 2604 0002 84B0     		sub	sp, sp, #16
 2605              	.LCFI61:
 2606              		.cfi_def_cfa_offset 24
 2607 0004 00AF     		add	r7, sp, #0
 2608              	.LCFI62:
 2609              		.cfi_def_cfa_register 7
 2610 0006 7860     		str	r0, [r7, #4]
 2611 0008 3960     		str	r1, [r7, #0]
1924:Source/tasks.c **** 	portTickType xTimeToWake;
1925:Source/tasks.c **** 
1926:Source/tasks.c **** 		configASSERT( pxEventList );
 2612              		.loc 1 1926 0
 2613 000a 7B68     		ldr	r3, [r7, #4]
 2614 000c 002B     		cmp	r3, #0
 2615 000e 02D1     		bne	.L149
 2616              		.loc 1 1926 0 is_stmt 0 discriminator 1
 2617 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2618              	.L150:
 2619              		.loc 1 1926 0 discriminator 2
 2620 0014 FEE7     		b	.L150
 2621              	.L149:
1927:Source/tasks.c **** 
1928:Source/tasks.c **** 		/* This function should not be called by application code hence the
1929:Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1930:Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1931:Source/tasks.c **** 		it should be called from a critical section. */
1932:Source/tasks.c **** 
1933:Source/tasks.c **** 
1934:Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1935:Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1936:Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1937:Source/tasks.c **** 		can be used in place of vListInsert. */
1938:Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2622              		.loc 1 1938 0 is_stmt 1
 2623 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2624 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2625 001e 1B68     		ldr	r3, [r3, #0]
 2626 0020 03F11803 		add	r3, r3, #24
 2627 0024 7868     		ldr	r0, [r7, #4]
 2628 0026 1946     		mov	r1, r3
 2629 0028 FFF7FEFF 		bl	vListInsertEnd
1939:Source/tasks.c **** 
1940:Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1941:Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1942:Source/tasks.c **** 		function is called form a critical section. */
1943:Source/tasks.c **** 		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 2630              		.loc 1 1943 0
 2631 002c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2632 0030 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2633 0034 1B68     		ldr	r3, [r3, #0]
 2634 0036 03F10403 		add	r3, r3, #4
 2635 003a 1846     		mov	r0, r3
 2636 003c FFF7FEFF 		bl	uxListRemove
1944:Source/tasks.c **** 		{
1945:Source/tasks.c **** 			/* The current task must be in a ready list, so there is no need to
1946:Source/tasks.c **** 			check, and the port reset macro can be called directly. */
1947:Source/tasks.c **** 			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
1948:Source/tasks.c **** 		}
1949:Source/tasks.c **** 
1950:Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1951:Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1952:Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2637              		.loc 1 1952 0
 2638 0040 40F20003 		movw	r3, #:lower16:xTickCount
 2639 0044 C0F20003 		movt	r3, #:upper16:xTickCount
 2640 0048 1A68     		ldr	r2, [r3, #0]
 2641 004a 3B68     		ldr	r3, [r7, #0]
 2642 004c D318     		adds	r3, r2, r3
 2643 004e FB60     		str	r3, [r7, #12]
1953:Source/tasks.c **** 
1954:Source/tasks.c **** 		traceTASK_DELAY_UNTIL();
1955:Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2644              		.loc 1 1955 0
 2645 0050 F868     		ldr	r0, [r7, #12]
 2646 0052 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1956:Source/tasks.c **** 	}
 2647              		.loc 1 1956 0
 2648 0056 07F11007 		add	r7, r7, #16
 2649 005a BD46     		mov	sp, r7
 2650 005c 80BD     		pop	{r7, pc}
 2651              		.cfi_endproc
 2652              	.LFE131:
 2654 005e 00BF     		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2655              		.align	2
 2656              		.global	xTaskRemoveFromEventList
 2657              		.thumb
 2658              		.thumb_func
 2660              	xTaskRemoveFromEventList:
 2661              	.LFB132:
1957:Source/tasks.c **** 
1958:Source/tasks.c **** #endif /* configUSE_TIMERS */
1959:Source/tasks.c **** /*-----------------------------------------------------------*/
1960:Source/tasks.c **** 
1961:Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1962:Source/tasks.c **** {
 2662              		.loc 1 1962 0
 2663              		.cfi_startproc
 2664              		@ args = 0, pretend = 0, frame = 16
 2665              		@ frame_needed = 1, uses_anonymous_args = 0
 2666 0000 80B5     		push	{r7, lr}
 2667              	.LCFI63:
 2668              		.cfi_def_cfa_offset 8
 2669              		.cfi_offset 7, -8
 2670              		.cfi_offset 14, -4
 2671 0002 84B0     		sub	sp, sp, #16
 2672              	.LCFI64:
 2673              		.cfi_def_cfa_offset 24
 2674 0004 00AF     		add	r7, sp, #0
 2675              	.LCFI65:
 2676              		.cfi_def_cfa_register 7
 2677 0006 7860     		str	r0, [r7, #4]
1963:Source/tasks.c **** tskTCB *pxUnblockedTCB;
1964:Source/tasks.c **** portBASE_TYPE xReturn;
1965:Source/tasks.c **** 
1966:Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1967:Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1968:Source/tasks.c **** 
1969:Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1970:Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1971:Source/tasks.c **** 	it to the ready list.
1972:Source/tasks.c **** 
1973:Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1974:Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1975:Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1976:Source/tasks.c **** 
1977:Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1978:Source/tasks.c **** 	pxEventList is not empty. */
1979:Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2678              		.loc 1 1979 0
 2679 0008 7B68     		ldr	r3, [r7, #4]
 2680 000a DB68     		ldr	r3, [r3, #12]
 2681 000c DB68     		ldr	r3, [r3, #12]
 2682 000e BB60     		str	r3, [r7, #8]
1980:Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2683              		.loc 1 1980 0
 2684 0010 BB68     		ldr	r3, [r7, #8]
 2685 0012 002B     		cmp	r3, #0
 2686 0014 02D1     		bne	.L152
 2687              		.loc 1 1980 0 is_stmt 0 discriminator 1
 2688 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 2689              	.L153:
 2690              		.loc 1 1980 0 discriminator 2
 2691 001a FEE7     		b	.L153
 2692              	.L152:
1981:Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2693              		.loc 1 1981 0 is_stmt 1
 2694 001c BB68     		ldr	r3, [r7, #8]
 2695 001e 03F11803 		add	r3, r3, #24
 2696 0022 1846     		mov	r0, r3
 2697 0024 FFF7FEFF 		bl	uxListRemove
1982:Source/tasks.c **** 
1983:Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2698              		.loc 1 1983 0
 2699 0028 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 2700 002c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 2701 0030 1B68     		ldr	r3, [r3, #0]
 2702 0032 002B     		cmp	r3, #0
 2703 0034 2AD1     		bne	.L154
1984:Source/tasks.c **** 	{
1985:Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2704              		.loc 1 1985 0
 2705 0036 BB68     		ldr	r3, [r7, #8]
 2706 0038 03F10403 		add	r3, r3, #4
 2707 003c 1846     		mov	r0, r3
 2708 003e FFF7FEFF 		bl	uxListRemove
1986:Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2709              		.loc 1 1986 0
 2710 0042 BB68     		ldr	r3, [r7, #8]
 2711 0044 DA6A     		ldr	r2, [r3, #44]
 2712 0046 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2713 004a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2714 004e 1B68     		ldr	r3, [r3, #0]
 2715 0050 9A42     		cmp	r2, r3
 2716 0052 06D9     		bls	.L155
 2717              		.loc 1 1986 0 is_stmt 0 discriminator 1
 2718 0054 BB68     		ldr	r3, [r7, #8]
 2719 0056 DA6A     		ldr	r2, [r3, #44]
 2720 0058 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 2721 005c C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 2722 0060 1A60     		str	r2, [r3, #0]
 2723              	.L155:
 2724              		.loc 1 1986 0 discriminator 2
 2725 0062 BB68     		ldr	r3, [r7, #8]
 2726 0064 DA6A     		ldr	r2, [r3, #44]
 2727 0066 1346     		mov	r3, r2
 2728 0068 4FEA8303 		lsl	r3, r3, #2
 2729 006c 9B18     		adds	r3, r3, r2
 2730 006e 4FEA8303 		lsl	r3, r3, #2
 2731 0072 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 2732 0076 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 2733 007a 9A18     		adds	r2, r3, r2
 2734 007c BB68     		ldr	r3, [r7, #8]
 2735 007e 03F10403 		add	r3, r3, #4
 2736 0082 1046     		mov	r0, r2
 2737 0084 1946     		mov	r1, r3
 2738 0086 FFF7FEFF 		bl	vListInsertEnd
 2739 008a 09E0     		b	.L156
 2740              	.L154:
1987:Source/tasks.c **** 	}
1988:Source/tasks.c **** 	else
1989:Source/tasks.c **** 	{
1990:Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1991:Source/tasks.c **** 		task pending until the scheduler is resumed. */
1992:Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2741              		.loc 1 1992 0 is_stmt 1
 2742 008c BB68     		ldr	r3, [r7, #8]
 2743 008e 03F11803 		add	r3, r3, #24
 2744 0092 40F20000 		movw	r0, #:lower16:xPendingReadyList
 2745 0096 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 2746 009a 1946     		mov	r1, r3
 2747 009c FFF7FEFF 		bl	vListInsertEnd
 2748              	.L156:
1993:Source/tasks.c **** 	}
1994:Source/tasks.c **** 
1995:Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2749              		.loc 1 1995 0
 2750 00a0 BB68     		ldr	r3, [r7, #8]
 2751 00a2 DA6A     		ldr	r2, [r3, #44]
 2752 00a4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 2753 00a8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 2754 00ac 1B68     		ldr	r3, [r3, #0]
 2755 00ae DB6A     		ldr	r3, [r3, #44]
 2756 00b0 9A42     		cmp	r2, r3
 2757 00b2 0AD3     		bcc	.L157
1996:Source/tasks.c **** 	{
1997:Source/tasks.c **** 		/* Return true if the task removed from the event list has
1998:Source/tasks.c **** 		a higher priority than the calling task.  This allows
1999:Source/tasks.c **** 		the calling task to know if it should force a context
2000:Source/tasks.c **** 		switch now. */
2001:Source/tasks.c **** 		xReturn = pdTRUE;
 2758              		.loc 1 2001 0
 2759 00b4 4FF00103 		mov	r3, #1
 2760 00b8 FB60     		str	r3, [r7, #12]
2002:Source/tasks.c **** 
2003:Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2004:Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2005:Source/tasks.c **** 		xYieldPending = pdTRUE;
 2761              		.loc 1 2005 0
 2762 00ba 40F20003 		movw	r3, #:lower16:xYieldPending
 2763 00be C0F20003 		movt	r3, #:upper16:xYieldPending
 2764 00c2 4FF00102 		mov	r2, #1
 2765 00c6 1A60     		str	r2, [r3, #0]
 2766 00c8 02E0     		b	.L158
 2767              	.L157:
2006:Source/tasks.c **** 	}
2007:Source/tasks.c **** 	else
2008:Source/tasks.c **** 	{
2009:Source/tasks.c **** 		xReturn = pdFALSE;
 2768              		.loc 1 2009 0
 2769 00ca 4FF00003 		mov	r3, #0
 2770 00ce FB60     		str	r3, [r7, #12]
 2771              	.L158:
2010:Source/tasks.c **** 	}
2011:Source/tasks.c **** 
2012:Source/tasks.c **** 	return xReturn;
 2772              		.loc 1 2012 0
 2773 00d0 FB68     		ldr	r3, [r7, #12]
2013:Source/tasks.c **** }
 2774              		.loc 1 2013 0
 2775 00d2 1846     		mov	r0, r3
 2776 00d4 07F11007 		add	r7, r7, #16
 2777 00d8 BD46     		mov	sp, r7
 2778 00da 80BD     		pop	{r7, pc}
 2779              		.cfi_endproc
 2780              	.LFE132:
 2782              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2783              		.align	2
 2784              		.global	vTaskSetTimeOutState
 2785              		.thumb
 2786              		.thumb_func
 2788              	vTaskSetTimeOutState:
 2789              	.LFB133:
2014:Source/tasks.c **** /*-----------------------------------------------------------*/
2015:Source/tasks.c **** 
2016:Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
2017:Source/tasks.c **** {
 2790              		.loc 1 2017 0
 2791              		.cfi_startproc
 2792              		@ args = 0, pretend = 0, frame = 8
 2793              		@ frame_needed = 1, uses_anonymous_args = 0
 2794 0000 80B5     		push	{r7, lr}
 2795              	.LCFI66:
 2796              		.cfi_def_cfa_offset 8
 2797              		.cfi_offset 7, -8
 2798              		.cfi_offset 14, -4
 2799 0002 82B0     		sub	sp, sp, #8
 2800              	.LCFI67:
 2801              		.cfi_def_cfa_offset 16
 2802 0004 00AF     		add	r7, sp, #0
 2803              	.LCFI68:
 2804              		.cfi_def_cfa_register 7
 2805 0006 7860     		str	r0, [r7, #4]
2018:Source/tasks.c **** 	configASSERT( pxTimeOut );
 2806              		.loc 1 2018 0
 2807 0008 7B68     		ldr	r3, [r7, #4]
 2808 000a 002B     		cmp	r3, #0
 2809 000c 02D1     		bne	.L161
 2810              		.loc 1 2018 0 is_stmt 0 discriminator 1
 2811 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2812              	.L162:
 2813              		.loc 1 2018 0 discriminator 2
 2814 0012 FEE7     		b	.L162
 2815              	.L161:
2019:Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2816              		.loc 1 2019 0 is_stmt 1
 2817 0014 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2818 0018 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2819 001c 1A68     		ldr	r2, [r3, #0]
 2820 001e 7B68     		ldr	r3, [r7, #4]
 2821 0020 1A60     		str	r2, [r3, #0]
2020:Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2822              		.loc 1 2020 0
 2823 0022 40F20003 		movw	r3, #:lower16:xTickCount
 2824 0026 C0F20003 		movt	r3, #:upper16:xTickCount
 2825 002a 1A68     		ldr	r2, [r3, #0]
 2826 002c 7B68     		ldr	r3, [r7, #4]
 2827 002e 5A60     		str	r2, [r3, #4]
2021:Source/tasks.c **** }
 2828              		.loc 1 2021 0
 2829 0030 07F10807 		add	r7, r7, #8
 2830 0034 BD46     		mov	sp, r7
 2831 0036 80BD     		pop	{r7, pc}
 2832              		.cfi_endproc
 2833              	.LFE133:
 2835              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2836              		.align	2
 2837              		.global	xTaskCheckForTimeOut
 2838              		.thumb
 2839              		.thumb_func
 2841              	xTaskCheckForTimeOut:
 2842              	.LFB134:
2022:Source/tasks.c **** /*-----------------------------------------------------------*/
2023:Source/tasks.c **** 
2024:Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
2025:Source/tasks.c **** {
 2843              		.loc 1 2025 0
 2844              		.cfi_startproc
 2845              		@ args = 0, pretend = 0, frame = 16
 2846              		@ frame_needed = 1, uses_anonymous_args = 0
 2847 0000 80B5     		push	{r7, lr}
 2848              	.LCFI69:
 2849              		.cfi_def_cfa_offset 8
 2850              		.cfi_offset 7, -8
 2851              		.cfi_offset 14, -4
 2852 0002 84B0     		sub	sp, sp, #16
 2853              	.LCFI70:
 2854              		.cfi_def_cfa_offset 24
 2855 0004 00AF     		add	r7, sp, #0
 2856              	.LCFI71:
 2857              		.cfi_def_cfa_register 7
 2858 0006 7860     		str	r0, [r7, #4]
 2859 0008 3960     		str	r1, [r7, #0]
2026:Source/tasks.c **** portBASE_TYPE xReturn;
2027:Source/tasks.c **** 
2028:Source/tasks.c **** 	configASSERT( pxTimeOut );
 2860              		.loc 1 2028 0
 2861 000a 7B68     		ldr	r3, [r7, #4]
 2862 000c 002B     		cmp	r3, #0
 2863 000e 02D1     		bne	.L164
 2864              		.loc 1 2028 0 is_stmt 0 discriminator 1
 2865 0010 FFF7FEFF 		bl	ulPortSetInterruptMask
 2866              	.L165:
 2867              		.loc 1 2028 0 discriminator 2
 2868 0014 FEE7     		b	.L165
 2869              	.L164:
2029:Source/tasks.c **** 	configASSERT( pxTicksToWait );
 2870              		.loc 1 2029 0 is_stmt 1
 2871 0016 3B68     		ldr	r3, [r7, #0]
 2872 0018 002B     		cmp	r3, #0
 2873 001a 02D1     		bne	.L166
 2874              		.loc 1 2029 0 is_stmt 0 discriminator 1
 2875 001c FFF7FEFF 		bl	ulPortSetInterruptMask
 2876              	.L167:
 2877              		.loc 1 2029 0 discriminator 2
 2878 0020 FEE7     		b	.L167
 2879              	.L166:
2030:Source/tasks.c **** 
2031:Source/tasks.c **** 	taskENTER_CRITICAL();
 2880              		.loc 1 2031 0 is_stmt 1
 2881 0022 FFF7FEFF 		bl	vPortEnterCritical
 2882              	.LBB8:
2032:Source/tasks.c **** 	{
2033:Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
2034:Source/tasks.c **** 		const portTickType xConstTickCount = xTickCount;
 2883              		.loc 1 2034 0
 2884 0026 40F20003 		movw	r3, #:lower16:xTickCount
 2885 002a C0F20003 		movt	r3, #:upper16:xTickCount
 2886 002e 1B68     		ldr	r3, [r3, #0]
 2887 0030 BB60     		str	r3, [r7, #8]
2035:Source/tasks.c **** 
2036:Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
2037:Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2038:Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
2039:Source/tasks.c **** 			therefore never time out. */
2040:Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2888              		.loc 1 2040 0
 2889 0032 3B68     		ldr	r3, [r7, #0]
 2890 0034 1B68     		ldr	r3, [r3, #0]
 2891 0036 B3F1FF3F 		cmp	r3, #-1
 2892 003a 03D1     		bne	.L168
2041:Source/tasks.c **** 			{
2042:Source/tasks.c **** 				xReturn = pdFALSE;
 2893              		.loc 1 2042 0
 2894 003c 4FF00003 		mov	r3, #0
 2895 0040 FB60     		str	r3, [r7, #12]
 2896 0042 2CE0     		b	.L169
 2897              	.L168:
2043:Source/tasks.c **** 			}
2044:Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
2045:Source/tasks.c **** 		#endif
2046:Source/tasks.c **** 
2047:Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 2898              		.loc 1 2047 0
 2899 0044 7B68     		ldr	r3, [r7, #4]
 2900 0046 1A68     		ldr	r2, [r3, #0]
 2901 0048 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 2902 004c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 2903 0050 1B68     		ldr	r3, [r3, #0]
 2904 0052 9A42     		cmp	r2, r3
 2905 0054 08D0     		beq	.L170
 2906              		.loc 1 2047 0 is_stmt 0 discriminator 1
 2907 0056 7B68     		ldr	r3, [r7, #4]
 2908 0058 5A68     		ldr	r2, [r3, #4]
 2909 005a BB68     		ldr	r3, [r7, #8]
 2910 005c 9A42     		cmp	r2, r3
 2911 005e 03D8     		bhi	.L170
2048:Source/tasks.c **** 		{
2049:Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
2050:Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
2051:Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
2052:Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
2053:Source/tasks.c **** 			xReturn = pdTRUE;
 2912              		.loc 1 2053 0 is_stmt 1
 2913 0060 4FF00103 		mov	r3, #1
 2914 0064 FB60     		str	r3, [r7, #12]
 2915 0066 1AE0     		b	.L169
 2916              	.L170:
2054:Source/tasks.c **** 		}
2055:Source/tasks.c **** 		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 2917              		.loc 1 2055 0
 2918 0068 7B68     		ldr	r3, [r7, #4]
 2919 006a 5B68     		ldr	r3, [r3, #4]
 2920 006c BA68     		ldr	r2, [r7, #8]
 2921 006e D21A     		subs	r2, r2, r3
 2922 0070 3B68     		ldr	r3, [r7, #0]
 2923 0072 1B68     		ldr	r3, [r3, #0]
 2924 0074 9A42     		cmp	r2, r3
 2925 0076 0FD2     		bcs	.L171
2056:Source/tasks.c **** 		{
2057:Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
2058:Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 2926              		.loc 1 2058 0
 2927 0078 3B68     		ldr	r3, [r7, #0]
 2928 007a 1A68     		ldr	r2, [r3, #0]
 2929 007c 7B68     		ldr	r3, [r7, #4]
 2930 007e 5968     		ldr	r1, [r3, #4]
 2931 0080 BB68     		ldr	r3, [r7, #8]
 2932 0082 CB1A     		subs	r3, r1, r3
 2933 0084 D218     		adds	r2, r2, r3
 2934 0086 3B68     		ldr	r3, [r7, #0]
 2935 0088 1A60     		str	r2, [r3, #0]
2059:Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2936              		.loc 1 2059 0
 2937 008a 7868     		ldr	r0, [r7, #4]
 2938 008c FFF7FEFF 		bl	vTaskSetTimeOutState
2060:Source/tasks.c **** 			xReturn = pdFALSE;
 2939              		.loc 1 2060 0
 2940 0090 4FF00003 		mov	r3, #0
 2941 0094 FB60     		str	r3, [r7, #12]
 2942 0096 02E0     		b	.L169
 2943              	.L171:
2061:Source/tasks.c **** 		}
2062:Source/tasks.c **** 		else
2063:Source/tasks.c **** 		{
2064:Source/tasks.c **** 			xReturn = pdTRUE;
 2944              		.loc 1 2064 0
 2945 0098 4FF00103 		mov	r3, #1
 2946 009c FB60     		str	r3, [r7, #12]
 2947              	.L169:
 2948              	.LBE8:
2065:Source/tasks.c **** 		}
2066:Source/tasks.c **** 	}
2067:Source/tasks.c **** 	taskEXIT_CRITICAL();
 2949              		.loc 1 2067 0
 2950 009e FFF7FEFF 		bl	vPortExitCritical
2068:Source/tasks.c **** 
2069:Source/tasks.c **** 	return xReturn;
 2951              		.loc 1 2069 0
 2952 00a2 FB68     		ldr	r3, [r7, #12]
2070:Source/tasks.c **** }
 2953              		.loc 1 2070 0
 2954 00a4 1846     		mov	r0, r3
 2955 00a6 07F11007 		add	r7, r7, #16
 2956 00aa BD46     		mov	sp, r7
 2957 00ac 80BD     		pop	{r7, pc}
 2958              		.cfi_endproc
 2959              	.LFE134:
 2961 00ae 00BF     		.section	.text.vTaskMissedYield,"ax",%progbits
 2962              		.align	2
 2963              		.global	vTaskMissedYield
 2964              		.thumb
 2965              		.thumb_func
 2967              	vTaskMissedYield:
 2968              	.LFB135:
2071:Source/tasks.c **** /*-----------------------------------------------------------*/
2072:Source/tasks.c **** 
2073:Source/tasks.c **** void vTaskMissedYield( void )
2074:Source/tasks.c **** {
 2969              		.loc 1 2074 0
 2970              		.cfi_startproc
 2971              		@ args = 0, pretend = 0, frame = 0
 2972              		@ frame_needed = 1, uses_anonymous_args = 0
 2973              		@ link register save eliminated.
 2974 0000 80B4     		push	{r7}
 2975              	.LCFI72:
 2976              		.cfi_def_cfa_offset 4
 2977              		.cfi_offset 7, -4
 2978 0002 00AF     		add	r7, sp, #0
 2979              	.LCFI73:
 2980              		.cfi_def_cfa_register 7
2075:Source/tasks.c **** 	xYieldPending = pdTRUE;
 2981              		.loc 1 2075 0
 2982 0004 40F20003 		movw	r3, #:lower16:xYieldPending
 2983 0008 C0F20003 		movt	r3, #:upper16:xYieldPending
 2984 000c 4FF00102 		mov	r2, #1
 2985 0010 1A60     		str	r2, [r3, #0]
2076:Source/tasks.c **** }
 2986              		.loc 1 2076 0
 2987 0012 BD46     		mov	sp, r7
 2988 0014 80BC     		pop	{r7}
 2989 0016 7047     		bx	lr
 2990              		.cfi_endproc
 2991              	.LFE135:
 2993              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 2994              		.align	2
 2995              		.global	uxTaskGetTaskNumber
 2996              		.thumb
 2997              		.thumb_func
 2999              	uxTaskGetTaskNumber:
 3000              	.LFB136:
2077:Source/tasks.c **** /*-----------------------------------------------------------*/
2078:Source/tasks.c **** 
2079:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2080:Source/tasks.c **** 
2081:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
2082:Source/tasks.c **** 	{
 3001              		.loc 1 2082 0
 3002              		.cfi_startproc
 3003              		@ args = 0, pretend = 0, frame = 16
 3004              		@ frame_needed = 1, uses_anonymous_args = 0
 3005              		@ link register save eliminated.
 3006 0000 80B4     		push	{r7}
 3007              	.LCFI74:
 3008              		.cfi_def_cfa_offset 4
 3009              		.cfi_offset 7, -4
 3010 0002 85B0     		sub	sp, sp, #20
 3011              	.LCFI75:
 3012              		.cfi_def_cfa_offset 24
 3013 0004 00AF     		add	r7, sp, #0
 3014              	.LCFI76:
 3015              		.cfi_def_cfa_register 7
 3016 0006 7860     		str	r0, [r7, #4]
2083:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2084:Source/tasks.c **** 	tskTCB *pxTCB;
2085:Source/tasks.c **** 
2086:Source/tasks.c **** 		if( xTask != NULL )
 3017              		.loc 1 2086 0
 3018 0008 7B68     		ldr	r3, [r7, #4]
 3019 000a 002B     		cmp	r3, #0
 3020 000c 05D0     		beq	.L175
2087:Source/tasks.c **** 		{
2088:Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3021              		.loc 1 2088 0
 3022 000e 7B68     		ldr	r3, [r7, #4]
 3023 0010 BB60     		str	r3, [r7, #8]
2089:Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 3024              		.loc 1 2089 0
 3025 0012 BB68     		ldr	r3, [r7, #8]
 3026 0014 5B6C     		ldr	r3, [r3, #68]
 3027 0016 FB60     		str	r3, [r7, #12]
 3028 0018 02E0     		b	.L176
 3029              	.L175:
2090:Source/tasks.c **** 		}
2091:Source/tasks.c **** 		else
2092:Source/tasks.c **** 		{
2093:Source/tasks.c **** 			uxReturn = 0U;
 3030              		.loc 1 2093 0
 3031 001a 4FF00003 		mov	r3, #0
 3032 001e FB60     		str	r3, [r7, #12]
 3033              	.L176:
2094:Source/tasks.c **** 		}
2095:Source/tasks.c **** 
2096:Source/tasks.c **** 		return uxReturn;
 3034              		.loc 1 2096 0
 3035 0020 FB68     		ldr	r3, [r7, #12]
2097:Source/tasks.c **** 	}
 3036              		.loc 1 2097 0
 3037 0022 1846     		mov	r0, r3
 3038 0024 07F11407 		add	r7, r7, #20
 3039 0028 BD46     		mov	sp, r7
 3040 002a 80BC     		pop	{r7}
 3041 002c 7047     		bx	lr
 3042              		.cfi_endproc
 3043              	.LFE136:
 3045 002e 00BF     		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3046              		.align	2
 3047              		.global	vTaskSetTaskNumber
 3048              		.thumb
 3049              		.thumb_func
 3051              	vTaskSetTaskNumber:
 3052              	.LFB137:
2098:Source/tasks.c **** 
2099:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2100:Source/tasks.c **** /*-----------------------------------------------------------*/
2101:Source/tasks.c **** 
2102:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2103:Source/tasks.c **** 
2104:Source/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
2105:Source/tasks.c **** 	{
 3053              		.loc 1 2105 0
 3054              		.cfi_startproc
 3055              		@ args = 0, pretend = 0, frame = 16
 3056              		@ frame_needed = 1, uses_anonymous_args = 0
 3057              		@ link register save eliminated.
 3058 0000 80B4     		push	{r7}
 3059              	.LCFI77:
 3060              		.cfi_def_cfa_offset 4
 3061              		.cfi_offset 7, -4
 3062 0002 85B0     		sub	sp, sp, #20
 3063              	.LCFI78:
 3064              		.cfi_def_cfa_offset 24
 3065 0004 00AF     		add	r7, sp, #0
 3066              	.LCFI79:
 3067              		.cfi_def_cfa_register 7
 3068 0006 7860     		str	r0, [r7, #4]
 3069 0008 3960     		str	r1, [r7, #0]
2106:Source/tasks.c **** 	tskTCB *pxTCB;
2107:Source/tasks.c **** 
2108:Source/tasks.c **** 		if( xTask != NULL )
 3070              		.loc 1 2108 0
 3071 000a 7B68     		ldr	r3, [r7, #4]
 3072 000c 002B     		cmp	r3, #0
 3073 000e 04D0     		beq	.L178
2109:Source/tasks.c **** 		{
2110:Source/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3074              		.loc 1 2110 0
 3075 0010 7B68     		ldr	r3, [r7, #4]
 3076 0012 FB60     		str	r3, [r7, #12]
2111:Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 3077              		.loc 1 2111 0
 3078 0014 FB68     		ldr	r3, [r7, #12]
 3079 0016 3A68     		ldr	r2, [r7, #0]
 3080 0018 5A64     		str	r2, [r3, #68]
 3081              	.L178:
2112:Source/tasks.c **** 		}
2113:Source/tasks.c **** 	}
 3082              		.loc 1 2113 0
 3083 001a 07F11407 		add	r7, r7, #20
 3084 001e BD46     		mov	sp, r7
 3085 0020 80BC     		pop	{r7}
 3086 0022 7047     		bx	lr
 3087              		.cfi_endproc
 3088              	.LFE137:
 3090              		.section	.text.prvIdleTask,"ax",%progbits
 3091              		.align	2
 3092              		.thumb
 3093              		.thumb_func
 3095              	prvIdleTask:
 3096              	.LFB138:
2114:Source/tasks.c **** 
2115:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2116:Source/tasks.c **** 
2117:Source/tasks.c **** /*
2118:Source/tasks.c ****  * -----------------------------------------------------------
2119:Source/tasks.c ****  * The Idle task.
2120:Source/tasks.c ****  * ----------------------------------------------------------
2121:Source/tasks.c ****  *
2122:Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2123:Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
2124:Source/tasks.c ****  *
2125:Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
2126:Source/tasks.c ****  *
2127:Source/tasks.c ****  */
2128:Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
2129:Source/tasks.c **** {
 3097              		.loc 1 2129 0
 3098              		.cfi_startproc
 3099              		@ args = 0, pretend = 0, frame = 8
 3100              		@ frame_needed = 1, uses_anonymous_args = 0
 3101 0000 80B5     		push	{r7, lr}
 3102              	.LCFI80:
 3103              		.cfi_def_cfa_offset 8
 3104              		.cfi_offset 7, -8
 3105              		.cfi_offset 14, -4
 3106 0002 82B0     		sub	sp, sp, #8
 3107              	.LCFI81:
 3108              		.cfi_def_cfa_offset 16
 3109 0004 00AF     		add	r7, sp, #0
 3110              	.LCFI82:
 3111              		.cfi_def_cfa_register 7
 3112 0006 7860     		str	r0, [r7, #4]
 3113              	.L182:
2130:Source/tasks.c **** 	/* Stop warnings. */
2131:Source/tasks.c **** 	( void ) pvParameters;
2132:Source/tasks.c **** 
2133:Source/tasks.c **** 	for( ;; )
2134:Source/tasks.c **** 	{
2135:Source/tasks.c **** 		/* See if any tasks have been deleted. */
2136:Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3114              		.loc 1 2136 0
 3115 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
2137:Source/tasks.c **** 
2138:Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
2139:Source/tasks.c **** 		{
2140:Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
2141:Source/tasks.c **** 			see if any other task has become available.  If we are using
2142:Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
2143:Source/tasks.c **** 			will automatically get the processor anyway. */
2144:Source/tasks.c **** 			taskYIELD();
2145:Source/tasks.c **** 		}
2146:Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2147:Source/tasks.c **** 
2148:Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2149:Source/tasks.c **** 		{
2150:Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
2151:Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
2152:Source/tasks.c **** 			to run then the idle task should yield before the end of the
2153:Source/tasks.c **** 			timeslice.
2154:Source/tasks.c **** 
2155:Source/tasks.c **** 			A critical region is not required here as we are just reading from
2156:Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
2157:Source/tasks.c **** 			the ready list at the idle priority contains more than one task
2158:Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
2159:Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 3116              		.loc 1 2159 0
 3117 000c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 3118 0010 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 3119 0014 1B68     		ldr	r3, [r3, #0]
 3120 0016 012B     		cmp	r3, #1
 3121 0018 01D9     		bls	.L181
2160:Source/tasks.c **** 			{
2161:Source/tasks.c **** 				taskYIELD();
 3122              		.loc 1 2161 0
 3123 001a FFF7FEFF 		bl	vPortYield
 3124              	.L181:
 3125              	.LBB9:
2162:Source/tasks.c **** 			}
2163:Source/tasks.c **** 		}
2164:Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2165:Source/tasks.c **** 
2166:Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
2167:Source/tasks.c **** 		{
2168:Source/tasks.c **** 			extern void vApplicationIdleHook( void );
2169:Source/tasks.c **** 
2170:Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
2171:Source/tasks.c **** 			allows the application designer to add background functionality
2172:Source/tasks.c **** 			without the overhead of a separate task.
2173:Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2174:Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
2175:Source/tasks.c **** 			vApplicationIdleHook();
 3126              		.loc 1 2175 0
 3127 001e FFF7FEFF 		bl	vApplicationIdleHook
 3128              	.LBE9:
2176:Source/tasks.c **** 		}
2177:Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
2178:Source/tasks.c **** 
2179:Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
2180:Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2181:Source/tasks.c **** 		user defined low power mode	implementations require
2182:Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2183:Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
2184:Source/tasks.c **** 		{
2185:Source/tasks.c **** 		portTickType xExpectedIdleTime;
2186:Source/tasks.c **** 
2187:Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
2188:Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
2189:Source/tasks.c **** 			test of the expected idle time is performed without the
2190:Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
2191:Source/tasks.c **** 			valid. */
2192:Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
2193:Source/tasks.c **** 
2194:Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2195:Source/tasks.c **** 			{
2196:Source/tasks.c **** 				vTaskSuspendAll();
2197:Source/tasks.c **** 				{
2198:Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
2199:Source/tasks.c **** 					time can be sampled again, and this time its value can
2200:Source/tasks.c **** 					be used. */
2201:Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
2202:Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
2203:Source/tasks.c **** 
2204:Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2205:Source/tasks.c **** 					{
2206:Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
2207:Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2208:Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
2209:Source/tasks.c **** 					}
2210:Source/tasks.c **** 				}
2211:Source/tasks.c **** 				( void ) xTaskResumeAll();
2212:Source/tasks.c **** 			}
2213:Source/tasks.c **** 		}
2214:Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
2215:Source/tasks.c **** 	}
 3129              		.loc 1 2215 0
 3130 0022 F1E7     		b	.L182
 3131              		.cfi_endproc
 3132              	.LFE138:
 3134              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 3135              		.align	2
 3136              		.thumb
 3137              		.thumb_func
 3139              	prvInitialiseTCBVariables:
 3140              	.LFB139:
2216:Source/tasks.c **** }
2217:Source/tasks.c **** /*-----------------------------------------------------------*/
2218:Source/tasks.c **** 
2219:Source/tasks.c **** #if configUSE_TICKLESS_IDLE != 0
2220:Source/tasks.c **** 
2221:Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2222:Source/tasks.c **** 	{
2223:Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
2224:Source/tasks.c **** 
2225:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2226:Source/tasks.c **** 		{
2227:Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
2228:Source/tasks.c **** 			eReturn = eAbortSleep;
2229:Source/tasks.c **** 		}
2230:Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
2231:Source/tasks.c **** 		{
2232:Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
2233:Source/tasks.c **** 			eReturn = eAbortSleep;
2234:Source/tasks.c **** 		}
2235:Source/tasks.c **** 		else
2236:Source/tasks.c **** 		{
2237:Source/tasks.c **** 			#if configUSE_TIMERS == 0
2238:Source/tasks.c **** 			{
2239:Source/tasks.c **** 				/* The idle task exists in addition to the application tasks. */
2240:Source/tasks.c **** 				const unsigned portBASE_TYPE uxNonApplicationTasks = 1;
2241:Source/tasks.c **** 
2242:Source/tasks.c **** 				/* If timers are not being used and all the tasks are in the
2243:Source/tasks.c **** 				suspended list (which might mean they have an infinite block
2244:Source/tasks.c **** 				time rather than actually being suspended) then it is safe to
2245:Source/tasks.c **** 				turn all clocks off and just wait for external interrupts. */
2246:Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicati
2247:Source/tasks.c **** 				{
2248:Source/tasks.c **** 					eReturn = eNoTasksWaitingTimeout;
2249:Source/tasks.c **** 				}
2250:Source/tasks.c **** 			}
2251:Source/tasks.c **** 			#endif /* configUSE_TIMERS */
2252:Source/tasks.c **** 		}
2253:Source/tasks.c **** 
2254:Source/tasks.c **** 		return eReturn;
2255:Source/tasks.c **** 	}
2256:Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2257:Source/tasks.c **** /*-----------------------------------------------------------*/
2258:Source/tasks.c **** 
2259:Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
2260:Source/tasks.c **** {
 3141              		.loc 1 2260 0
 3142              		.cfi_startproc
 3143              		@ args = 4, pretend = 0, frame = 24
 3144              		@ frame_needed = 1, uses_anonymous_args = 0
 3145 0000 80B5     		push	{r7, lr}
 3146              	.LCFI83:
 3147              		.cfi_def_cfa_offset 8
 3148              		.cfi_offset 7, -8
 3149              		.cfi_offset 14, -4
 3150 0002 86B0     		sub	sp, sp, #24
 3151              	.LCFI84:
 3152              		.cfi_def_cfa_offset 32
 3153 0004 00AF     		add	r7, sp, #0
 3154              	.LCFI85:
 3155              		.cfi_def_cfa_register 7
 3156 0006 F860     		str	r0, [r7, #12]
 3157 0008 B960     		str	r1, [r7, #8]
 3158 000a 7A60     		str	r2, [r7, #4]
 3159 000c 3B60     		str	r3, [r7, #0]
2261:Source/tasks.c **** unsigned portBASE_TYPE x;
2262:Source/tasks.c **** 
2263:Source/tasks.c **** 	/* Store the task name in the TCB. */
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3160              		.loc 1 2264 0
 3161 000e 4FF00003 		mov	r3, #0
 3162 0012 7B61     		str	r3, [r7, #20]
 3163 0014 13E0     		b	.L184
 3164              	.L187:
2265:Source/tasks.c **** 	{
2266:Source/tasks.c **** 		pxTCB->pcTaskName[ x ] = pcName[ x ];
 3165              		.loc 1 2266 0
 3166 0016 BA68     		ldr	r2, [r7, #8]
 3167 0018 7B69     		ldr	r3, [r7, #20]
 3168 001a D318     		adds	r3, r2, r3
 3169 001c 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 3170 001e F968     		ldr	r1, [r7, #12]
 3171 0020 7B69     		ldr	r3, [r7, #20]
 3172 0022 CB18     		adds	r3, r1, r3
 3173 0024 03F13003 		add	r3, r3, #48
 3174 0028 1A71     		strb	r2, [r3, #4]
2267:Source/tasks.c **** 
2268:Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2269:Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
2270:Source/tasks.c **** 		string is not accessible (extremely unlikely). */
2271:Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 3175              		.loc 1 2271 0
 3176 002a BA68     		ldr	r2, [r7, #8]
 3177 002c 7B69     		ldr	r3, [r7, #20]
 3178 002e D318     		adds	r3, r2, r3
 3179 0030 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3180 0032 002B     		cmp	r3, #0
 3181 0034 07D0     		beq	.L189
 3182              	.L185:
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3183              		.loc 1 2264 0
 3184 0036 7B69     		ldr	r3, [r7, #20]
 3185 0038 03F10103 		add	r3, r3, #1
 3186 003c 7B61     		str	r3, [r7, #20]
 3187              	.L184:
2264:Source/tasks.c **** 	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++
 3188              		.loc 1 2264 0 is_stmt 0 discriminator 1
 3189 003e 7B69     		ldr	r3, [r7, #20]
 3190 0040 092B     		cmp	r3, #9
 3191 0042 E8D9     		bls	.L187
 3192 0044 00E0     		b	.L186
 3193              	.L189:
2272:Source/tasks.c **** 		{
2273:Source/tasks.c **** 			break;
 3194              		.loc 1 2273 0 is_stmt 1
 3195 0046 00BF     		nop
 3196              	.L186:
2274:Source/tasks.c **** 		}
2275:Source/tasks.c **** 	}
2276:Source/tasks.c **** 
2277:Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
2278:Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
2279:Source/tasks.c **** 	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 3197              		.loc 1 2279 0
 3198 0048 FB68     		ldr	r3, [r7, #12]
 3199 004a 4FF00002 		mov	r2, #0
 3200 004e 83F83D20 		strb	r2, [r3, #61]
2280:Source/tasks.c **** 
2281:Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
2282:Source/tasks.c **** 	remove the privilege bit if one is present. */
2283:Source/tasks.c **** 	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
 3201              		.loc 1 2283 0
 3202 0052 7B68     		ldr	r3, [r7, #4]
 3203 0054 042B     		cmp	r3, #4
 3204 0056 02D9     		bls	.L188
2284:Source/tasks.c **** 	{
2285:Source/tasks.c **** 		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 3205              		.loc 1 2285 0
 3206 0058 4FF00403 		mov	r3, #4
 3207 005c 7B60     		str	r3, [r7, #4]
 3208              	.L188:
2286:Source/tasks.c **** 	}
2287:Source/tasks.c **** 
2288:Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3209              		.loc 1 2288 0
 3210 005e FB68     		ldr	r3, [r7, #12]
 3211 0060 7A68     		ldr	r2, [r7, #4]
 3212 0062 DA62     		str	r2, [r3, #44]
2289:Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2290:Source/tasks.c **** 	{
2291:Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3213              		.loc 1 2291 0
 3214 0064 FB68     		ldr	r3, [r7, #12]
 3215 0066 7A68     		ldr	r2, [r7, #4]
 3216 0068 9A64     		str	r2, [r3, #72]
2292:Source/tasks.c **** 	}
2293:Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
2294:Source/tasks.c **** 
2295:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3217              		.loc 1 2295 0
 3218 006a FB68     		ldr	r3, [r7, #12]
 3219 006c 03F10403 		add	r3, r3, #4
 3220 0070 1846     		mov	r0, r3
 3221 0072 FFF7FEFF 		bl	vListInitialiseItem
2296:Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3222              		.loc 1 2296 0
 3223 0076 FB68     		ldr	r3, [r7, #12]
 3224 0078 03F11803 		add	r3, r3, #24
 3225 007c 1846     		mov	r0, r3
 3226 007e FFF7FEFF 		bl	vListInitialiseItem
2297:Source/tasks.c **** 
2298:Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2299:Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2300:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3227              		.loc 1 2300 0
 3228 0082 FB68     		ldr	r3, [r7, #12]
 3229 0084 FA68     		ldr	r2, [r7, #12]
 3230 0086 1A61     		str	r2, [r3, #16]
2301:Source/tasks.c **** 
2302:Source/tasks.c **** 	/* Event lists are always in priority order. */
2303:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( por
 3231              		.loc 1 2303 0
 3232 0088 7B68     		ldr	r3, [r7, #4]
 3233 008a C3F10502 		rsb	r2, r3, #5
 3234 008e FB68     		ldr	r3, [r7, #12]
 3235 0090 9A61     		str	r2, [r3, #24]
2304:Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3236              		.loc 1 2304 0
 3237 0092 FB68     		ldr	r3, [r7, #12]
 3238 0094 FA68     		ldr	r2, [r7, #12]
 3239 0096 5A62     		str	r2, [r3, #36]
2305:Source/tasks.c **** 
2306:Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2307:Source/tasks.c **** 	{
2308:Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2309:Source/tasks.c **** 	}
2310:Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
2311:Source/tasks.c **** 
2312:Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2313:Source/tasks.c **** 	{
2314:Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2315:Source/tasks.c **** 	}
2316:Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
2317:Source/tasks.c **** 
2318:Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2319:Source/tasks.c **** 	{
2320:Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2321:Source/tasks.c **** 	}
2322:Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
2323:Source/tasks.c **** 
2324:Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2325:Source/tasks.c **** 	{
2326:Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2327:Source/tasks.c **** 	}
2328:Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
2329:Source/tasks.c **** 	{
2330:Source/tasks.c **** 		( void ) xRegions;
2331:Source/tasks.c **** 		( void ) usStackDepth;
2332:Source/tasks.c **** 	}
2333:Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
2334:Source/tasks.c **** 
2335:Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2336:Source/tasks.c **** 	{
2337:Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
2338:Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2339:Source/tasks.c **** 	}
2340:Source/tasks.c **** 	#endif /* configUSE_NEWLIB_REENTRANT */
2341:Source/tasks.c **** }
 3240              		.loc 1 2341 0
 3241 0098 07F11807 		add	r7, r7, #24
 3242 009c BD46     		mov	sp, r7
 3243 009e 80BD     		pop	{r7, pc}
 3244              		.cfi_endproc
 3245              	.LFE139:
 3247              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3248              		.align	2
 3249              		.thumb
 3250              		.thumb_func
 3252              	prvInitialiseTaskLists:
 3253              	.LFB140:
2342:Source/tasks.c **** /*-----------------------------------------------------------*/
2343:Source/tasks.c **** 
2344:Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2345:Source/tasks.c **** 
2346:Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2347:Source/tasks.c **** 	{
2348:Source/tasks.c **** 	tskTCB *pxTCB;
2349:Source/tasks.c **** 
2350:Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2351:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2352:Source/tasks.c **** 
2353:Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2354:Source/tasks.c **** 	}
2355:Source/tasks.c **** 
2356:Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
2357:Source/tasks.c **** /*-----------------------------------------------------------*/
2358:Source/tasks.c **** 
2359:Source/tasks.c **** static void prvInitialiseTaskLists( void )
2360:Source/tasks.c **** {
 3254              		.loc 1 2360 0
 3255              		.cfi_startproc
 3256              		@ args = 0, pretend = 0, frame = 8
 3257              		@ frame_needed = 1, uses_anonymous_args = 0
 3258 0000 80B5     		push	{r7, lr}
 3259              	.LCFI86:
 3260              		.cfi_def_cfa_offset 8
 3261              		.cfi_offset 7, -8
 3262              		.cfi_offset 14, -4
 3263 0002 82B0     		sub	sp, sp, #8
 3264              	.LCFI87:
 3265              		.cfi_def_cfa_offset 16
 3266 0004 00AF     		add	r7, sp, #0
 3267              	.LCFI88:
 3268              		.cfi_def_cfa_register 7
2361:Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2362:Source/tasks.c **** 
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3269              		.loc 1 2363 0
 3270 0006 4FF00003 		mov	r3, #0
 3271 000a 7B60     		str	r3, [r7, #4]
 3272 000c 12E0     		b	.L191
 3273              	.L192:
2364:Source/tasks.c **** 	{
2365:Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3274              		.loc 1 2365 0 discriminator 2
 3275 000e 7A68     		ldr	r2, [r7, #4]
 3276 0010 1346     		mov	r3, r2
 3277 0012 4FEA8303 		lsl	r3, r3, #2
 3278 0016 9B18     		adds	r3, r3, r2
 3279 0018 4FEA8303 		lsl	r3, r3, #2
 3280 001c 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 3281 0020 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 3282 0024 9B18     		adds	r3, r3, r2
 3283 0026 1846     		mov	r0, r3
 3284 0028 FFF7FEFF 		bl	vListInitialise
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3285              		.loc 1 2363 0 discriminator 2
 3286 002c 7B68     		ldr	r3, [r7, #4]
 3287 002e 03F10103 		add	r3, r3, #1
 3288 0032 7B60     		str	r3, [r7, #4]
 3289              	.L191:
2363:Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX
 3290              		.loc 1 2363 0 is_stmt 0 discriminator 1
 3291 0034 7B68     		ldr	r3, [r7, #4]
 3292 0036 042B     		cmp	r3, #4
 3293 0038 E9D9     		bls	.L192
2366:Source/tasks.c **** 	}
2367:Source/tasks.c **** 
2368:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3294              		.loc 1 2368 0 is_stmt 1
 3295 003a 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 3296 003e C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 3297 0042 FFF7FEFF 		bl	vListInitialise
2369:Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3298              		.loc 1 2369 0
 3299 0046 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 3300 004a C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 3301 004e FFF7FEFF 		bl	vListInitialise
2370:Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3302              		.loc 1 2370 0
 3303 0052 40F20000 		movw	r0, #:lower16:xPendingReadyList
 3304 0056 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 3305 005a FFF7FEFF 		bl	vListInitialise
2371:Source/tasks.c **** 
2372:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2373:Source/tasks.c **** 	{
2374:Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3306              		.loc 1 2374 0
 3307 005e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 3308 0062 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 3309 0066 FFF7FEFF 		bl	vListInitialise
2375:Source/tasks.c **** 	}
2376:Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
2377:Source/tasks.c **** 
2378:Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2379:Source/tasks.c **** 	{
2380:Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3310              		.loc 1 2380 0
 3311 006a 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 3312 006e C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 3313 0072 FFF7FEFF 		bl	vListInitialise
2381:Source/tasks.c **** 	}
2382:Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
2383:Source/tasks.c **** 
2384:Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2385:Source/tasks.c **** 	using list2. */
2386:Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3314              		.loc 1 2386 0
 3315 0076 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3316 007a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3317 007e 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 3318 0082 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 3319 0086 1A60     		str	r2, [r3, #0]
2387:Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3320              		.loc 1 2387 0
 3321 0088 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3322 008c C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3323 0090 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 3324 0094 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 3325 0098 1A60     		str	r2, [r3, #0]
2388:Source/tasks.c **** }
 3326              		.loc 1 2388 0
 3327 009a 07F10807 		add	r7, r7, #8
 3328 009e BD46     		mov	sp, r7
 3329 00a0 80BD     		pop	{r7, pc}
 3330              		.cfi_endproc
 3331              	.LFE140:
 3333 00a2 00BF     		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3334              		.align	2
 3335              		.thumb
 3336              		.thumb_func
 3338              	prvCheckTasksWaitingTermination:
 3339              	.LFB141:
2389:Source/tasks.c **** /*-----------------------------------------------------------*/
2390:Source/tasks.c **** 
2391:Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2392:Source/tasks.c **** {
 3340              		.loc 1 2392 0
 3341              		.cfi_startproc
 3342              		@ args = 0, pretend = 0, frame = 8
 3343              		@ frame_needed = 1, uses_anonymous_args = 0
 3344 0000 80B5     		push	{r7, lr}
 3345              	.LCFI89:
 3346              		.cfi_def_cfa_offset 8
 3347              		.cfi_offset 7, -8
 3348              		.cfi_offset 14, -4
 3349 0002 82B0     		sub	sp, sp, #8
 3350              	.LCFI90:
 3351              		.cfi_def_cfa_offset 16
 3352 0004 00AF     		add	r7, sp, #0
 3353              	.LCFI91:
 3354              		.cfi_def_cfa_register 7
 3355              	.LBB10:
2393:Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2394:Source/tasks.c **** 	{
2395:Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2396:Source/tasks.c **** 
2397:Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2398:Source/tasks.c **** 		too often in the idle task. */
2399:Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3356              		.loc 1 2399 0
 3357 0006 3DE0     		b	.L194
 3358              	.L195:
2400:Source/tasks.c **** 		{
2401:Source/tasks.c **** 			vTaskSuspendAll();
 3359              		.loc 1 2401 0
 3360 0008 FFF7FEFF 		bl	vTaskSuspendAll
2402:Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3361              		.loc 1 2402 0
 3362 000c 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3363 0010 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3364 0014 1B68     		ldr	r3, [r3, #0]
 3365 0016 002B     		cmp	r3, #0
 3366 0018 14BF     		ite	ne
 3367 001a 0023     		movne	r3, #0
 3368 001c 0123     		moveq	r3, #1
 3369 001e DBB2     		uxtb	r3, r3
 3370 0020 7B60     		str	r3, [r7, #4]
2403:Source/tasks.c **** 			( void ) xTaskResumeAll();
 3371              		.loc 1 2403 0
 3372 0022 FFF7FEFF 		bl	xTaskResumeAll
2404:Source/tasks.c **** 
2405:Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3373              		.loc 1 2405 0
 3374 0026 7B68     		ldr	r3, [r7, #4]
 3375 0028 002B     		cmp	r3, #0
 3376 002a 2BD1     		bne	.L194
 3377              	.LBB11:
2406:Source/tasks.c **** 			{
2407:Source/tasks.c **** 				tskTCB *pxTCB;
2408:Source/tasks.c **** 
2409:Source/tasks.c **** 				taskENTER_CRITICAL();
 3378              		.loc 1 2409 0
 3379 002c FFF7FEFF 		bl	vPortEnterCritical
2410:Source/tasks.c **** 				{
2411:Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 3380              		.loc 1 2411 0
 3381 0030 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 3382 0034 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 3383 0038 DB68     		ldr	r3, [r3, #12]
 3384 003a DB68     		ldr	r3, [r3, #12]
 3385 003c 3B60     		str	r3, [r7, #0]
2412:Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 3386              		.loc 1 2412 0
 3387 003e 3B68     		ldr	r3, [r7, #0]
 3388 0040 03F10403 		add	r3, r3, #4
 3389 0044 1846     		mov	r0, r3
 3390 0046 FFF7FEFF 		bl	uxListRemove
2413:Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3391              		.loc 1 2413 0
 3392 004a 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3393 004e C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3394 0052 1B68     		ldr	r3, [r3, #0]
 3395 0054 03F1FF32 		add	r2, r3, #-1
 3396 0058 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3397 005c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3398 0060 1A60     		str	r2, [r3, #0]
2414:Source/tasks.c **** 					--uxTasksDeleted;
 3399              		.loc 1 2414 0
 3400 0062 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3401 0066 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3402 006a 1B68     		ldr	r3, [r3, #0]
 3403 006c 03F1FF32 		add	r2, r3, #-1
 3404 0070 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3405 0074 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3406 0078 1A60     		str	r2, [r3, #0]
2415:Source/tasks.c **** 				}
2416:Source/tasks.c **** 				taskEXIT_CRITICAL();
 3407              		.loc 1 2416 0
 3408 007a FFF7FEFF 		bl	vPortExitCritical
2417:Source/tasks.c **** 
2418:Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3409              		.loc 1 2418 0
 3410 007e 3868     		ldr	r0, [r7, #0]
 3411 0080 FFF7FEFF 		bl	prvDeleteTCB
 3412              	.L194:
 3413              	.LBE11:
2399:Source/tasks.c **** 		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3414              		.loc 1 2399 0 discriminator 1
 3415 0084 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 3416 0088 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 3417 008c 1B68     		ldr	r3, [r3, #0]
 3418 008e 002B     		cmp	r3, #0
 3419 0090 BAD1     		bne	.L195
 3420              	.LBE10:
2419:Source/tasks.c **** 			}
2420:Source/tasks.c **** 		}
2421:Source/tasks.c **** 	}
2422:Source/tasks.c **** 	#endif /* vTaskDelete */
2423:Source/tasks.c **** }
 3421              		.loc 1 2423 0
 3422 0092 07F10807 		add	r7, r7, #8
 3423 0096 BD46     		mov	sp, r7
 3424 0098 80BD     		pop	{r7, pc}
 3425              		.cfi_endproc
 3426              	.LFE141:
 3428 009a 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3429              		.align	2
 3430              		.thumb
 3431              		.thumb_func
 3433              	prvAddCurrentTaskToDelayedList:
 3434              	.LFB142:
2424:Source/tasks.c **** /*-----------------------------------------------------------*/
2425:Source/tasks.c **** 
2426:Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2427:Source/tasks.c **** {
 3435              		.loc 1 2427 0
 3436              		.cfi_startproc
 3437              		@ args = 0, pretend = 0, frame = 8
 3438              		@ frame_needed = 1, uses_anonymous_args = 0
 3439 0000 80B5     		push	{r7, lr}
 3440              	.LCFI92:
 3441              		.cfi_def_cfa_offset 8
 3442              		.cfi_offset 7, -8
 3443              		.cfi_offset 14, -4
 3444 0002 82B0     		sub	sp, sp, #8
 3445              	.LCFI93:
 3446              		.cfi_def_cfa_offset 16
 3447 0004 00AF     		add	r7, sp, #0
 3448              	.LCFI94:
 3449              		.cfi_def_cfa_register 7
 3450 0006 7860     		str	r0, [r7, #4]
2428:Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2429:Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3451              		.loc 1 2429 0
 3452 0008 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3453 000c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3454 0010 1B68     		ldr	r3, [r3, #0]
 3455 0012 7A68     		ldr	r2, [r7, #4]
 3456 0014 5A60     		str	r2, [r3, #4]
2430:Source/tasks.c **** 
2431:Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3457              		.loc 1 2431 0
 3458 0016 40F20003 		movw	r3, #:lower16:xTickCount
 3459 001a C0F20003 		movt	r3, #:upper16:xTickCount
 3460 001e 1B68     		ldr	r3, [r3, #0]
 3461 0020 7A68     		ldr	r2, [r7, #4]
 3462 0022 9A42     		cmp	r2, r3
 3463 0024 10D2     		bcs	.L197
2432:Source/tasks.c **** 	{
2433:Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2434:Source/tasks.c **** 		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3464              		.loc 1 2434 0
 3465 0026 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 3466 002a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 3467 002e 1A68     		ldr	r2, [r3, #0]
 3468 0030 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3469 0034 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3470 0038 1B68     		ldr	r3, [r3, #0]
 3471 003a 03F10403 		add	r3, r3, #4
 3472 003e 1046     		mov	r0, r2
 3473 0040 1946     		mov	r1, r3
 3474 0042 FFF7FEFF 		bl	vListInsert
 3475 0046 1DE0     		b	.L196
 3476              	.L197:
2435:Source/tasks.c **** 	}
2436:Source/tasks.c **** 	else
2437:Source/tasks.c **** 	{
2438:Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2439:Source/tasks.c **** 		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 3477              		.loc 1 2439 0
 3478 0048 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 3479 004c C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 3480 0050 1A68     		ldr	r2, [r3, #0]
 3481 0052 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3482 0056 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3483 005a 1B68     		ldr	r3, [r3, #0]
 3484 005c 03F10403 		add	r3, r3, #4
 3485 0060 1046     		mov	r0, r2
 3486 0062 1946     		mov	r1, r3
 3487 0064 FFF7FEFF 		bl	vListInsert
2440:Source/tasks.c **** 
2441:Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2442:Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2443:Source/tasks.c **** 		too. */
2444:Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3488              		.loc 1 2444 0
 3489 0068 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3490 006c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3491 0070 1B68     		ldr	r3, [r3, #0]
 3492 0072 7A68     		ldr	r2, [r7, #4]
 3493 0074 9A42     		cmp	r2, r3
 3494 0076 05D2     		bcs	.L196
2445:Source/tasks.c **** 		{
2446:Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3495              		.loc 1 2446 0
 3496 0078 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 3497 007c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 3498 0080 7A68     		ldr	r2, [r7, #4]
 3499 0082 1A60     		str	r2, [r3, #0]
 3500              	.L196:
2447:Source/tasks.c **** 		}
2448:Source/tasks.c **** 	}
2449:Source/tasks.c **** }
 3501              		.loc 1 2449 0
 3502 0084 07F10807 		add	r7, r7, #8
 3503 0088 BD46     		mov	sp, r7
 3504 008a 80BD     		pop	{r7, pc}
 3505              		.cfi_endproc
 3506              	.LFE142:
 3508              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3509              		.align	2
 3510              		.thumb
 3511              		.thumb_func
 3513              	prvAllocateTCBAndStack:
 3514              	.LFB143:
2450:Source/tasks.c **** /*-----------------------------------------------------------*/
2451:Source/tasks.c **** 
2452:Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2453:Source/tasks.c **** {
 3515              		.loc 1 2453 0
 3516              		.cfi_startproc
 3517              		@ args = 0, pretend = 0, frame = 16
 3518              		@ frame_needed = 1, uses_anonymous_args = 0
 3519 0000 80B5     		push	{r7, lr}
 3520              	.LCFI95:
 3521              		.cfi_def_cfa_offset 8
 3522              		.cfi_offset 7, -8
 3523              		.cfi_offset 14, -4
 3524 0002 84B0     		sub	sp, sp, #16
 3525              	.LCFI96:
 3526              		.cfi_def_cfa_offset 24
 3527 0004 00AF     		add	r7, sp, #0
 3528              	.LCFI97:
 3529              		.cfi_def_cfa_register 7
 3530 0006 0346     		mov	r3, r0
 3531 0008 3960     		str	r1, [r7, #0]
 3532 000a FB80     		strh	r3, [r7, #6]	@ movhi
2454:Source/tasks.c **** tskTCB *pxNewTCB;
2455:Source/tasks.c **** 
2456:Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2457:Source/tasks.c **** 	the implementation of the port malloc function. */
2458:Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3533              		.loc 1 2458 0
 3534 000c 4FF04C00 		mov	r0, #76
 3535 0010 FFF7FEFF 		bl	pvPortMalloc
 3536 0014 F860     		str	r0, [r7, #12]
2459:Source/tasks.c **** 
2460:Source/tasks.c **** 	if( pxNewTCB != NULL )
 3537              		.loc 1 2460 0
 3538 0016 FB68     		ldr	r3, [r7, #12]
 3539 0018 002B     		cmp	r3, #0
 3540 001a 23D0     		beq	.L200
2461:Source/tasks.c **** 	{
2462:Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2463:Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2464:Source/tasks.c **** 		be deleted later if required. */
2465:Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * siz
 3541              		.loc 1 2465 0
 3542 001c 3B68     		ldr	r3, [r7, #0]
 3543 001e 002B     		cmp	r3, #0
 3544 0020 07D1     		bne	.L201
 3545              		.loc 1 2465 0 is_stmt 0 discriminator 1
 3546 0022 FB88     		ldrh	r3, [r7, #6]
 3547 0024 4FEA8303 		lsl	r3, r3, #2
 3548 0028 1846     		mov	r0, r3
 3549 002a FFF7FEFF 		bl	pvPortMalloc
 3550 002e 0346     		mov	r3, r0
 3551 0030 00E0     		b	.L202
 3552              	.L201:
 3553              		.loc 1 2465 0 discriminator 2
 3554 0032 3B68     		ldr	r3, [r7, #0]
 3555              	.L202:
 3556              		.loc 1 2465 0 discriminator 3
 3557 0034 FA68     		ldr	r2, [r7, #12]
 3558 0036 1363     		str	r3, [r2, #48]
2466:Source/tasks.c **** 
2467:Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3559              		.loc 1 2467 0 is_stmt 1 discriminator 3
 3560 0038 FB68     		ldr	r3, [r7, #12]
 3561 003a 1B6B     		ldr	r3, [r3, #48]
 3562 003c 002B     		cmp	r3, #0
 3563 003e 06D1     		bne	.L203
2468:Source/tasks.c **** 		{
2469:Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2470:Source/tasks.c **** 			vPortFree( pxNewTCB );
 3564              		.loc 1 2470 0
 3565 0040 F868     		ldr	r0, [r7, #12]
 3566 0042 FFF7FEFF 		bl	vPortFree
2471:Source/tasks.c **** 			pxNewTCB = NULL;
 3567              		.loc 1 2471 0
 3568 0046 4FF00003 		mov	r3, #0
 3569 004a FB60     		str	r3, [r7, #12]
 3570 004c 0AE0     		b	.L200
 3571              	.L203:
2472:Source/tasks.c **** 		}
2473:Source/tasks.c **** 		else
2474:Source/tasks.c **** 		{
2475:Source/tasks.c **** 			/* Just to help debugging. */
2476:Source/tasks.c **** 			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof
 3572              		.loc 1 2476 0
 3573 004e FB68     		ldr	r3, [r7, #12]
 3574 0050 1A6B     		ldr	r2, [r3, #48]
 3575 0052 FB88     		ldrh	r3, [r7, #6]
 3576 0054 4FEA8303 		lsl	r3, r3, #2
 3577 0058 1046     		mov	r0, r2
 3578 005a 4FF0A501 		mov	r1, #165
 3579 005e 1A46     		mov	r2, r3
 3580 0060 FFF7FEFF 		bl	memset
 3581              	.L200:
2477:Source/tasks.c **** 		}
2478:Source/tasks.c **** 	}
2479:Source/tasks.c **** 
2480:Source/tasks.c **** 	return pxNewTCB;
 3582              		.loc 1 2480 0
 3583 0064 FB68     		ldr	r3, [r7, #12]
2481:Source/tasks.c **** }
 3584              		.loc 1 2481 0
 3585 0066 1846     		mov	r0, r3
 3586 0068 07F11007 		add	r7, r7, #16
 3587 006c BD46     		mov	sp, r7
 3588 006e 80BD     		pop	{r7, pc}
 3589              		.cfi_endproc
 3590              	.LFE143:
 3592              		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
 3593              		.align	2
 3594              		.thumb
 3595              		.thumb_func
 3597              	prvListTaskWithinSingleList:
 3598              	.LFB144:
2482:Source/tasks.c **** /*-----------------------------------------------------------*/
2483:Source/tasks.c **** 
2484:Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2485:Source/tasks.c **** 
2486:Source/tasks.c **** 	static unsigned portBASE_TYPE prvListTaskWithinSingleList( xTaskStatusType *pxTaskStatusArray, xLi
2487:Source/tasks.c **** 	{
 3599              		.loc 1 2487 0
 3600              		.cfi_startproc
 3601              		@ args = 0, pretend = 0, frame = 40
 3602              		@ frame_needed = 1, uses_anonymous_args = 0
 3603 0000 90B5     		push	{r4, r7, lr}
 3604              	.LCFI98:
 3605              		.cfi_def_cfa_offset 12
 3606              		.cfi_offset 4, -12
 3607              		.cfi_offset 7, -8
 3608              		.cfi_offset 14, -4
 3609 0002 8BB0     		sub	sp, sp, #44
 3610              	.LCFI99:
 3611              		.cfi_def_cfa_offset 56
 3612 0004 00AF     		add	r7, sp, #0
 3613              	.LCFI100:
 3614              		.cfi_def_cfa_register 7
 3615 0006 F860     		str	r0, [r7, #12]
 3616 0008 B960     		str	r1, [r7, #8]
 3617 000a 1346     		mov	r3, r2
 3618 000c FB71     		strb	r3, [r7, #7]
2488:Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2489:Source/tasks.c **** 	unsigned portBASE_TYPE uxTask = 0;
 3619              		.loc 1 2489 0
 3620 000e 4FF00003 		mov	r3, #0
 3621 0012 7B62     		str	r3, [r7, #36]
2490:Source/tasks.c **** 
2491:Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( unsigned portBASE_TYPE ) 0 )
 3622              		.loc 1 2491 0
 3623 0014 BB68     		ldr	r3, [r7, #8]
 3624 0016 1B68     		ldr	r3, [r3, #0]
 3625 0018 002B     		cmp	r3, #0
 3626 001a 78D0     		beq	.L206
 3627              	.LBB12:
2492:Source/tasks.c **** 		{
2493:Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3628              		.loc 1 2493 0
 3629 001c BB68     		ldr	r3, [r7, #8]
 3630 001e 3B62     		str	r3, [r7, #32]
 3631 0020 3B6A     		ldr	r3, [r7, #32]
 3632 0022 5B68     		ldr	r3, [r3, #4]
 3633 0024 5A68     		ldr	r2, [r3, #4]
 3634 0026 3B6A     		ldr	r3, [r7, #32]
 3635 0028 5A60     		str	r2, [r3, #4]
 3636 002a 3B6A     		ldr	r3, [r7, #32]
 3637 002c 5A68     		ldr	r2, [r3, #4]
 3638 002e 3B6A     		ldr	r3, [r7, #32]
 3639 0030 03F10803 		add	r3, r3, #8
 3640 0034 9A42     		cmp	r2, r3
 3641 0036 04D1     		bne	.L207
 3642              		.loc 1 2493 0 is_stmt 0 discriminator 1
 3643 0038 3B6A     		ldr	r3, [r7, #32]
 3644 003a 5B68     		ldr	r3, [r3, #4]
 3645 003c 5A68     		ldr	r2, [r3, #4]
 3646 003e 3B6A     		ldr	r3, [r7, #32]
 3647 0040 5A60     		str	r2, [r3, #4]
 3648              	.L207:
 3649              		.loc 1 2493 0 discriminator 2
 3650 0042 3B6A     		ldr	r3, [r7, #32]
 3651 0044 5B68     		ldr	r3, [r3, #4]
 3652 0046 DB68     		ldr	r3, [r3, #12]
 3653 0048 FB61     		str	r3, [r7, #28]
 3654              	.L209:
 3655              	.LBE12:
 3656              	.LBB13:
2494:Source/tasks.c **** 
2495:Source/tasks.c **** 			/* Populate an xTaskStatusType structure within the
2496:Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
2497:Source/tasks.c **** 			pxList.  See the definition of xTaskStatusType in task.h for the
2498:Source/tasks.c **** 			meaning of each xTaskStatusType structure member. */
2499:Source/tasks.c **** 			do
2500:Source/tasks.c **** 			{
2501:Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3657              		.loc 1 2501 0 is_stmt 1
 3658 004a BB68     		ldr	r3, [r7, #8]
 3659 004c BB61     		str	r3, [r7, #24]
 3660 004e BB69     		ldr	r3, [r7, #24]
 3661 0050 5B68     		ldr	r3, [r3, #4]
 3662 0052 5A68     		ldr	r2, [r3, #4]
 3663 0054 BB69     		ldr	r3, [r7, #24]
 3664 0056 5A60     		str	r2, [r3, #4]
 3665 0058 BB69     		ldr	r3, [r7, #24]
 3666 005a 5A68     		ldr	r2, [r3, #4]
 3667 005c BB69     		ldr	r3, [r7, #24]
 3668 005e 03F10803 		add	r3, r3, #8
 3669 0062 9A42     		cmp	r2, r3
 3670 0064 04D1     		bne	.L208
 3671              		.loc 1 2501 0 is_stmt 0 discriminator 1
 3672 0066 BB69     		ldr	r3, [r7, #24]
 3673 0068 5B68     		ldr	r3, [r3, #4]
 3674 006a 5A68     		ldr	r2, [r3, #4]
 3675 006c BB69     		ldr	r3, [r7, #24]
 3676 006e 5A60     		str	r2, [r3, #4]
 3677              	.L208:
 3678              		.loc 1 2501 0 discriminator 2
 3679 0070 BB69     		ldr	r3, [r7, #24]
 3680 0072 5B68     		ldr	r3, [r3, #4]
 3681 0074 DB68     		ldr	r3, [r3, #12]
 3682 0076 7B61     		str	r3, [r7, #20]
 3683              	.LBE13:
2502:Source/tasks.c **** 
2503:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xHandle = ( xTaskHandle ) pxNextTCB;
 3684              		.loc 1 2503 0 is_stmt 1 discriminator 2
 3685 0078 7B6A     		ldr	r3, [r7, #36]
 3686 007a 4FEA4313 		lsl	r3, r3, #5
 3687 007e FA68     		ldr	r2, [r7, #12]
 3688 0080 D318     		adds	r3, r2, r3
 3689 0082 7A69     		ldr	r2, [r7, #20]
 3690 0084 1A60     		str	r2, [r3, #0]
2504:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].pcTaskName = ( const signed char * ) &( pxNextTCB->pcTaskName [ 0 ]
 3691              		.loc 1 2504 0 discriminator 2
 3692 0086 7B6A     		ldr	r3, [r7, #36]
 3693 0088 4FEA4313 		lsl	r3, r3, #5
 3694 008c FA68     		ldr	r2, [r7, #12]
 3695 008e D318     		adds	r3, r2, r3
 3696 0090 7A69     		ldr	r2, [r7, #20]
 3697 0092 02F13402 		add	r2, r2, #52
 3698 0096 5A60     		str	r2, [r3, #4]
2505:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
 3699              		.loc 1 2505 0 discriminator 2
 3700 0098 7B6A     		ldr	r3, [r7, #36]
 3701 009a 4FEA4313 		lsl	r3, r3, #5
 3702 009e FA68     		ldr	r2, [r7, #12]
 3703 00a0 D318     		adds	r3, r2, r3
 3704 00a2 7A69     		ldr	r2, [r7, #20]
 3705 00a4 126C     		ldr	r2, [r2, #64]
 3706 00a6 9A60     		str	r2, [r3, #8]
2506:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
 3707              		.loc 1 2506 0 discriminator 2
 3708 00a8 7B6A     		ldr	r3, [r7, #36]
 3709 00aa 4FEA4313 		lsl	r3, r3, #5
 3710 00ae FA68     		ldr	r2, [r7, #12]
 3711 00b0 D318     		adds	r3, r2, r3
 3712 00b2 FA79     		ldrb	r2, [r7, #7]
 3713 00b4 1A73     		strb	r2, [r3, #12]
2507:Source/tasks.c **** 				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
 3714              		.loc 1 2507 0 discriminator 2
 3715 00b6 7B6A     		ldr	r3, [r7, #36]
 3716 00b8 4FEA4313 		lsl	r3, r3, #5
 3717 00bc FA68     		ldr	r2, [r7, #12]
 3718 00be D318     		adds	r3, r2, r3
 3719 00c0 7A69     		ldr	r2, [r7, #20]
 3720 00c2 D26A     		ldr	r2, [r2, #44]
 3721 00c4 1A61     		str	r2, [r3, #16]
2508:Source/tasks.c **** 
2509:Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
2510:Source/tasks.c **** 				{
2511:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
 3722              		.loc 1 2511 0 discriminator 2
 3723 00c6 7B6A     		ldr	r3, [r7, #36]
 3724 00c8 4FEA4313 		lsl	r3, r3, #5
 3725 00cc FA68     		ldr	r2, [r7, #12]
 3726 00ce D318     		adds	r3, r2, r3
 3727 00d0 7A69     		ldr	r2, [r7, #20]
 3728 00d2 926C     		ldr	r2, [r2, #72]
 3729 00d4 5A61     		str	r2, [r3, #20]
2512:Source/tasks.c **** 				}
2513:Source/tasks.c **** 				#else
2514:Source/tasks.c **** 				{
2515:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2516:Source/tasks.c **** 				}
2517:Source/tasks.c **** 				#endif
2518:Source/tasks.c **** 
2519:Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2520:Source/tasks.c **** 				{
2521:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2522:Source/tasks.c **** 				}
2523:Source/tasks.c **** 				#else
2524:Source/tasks.c **** 				{
2525:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
 3730              		.loc 1 2525 0 discriminator 2
 3731 00d6 7B6A     		ldr	r3, [r7, #36]
 3732 00d8 4FEA4313 		lsl	r3, r3, #5
 3733 00dc FA68     		ldr	r2, [r7, #12]
 3734 00de D318     		adds	r3, r2, r3
 3735 00e0 4FF00002 		mov	r2, #0
 3736 00e4 9A61     		str	r2, [r3, #24]
2526:Source/tasks.c **** 				}
2527:Source/tasks.c **** 				#endif
2528:Source/tasks.c **** 
2529:Source/tasks.c **** 				#if ( portSTACK_GROWTH > 0 )
2530:Source/tasks.c **** 				{
2531:Source/tasks.c **** 					ppxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned cha
2532:Source/tasks.c **** 				}
2533:Source/tasks.c **** 				#else
2534:Source/tasks.c **** 				{
2535:Source/tasks.c **** 					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( unsigned char
 3737              		.loc 1 2535 0 discriminator 2
 3738 00e6 7B6A     		ldr	r3, [r7, #36]
 3739 00e8 4FEA4313 		lsl	r3, r3, #5
 3740 00ec FA68     		ldr	r2, [r7, #12]
 3741 00ee D418     		adds	r4, r2, r3
 3742 00f0 7B69     		ldr	r3, [r7, #20]
 3743 00f2 1B6B     		ldr	r3, [r3, #48]
 3744 00f4 1846     		mov	r0, r3
 3745 00f6 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 3746 00fa 0346     		mov	r3, r0
 3747 00fc A383     		strh	r3, [r4, #28]	@ movhi
2536:Source/tasks.c **** 				}
2537:Source/tasks.c **** 				#endif
2538:Source/tasks.c **** 
2539:Source/tasks.c **** 				uxTask++;
 3748              		.loc 1 2539 0 discriminator 2
 3749 00fe 7B6A     		ldr	r3, [r7, #36]
 3750 0100 03F10103 		add	r3, r3, #1
 3751 0104 7B62     		str	r3, [r7, #36]
2540:Source/tasks.c **** 
2541:Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
 3752              		.loc 1 2541 0 discriminator 2
 3753 0106 7A69     		ldr	r2, [r7, #20]
 3754 0108 FB69     		ldr	r3, [r7, #28]
 3755 010a 9A42     		cmp	r2, r3
 3756 010c 9DD1     		bne	.L209
 3757              	.L206:
2542:Source/tasks.c **** 		}
2543:Source/tasks.c **** 
2544:Source/tasks.c **** 		return uxTask;
 3758              		.loc 1 2544 0
 3759 010e 7B6A     		ldr	r3, [r7, #36]
2545:Source/tasks.c **** 	}
 3760              		.loc 1 2545 0
 3761 0110 1846     		mov	r0, r3
 3762 0112 07F12C07 		add	r7, r7, #44
 3763 0116 BD46     		mov	sp, r7
 3764 0118 90BD     		pop	{r4, r7, pc}
 3765              		.cfi_endproc
 3766              	.LFE144:
 3768 011a 00BF     		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 3769              		.align	2
 3770              		.thumb
 3771              		.thumb_func
 3773              	prvTaskCheckFreeStackSpace:
 3774              	.LFB145:
2546:Source/tasks.c **** 
2547:Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2548:Source/tasks.c **** /*-----------------------------------------------------------*/
2549:Source/tasks.c **** 
2550:Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2551:Source/tasks.c **** 
2552:Source/tasks.c **** 	static unsigned short prvTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2553:Source/tasks.c **** 	{
 3775              		.loc 1 2553 0
 3776              		.cfi_startproc
 3777              		@ args = 0, pretend = 0, frame = 16
 3778              		@ frame_needed = 1, uses_anonymous_args = 0
 3779              		@ link register save eliminated.
 3780 0000 80B4     		push	{r7}
 3781              	.LCFI101:
 3782              		.cfi_def_cfa_offset 4
 3783              		.cfi_offset 7, -4
 3784 0002 85B0     		sub	sp, sp, #20
 3785              	.LCFI102:
 3786              		.cfi_def_cfa_offset 24
 3787 0004 00AF     		add	r7, sp, #0
 3788              	.LCFI103:
 3789              		.cfi_def_cfa_register 7
 3790 0006 7860     		str	r0, [r7, #4]
2554:Source/tasks.c **** 	unsigned short usCount = 0U;
 3791              		.loc 1 2554 0
 3792 0008 4FF00003 		mov	r3, #0
 3793 000c FB81     		strh	r3, [r7, #14]	@ movhi
2555:Source/tasks.c **** 
2556:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3794              		.loc 1 2556 0
 3795 000e 07E0     		b	.L212
 3796              	.L213:
2557:Source/tasks.c **** 		{
2558:Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3797              		.loc 1 2558 0
 3798 0010 7B68     		ldr	r3, [r7, #4]
 3799 0012 03F10103 		add	r3, r3, #1
 3800 0016 7B60     		str	r3, [r7, #4]
2559:Source/tasks.c **** 			usCount++;
 3801              		.loc 1 2559 0
 3802 0018 FB89     		ldrh	r3, [r7, #14]	@ movhi
 3803 001a 03F10103 		add	r3, r3, #1
 3804 001e FB81     		strh	r3, [r7, #14]	@ movhi
 3805              	.L212:
2556:Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3806              		.loc 1 2556 0 discriminator 1
 3807 0020 7B68     		ldr	r3, [r7, #4]
 3808 0022 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3809 0024 A52B     		cmp	r3, #165
 3810 0026 F3D0     		beq	.L213
2560:Source/tasks.c **** 		}
2561:Source/tasks.c **** 
2562:Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3811              		.loc 1 2562 0
 3812 0028 FB89     		ldrh	r3, [r7, #14]
 3813 002a 4FEA9303 		lsr	r3, r3, #2
 3814 002e FB81     		strh	r3, [r7, #14]	@ movhi
2563:Source/tasks.c **** 
2564:Source/tasks.c **** 		return usCount;
 3815              		.loc 1 2564 0
 3816 0030 FB89     		ldrh	r3, [r7, #14]
2565:Source/tasks.c **** 	}
 3817              		.loc 1 2565 0
 3818 0032 1846     		mov	r0, r3
 3819 0034 07F11407 		add	r7, r7, #20
 3820 0038 BD46     		mov	sp, r7
 3821 003a 80BC     		pop	{r7}
 3822 003c 7047     		bx	lr
 3823              		.cfi_endproc
 3824              	.LFE145:
 3826 003e 00BF     		.section	.text.prvDeleteTCB,"ax",%progbits
 3827              		.align	2
 3828              		.thumb
 3829              		.thumb_func
 3831              	prvDeleteTCB:
 3832              	.LFB146:
2566:Source/tasks.c **** 
2567:Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
2568:Source/tasks.c **** /*-----------------------------------------------------------*/
2569:Source/tasks.c **** 
2570:Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2571:Source/tasks.c **** 
2572:Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2573:Source/tasks.c **** 	{
2574:Source/tasks.c **** 	tskTCB *pxTCB;
2575:Source/tasks.c **** 	unsigned char *pcEndOfStack;
2576:Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2577:Source/tasks.c **** 
2578:Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2579:Source/tasks.c **** 
2580:Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2581:Source/tasks.c **** 		{
2582:Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2583:Source/tasks.c **** 		}
2584:Source/tasks.c **** 		#else
2585:Source/tasks.c **** 		{
2586:Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2587:Source/tasks.c **** 		}
2588:Source/tasks.c **** 		#endif
2589:Source/tasks.c **** 
2590:Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) prvTaskCheckFreeStackSpace( pcEndOfStack );
2591:Source/tasks.c **** 
2592:Source/tasks.c **** 		return uxReturn;
2593:Source/tasks.c **** 	}
2594:Source/tasks.c **** 
2595:Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
2596:Source/tasks.c **** /*-----------------------------------------------------------*/
2597:Source/tasks.c **** 
2598:Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2599:Source/tasks.c **** 
2600:Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2601:Source/tasks.c **** 	{
 3833              		.loc 1 2601 0
 3834              		.cfi_startproc
 3835              		@ args = 0, pretend = 0, frame = 8
 3836              		@ frame_needed = 1, uses_anonymous_args = 0
 3837 0000 80B5     		push	{r7, lr}
 3838              	.LCFI104:
 3839              		.cfi_def_cfa_offset 8
 3840              		.cfi_offset 7, -8
 3841              		.cfi_offset 14, -4
 3842 0002 82B0     		sub	sp, sp, #8
 3843              	.LCFI105:
 3844              		.cfi_def_cfa_offset 16
 3845 0004 00AF     		add	r7, sp, #0
 3846              	.LCFI106:
 3847              		.cfi_def_cfa_register 7
 3848 0006 7860     		str	r0, [r7, #4]
2602:Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2603:Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2604:Source/tasks.c **** 		want to allocate and clean RAM statically. */
2605:Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2606:Source/tasks.c **** 
2607:Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2608:Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2609:Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3849              		.loc 1 2609 0
 3850 0008 7B68     		ldr	r3, [r7, #4]
 3851 000a 1B6B     		ldr	r3, [r3, #48]
 3852 000c 1846     		mov	r0, r3
 3853 000e FFF7FEFF 		bl	vPortFree
2610:Source/tasks.c **** 		vPortFree( pxTCB );
 3854              		.loc 1 2610 0
 3855 0012 7868     		ldr	r0, [r7, #4]
 3856 0014 FFF7FEFF 		bl	vPortFree
2611:Source/tasks.c **** 	}
 3857              		.loc 1 2611 0
 3858 0018 07F10807 		add	r7, r7, #8
 3859 001c BD46     		mov	sp, r7
 3860 001e 80BD     		pop	{r7, pc}
 3861              		.cfi_endproc
 3862              	.LFE146:
 3864              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3865              		.align	2
 3866              		.global	xTaskGetCurrentTaskHandle
 3867              		.thumb
 3868              		.thumb_func
 3870              	xTaskGetCurrentTaskHandle:
 3871              	.LFB147:
2612:Source/tasks.c **** 
2613:Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
2614:Source/tasks.c **** /*-----------------------------------------------------------*/
2615:Source/tasks.c **** 
2616:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2617:Source/tasks.c **** 
2618:Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2619:Source/tasks.c **** 	{
 3872              		.loc 1 2619 0
 3873              		.cfi_startproc
 3874              		@ args = 0, pretend = 0, frame = 8
 3875              		@ frame_needed = 1, uses_anonymous_args = 0
 3876              		@ link register save eliminated.
 3877 0000 80B4     		push	{r7}
 3878              	.LCFI107:
 3879              		.cfi_def_cfa_offset 4
 3880              		.cfi_offset 7, -4
 3881 0002 83B0     		sub	sp, sp, #12
 3882              	.LCFI108:
 3883              		.cfi_def_cfa_offset 16
 3884 0004 00AF     		add	r7, sp, #0
 3885              	.LCFI109:
 3886              		.cfi_def_cfa_register 7
2620:Source/tasks.c **** 	xTaskHandle xReturn;
2621:Source/tasks.c **** 
2622:Source/tasks.c **** 		/* A critical section is not required as this is not called from
2623:Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2624:Source/tasks.c **** 		individual execution thread. */
2625:Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3887              		.loc 1 2625 0
 3888 0006 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3889 000a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3890 000e 1B68     		ldr	r3, [r3, #0]
 3891 0010 7B60     		str	r3, [r7, #4]
2626:Source/tasks.c **** 
2627:Source/tasks.c **** 		return xReturn;
 3892              		.loc 1 2627 0
 3893 0012 7B68     		ldr	r3, [r7, #4]
2628:Source/tasks.c **** 	}
 3894              		.loc 1 2628 0
 3895 0014 1846     		mov	r0, r3
 3896 0016 07F10C07 		add	r7, r7, #12
 3897 001a BD46     		mov	sp, r7
 3898 001c 80BC     		pop	{r7}
 3899 001e 7047     		bx	lr
 3900              		.cfi_endproc
 3901              	.LFE147:
 3903              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3904              		.align	2
 3905              		.global	xTaskGetSchedulerState
 3906              		.thumb
 3907              		.thumb_func
 3909              	xTaskGetSchedulerState:
 3910              	.LFB148:
2629:Source/tasks.c **** 
2630:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
2631:Source/tasks.c **** /*-----------------------------------------------------------*/
2632:Source/tasks.c **** 
2633:Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2634:Source/tasks.c **** 
2635:Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2636:Source/tasks.c **** 	{
 3911              		.loc 1 2636 0
 3912              		.cfi_startproc
 3913              		@ args = 0, pretend = 0, frame = 8
 3914              		@ frame_needed = 1, uses_anonymous_args = 0
 3915              		@ link register save eliminated.
 3916 0000 80B4     		push	{r7}
 3917              	.LCFI110:
 3918              		.cfi_def_cfa_offset 4
 3919              		.cfi_offset 7, -4
 3920 0002 83B0     		sub	sp, sp, #12
 3921              	.LCFI111:
 3922              		.cfi_def_cfa_offset 16
 3923 0004 00AF     		add	r7, sp, #0
 3924              	.LCFI112:
 3925              		.cfi_def_cfa_register 7
2637:Source/tasks.c **** 	portBASE_TYPE xReturn;
2638:Source/tasks.c **** 
2639:Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3926              		.loc 1 2639 0
 3927 0006 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 3928 000a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 3929 000e 1B68     		ldr	r3, [r3, #0]
 3930 0010 002B     		cmp	r3, #0
 3931 0012 03D1     		bne	.L219
2640:Source/tasks.c **** 		{
2641:Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3932              		.loc 1 2641 0
 3933 0014 4FF00003 		mov	r3, #0
 3934 0018 7B60     		str	r3, [r7, #4]
 3935 001a 0DE0     		b	.L220
 3936              	.L219:
2642:Source/tasks.c **** 		}
2643:Source/tasks.c **** 		else
2644:Source/tasks.c **** 		{
2645:Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3937              		.loc 1 2645 0
 3938 001c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 3939 0020 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 3940 0024 1B68     		ldr	r3, [r3, #0]
 3941 0026 002B     		cmp	r3, #0
 3942 0028 03D1     		bne	.L221
2646:Source/tasks.c **** 			{
2647:Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3943              		.loc 1 2647 0
 3944 002a 4FF00103 		mov	r3, #1
 3945 002e 7B60     		str	r3, [r7, #4]
 3946 0030 02E0     		b	.L220
 3947              	.L221:
2648:Source/tasks.c **** 			}
2649:Source/tasks.c **** 			else
2650:Source/tasks.c **** 			{
2651:Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3948              		.loc 1 2651 0
 3949 0032 4FF00203 		mov	r3, #2
 3950 0036 7B60     		str	r3, [r7, #4]
 3951              	.L220:
2652:Source/tasks.c **** 			}
2653:Source/tasks.c **** 		}
2654:Source/tasks.c **** 
2655:Source/tasks.c **** 		return xReturn;
 3952              		.loc 1 2655 0
 3953 0038 7B68     		ldr	r3, [r7, #4]
2656:Source/tasks.c **** 	}
 3954              		.loc 1 2656 0
 3955 003a 1846     		mov	r0, r3
 3956 003c 07F10C07 		add	r7, r7, #12
 3957 0040 BD46     		mov	sp, r7
 3958 0042 80BC     		pop	{r7}
 3959 0044 7047     		bx	lr
 3960              		.cfi_endproc
 3961              	.LFE148:
 3963 0046 00BF     		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3964              		.align	2
 3965              		.global	vTaskPriorityInherit
 3966              		.thumb
 3967              		.thumb_func
 3969              	vTaskPriorityInherit:
 3970              	.LFB149:
2657:Source/tasks.c **** 
2658:Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
2659:Source/tasks.c **** /*-----------------------------------------------------------*/
2660:Source/tasks.c **** 
2661:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2662:Source/tasks.c **** 
2663:Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
2664:Source/tasks.c **** 	{
 3971              		.loc 1 2664 0
 3972              		.cfi_startproc
 3973              		@ args = 0, pretend = 0, frame = 16
 3974              		@ frame_needed = 1, uses_anonymous_args = 0
 3975 0000 80B5     		push	{r7, lr}
 3976              	.LCFI113:
 3977              		.cfi_def_cfa_offset 8
 3978              		.cfi_offset 7, -8
 3979              		.cfi_offset 14, -4
 3980 0002 84B0     		sub	sp, sp, #16
 3981              	.LCFI114:
 3982              		.cfi_def_cfa_offset 24
 3983 0004 00AF     		add	r7, sp, #0
 3984              	.LCFI115:
 3985              		.cfi_def_cfa_register 7
 3986 0006 7860     		str	r0, [r7, #4]
2665:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3987              		.loc 1 2665 0
 3988 0008 7B68     		ldr	r3, [r7, #4]
 3989 000a FB60     		str	r3, [r7, #12]
2666:Source/tasks.c **** 
2667:Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
2668:Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
2669:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3990              		.loc 1 2669 0
 3991 000c 7B68     		ldr	r3, [r7, #4]
 3992 000e 002B     		cmp	r3, #0
 3993 0010 66D0     		beq	.L223
2670:Source/tasks.c **** 		{
2671:Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3994              		.loc 1 2671 0
 3995 0012 FB68     		ldr	r3, [r7, #12]
 3996 0014 DA6A     		ldr	r2, [r3, #44]
 3997 0016 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 3998 001a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 3999 001e 1B68     		ldr	r3, [r3, #0]
 4000 0020 DB6A     		ldr	r3, [r3, #44]
 4001 0022 9A42     		cmp	r2, r3
 4002 0024 5CD2     		bcs	.L223
2672:Source/tasks.c **** 			{
2673:Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new priority. */
2674:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( 
 4003              		.loc 1 2674 0
 4004 0026 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4005 002a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4006 002e 1B68     		ldr	r3, [r3, #0]
 4007 0030 DB6A     		ldr	r3, [r3, #44]
 4008 0032 C3F10502 		rsb	r2, r3, #5
 4009 0036 FB68     		ldr	r3, [r7, #12]
 4010 0038 9A61     		str	r2, [r3, #24]
2675:Source/tasks.c **** 
2676:Source/tasks.c **** 				/* If the task being modified is in the ready state it will need to
2677:Source/tasks.c **** 				be moved into a new list. */
2678:Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericLis
 4011              		.loc 1 2678 0
 4012 003a FB68     		ldr	r3, [r7, #12]
 4013 003c 5969     		ldr	r1, [r3, #20]
 4014 003e FB68     		ldr	r3, [r7, #12]
 4015 0040 DA6A     		ldr	r2, [r3, #44]
 4016 0042 1346     		mov	r3, r2
 4017 0044 4FEA8303 		lsl	r3, r3, #2
 4018 0048 9B18     		adds	r3, r3, r2
 4019 004a 4FEA8303 		lsl	r3, r3, #2
 4020 004e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4021 0052 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4022 0056 9B18     		adds	r3, r3, r2
 4023 0058 9942     		cmp	r1, r3
 4024 005a 02D1     		bne	.L225
 4025              		.loc 1 2678 0 is_stmt 0 discriminator 1
 4026 005c 4FF00103 		mov	r3, #1
 4027 0060 01E0     		b	.L226
 4028              	.L225:
 4029              		.loc 1 2678 0 discriminator 2
 4030 0062 4FF00003 		mov	r3, #0
 4031              	.L226:
 4032              		.loc 1 2678 0 discriminator 3
 4033 0066 002B     		cmp	r3, #0
 4034 0068 32D0     		beq	.L227
2679:Source/tasks.c **** 				{
2680:Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 4035              		.loc 1 2680 0 is_stmt 1
 4036 006a FB68     		ldr	r3, [r7, #12]
 4037 006c 03F10403 		add	r3, r3, #4
 4038 0070 1846     		mov	r0, r3
 4039 0072 FFF7FEFF 		bl	uxListRemove
2681:Source/tasks.c **** 					{
2682:Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2683:Source/tasks.c **** 					}
2684:Source/tasks.c **** 
2685:Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
2686:Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4040              		.loc 1 2686 0
 4041 0076 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4042 007a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4043 007e 1B68     		ldr	r3, [r3, #0]
 4044 0080 DA6A     		ldr	r2, [r3, #44]
 4045 0082 FB68     		ldr	r3, [r7, #12]
 4046 0084 DA62     		str	r2, [r3, #44]
2687:Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4047              		.loc 1 2687 0
 4048 0086 FB68     		ldr	r3, [r7, #12]
 4049 0088 DA6A     		ldr	r2, [r3, #44]
 4050 008a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4051 008e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4052 0092 1B68     		ldr	r3, [r3, #0]
 4053 0094 9A42     		cmp	r2, r3
 4054 0096 06D9     		bls	.L228
 4055              		.loc 1 2687 0 is_stmt 0 discriminator 1
 4056 0098 FB68     		ldr	r3, [r7, #12]
 4057 009a DA6A     		ldr	r2, [r3, #44]
 4058 009c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4059 00a0 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4060 00a4 1A60     		str	r2, [r3, #0]
 4061              	.L228:
 4062              		.loc 1 2687 0 discriminator 2
 4063 00a6 FB68     		ldr	r3, [r7, #12]
 4064 00a8 DA6A     		ldr	r2, [r3, #44]
 4065 00aa 1346     		mov	r3, r2
 4066 00ac 4FEA8303 		lsl	r3, r3, #2
 4067 00b0 9B18     		adds	r3, r3, r2
 4068 00b2 4FEA8303 		lsl	r3, r3, #2
 4069 00b6 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4070 00ba C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4071 00be 9A18     		adds	r2, r3, r2
 4072 00c0 FB68     		ldr	r3, [r7, #12]
 4073 00c2 03F10403 		add	r3, r3, #4
 4074 00c6 1046     		mov	r0, r2
 4075 00c8 1946     		mov	r1, r3
 4076 00ca FFF7FEFF 		bl	vListInsertEnd
 4077 00ce 07E0     		b	.L223
 4078              	.L227:
2688:Source/tasks.c **** 				}
2689:Source/tasks.c **** 				else
2690:Source/tasks.c **** 				{
2691:Source/tasks.c **** 					/* Just inherit the priority. */
2692:Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4079              		.loc 1 2692 0 is_stmt 1
 4080 00d0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4081 00d4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4082 00d8 1B68     		ldr	r3, [r3, #0]
 4083 00da DA6A     		ldr	r2, [r3, #44]
 4084 00dc FB68     		ldr	r3, [r7, #12]
 4085 00de DA62     		str	r2, [r3, #44]
 4086              	.L223:
2693:Source/tasks.c **** 				}
2694:Source/tasks.c **** 
2695:Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2696:Source/tasks.c **** 			}
2697:Source/tasks.c **** 		}
2698:Source/tasks.c **** 	}
 4087              		.loc 1 2698 0
 4088 00e0 07F11007 		add	r7, r7, #16
 4089 00e4 BD46     		mov	sp, r7
 4090 00e6 80BD     		pop	{r7, pc}
 4091              		.cfi_endproc
 4092              	.LFE149:
 4094              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 4095              		.align	2
 4096              		.global	vTaskPriorityDisinherit
 4097              		.thumb
 4098              		.thumb_func
 4100              	vTaskPriorityDisinherit:
 4101              	.LFB150:
2699:Source/tasks.c **** 
2700:Source/tasks.c **** #endif /* configUSE_MUTEXES */
2701:Source/tasks.c **** /*-----------------------------------------------------------*/
2702:Source/tasks.c **** 
2703:Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2704:Source/tasks.c **** 
2705:Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
2706:Source/tasks.c **** 	{
 4102              		.loc 1 2706 0
 4103              		.cfi_startproc
 4104              		@ args = 0, pretend = 0, frame = 16
 4105              		@ frame_needed = 1, uses_anonymous_args = 0
 4106 0000 80B5     		push	{r7, lr}
 4107              	.LCFI116:
 4108              		.cfi_def_cfa_offset 8
 4109              		.cfi_offset 7, -8
 4110              		.cfi_offset 14, -4
 4111 0002 84B0     		sub	sp, sp, #16
 4112              	.LCFI117:
 4113              		.cfi_def_cfa_offset 24
 4114 0004 00AF     		add	r7, sp, #0
 4115              	.LCFI118:
 4116              		.cfi_def_cfa_register 7
 4117 0006 7860     		str	r0, [r7, #4]
2707:Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 4118              		.loc 1 2707 0
 4119 0008 7B68     		ldr	r3, [r7, #4]
 4120 000a FB60     		str	r3, [r7, #12]
2708:Source/tasks.c **** 
2709:Source/tasks.c **** 		if( pxMutexHolder != NULL )
 4121              		.loc 1 2709 0
 4122 000c 7B68     		ldr	r3, [r7, #4]
 4123 000e 002B     		cmp	r3, #0
 4124 0010 39D0     		beq	.L229
2710:Source/tasks.c **** 		{
2711:Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4125              		.loc 1 2711 0
 4126 0012 FB68     		ldr	r3, [r7, #12]
 4127 0014 DA6A     		ldr	r2, [r3, #44]
 4128 0016 FB68     		ldr	r3, [r7, #12]
 4129 0018 9B6C     		ldr	r3, [r3, #72]
 4130 001a 9A42     		cmp	r2, r3
 4131 001c 33D0     		beq	.L229
2712:Source/tasks.c **** 			{
2713:Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2714:Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2715:Source/tasks.c **** 				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 4132              		.loc 1 2715 0
 4133 001e FB68     		ldr	r3, [r7, #12]
 4134 0020 03F10403 		add	r3, r3, #4
 4135 0024 1846     		mov	r0, r3
 4136 0026 FFF7FEFF 		bl	uxListRemove
2716:Source/tasks.c **** 				{
2717:Source/tasks.c **** 					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
2718:Source/tasks.c **** 				}
2719:Source/tasks.c **** 
2720:Source/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2721:Source/tasks.c **** 				ready list. */
2722:Source/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2723:Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 4137              		.loc 1 2723 0
 4138 002a FB68     		ldr	r3, [r7, #12]
 4139 002c 9A6C     		ldr	r2, [r3, #72]
 4140 002e FB68     		ldr	r3, [r7, #12]
 4141 0030 DA62     		str	r2, [r3, #44]
2724:Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( 
 4142              		.loc 1 2724 0
 4143 0032 FB68     		ldr	r3, [r7, #12]
 4144 0034 DB6A     		ldr	r3, [r3, #44]
 4145 0036 C3F10502 		rsb	r2, r3, #5
 4146 003a FB68     		ldr	r3, [r7, #12]
 4147 003c 9A61     		str	r2, [r3, #24]
2725:Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4148              		.loc 1 2725 0
 4149 003e FB68     		ldr	r3, [r7, #12]
 4150 0040 DA6A     		ldr	r2, [r3, #44]
 4151 0042 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4152 0046 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4153 004a 1B68     		ldr	r3, [r3, #0]
 4154 004c 9A42     		cmp	r2, r3
 4155 004e 06D9     		bls	.L231
 4156              		.loc 1 2725 0 is_stmt 0 discriminator 1
 4157 0050 FB68     		ldr	r3, [r7, #12]
 4158 0052 DA6A     		ldr	r2, [r3, #44]
 4159 0054 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4160 0058 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4161 005c 1A60     		str	r2, [r3, #0]
 4162              	.L231:
 4163              		.loc 1 2725 0 discriminator 2
 4164 005e FB68     		ldr	r3, [r7, #12]
 4165 0060 DA6A     		ldr	r2, [r3, #44]
 4166 0062 1346     		mov	r3, r2
 4167 0064 4FEA8303 		lsl	r3, r3, #2
 4168 0068 9B18     		adds	r3, r3, r2
 4169 006a 4FEA8303 		lsl	r3, r3, #2
 4170 006e 40F20002 		movw	r2, #:lower16:pxReadyTasksLists
 4171 0072 C0F20002 		movt	r2, #:upper16:pxReadyTasksLists
 4172 0076 9A18     		adds	r2, r3, r2
 4173 0078 FB68     		ldr	r3, [r7, #12]
 4174 007a 03F10403 		add	r3, r3, #4
 4175 007e 1046     		mov	r0, r2
 4176 0080 1946     		mov	r1, r3
 4177 0082 FFF7FEFF 		bl	vListInsertEnd
 4178              	.L229:
2726:Source/tasks.c **** 			}
2727:Source/tasks.c **** 		}
2728:Source/tasks.c **** 	}
 4179              		.loc 1 2728 0 is_stmt 1
 4180 0086 07F11007 		add	r7, r7, #16
 4181 008a BD46     		mov	sp, r7
 4182 008c 80BD     		pop	{r7, pc}
 4183              		.cfi_endproc
 4184              	.LFE150:
 4186 008e 00BF     		.section	.rodata.ucExpectedStackBytes.8450,"a",%progbits
 4187              		.align	2
 4190              	ucExpectedStackBytes.8450:
 4191 0000 A5       		.byte	-91
 4192 0001 A5       		.byte	-91
 4193 0002 A5       		.byte	-91
 4194 0003 A5       		.byte	-91
 4195 0004 A5       		.byte	-91
 4196 0005 A5       		.byte	-91
 4197 0006 A5       		.byte	-91
 4198 0007 A5       		.byte	-91
 4199 0008 A5       		.byte	-91
 4200 0009 A5       		.byte	-91
 4201 000a A5       		.byte	-91
 4202 000b A5       		.byte	-91
 4203 000c A5       		.byte	-91
 4204 000d A5       		.byte	-91
 4205 000e A5       		.byte	-91
 4206 000f A5       		.byte	-91
 4207 0010 A5       		.byte	-91
 4208 0011 A5       		.byte	-91
 4209 0012 A5       		.byte	-91
 4210 0013 A5       		.byte	-91
 4211              		.text
 4212              	.Letext0:
 4213              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 4214              		.file 3 "Source/include/projdefs.h"
 4215              		.file 4 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 4216              		.file 5 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 4217              		.file 6 "Source/include/list.h"
 4218              		.file 7 "Source/include/task.h"
 4219              		.file 8 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccfLT38m.s:24     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccfLT38m.s:21     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccfLT38m.s:27     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccfLT38m.s:30     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccfLT38m.s:33     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccfLT38m.s:36     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccfLT38m.s:39     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccfLT38m.s:42     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccfLT38m.s:45     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccfLT38m.s:48     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccfLT38m.s:51     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccfLT38m.s:54     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccfLT38m.s:57     .bss.xPendingReadyList:00000000 $d
     /tmp/ccfLT38m.s:60     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccfLT38m.s:63     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccfLT38m.s:66     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccfLT38m.s:69     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccfLT38m.s:72     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccfLT38m.s:75     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccfLT38m.s:78     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccfLT38m.s:81     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccfLT38m.s:84     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccfLT38m.s:87     .bss.xTickCount:00000000 $d
     /tmp/ccfLT38m.s:90     .bss.xTickCount:00000000 xTickCount
     /tmp/ccfLT38m.s:93     .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccfLT38m.s:96     .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccfLT38m.s:99     .bss.xSchedulerRunning:00000000 $d
     /tmp/ccfLT38m.s:102    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccfLT38m.s:105    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccfLT38m.s:108    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccfLT38m.s:111    .bss.uxPendedTicks:00000000 $d
     /tmp/ccfLT38m.s:114    .bss.uxPendedTicks:00000000 uxPendedTicks
     /tmp/ccfLT38m.s:117    .bss.xYieldPending:00000000 $d
     /tmp/ccfLT38m.s:120    .bss.xYieldPending:00000000 xYieldPending
     /tmp/ccfLT38m.s:123    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccfLT38m.s:126    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccfLT38m.s:129    .bss.uxTaskNumber:00000000 $d
     /tmp/ccfLT38m.s:132    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccfLT38m.s:135    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccfLT38m.s:138    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccfLT38m.s:141    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccfLT38m.s:146    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccfLT38m.s:3513   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccfLT38m.s:3139   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccfLT38m.s:3252   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccfLT38m.s:387    .text.vTaskDelete:00000000 $t
     /tmp/ccfLT38m.s:392    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccfLT38m.s:492    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccfLT38m.s:497    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccfLT38m.s:1533   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccfLT38m.s:3433   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccfLT38m.s:1568   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccfLT38m.s:629    .text.vTaskDelay:00000000 $t
     /tmp/ccfLT38m.s:634    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccfLT38m.s:697    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccfLT38m.s:702    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccfLT38m.s:754    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccfLT38m.s:759    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccfLT38m.s:962    .text.vTaskSuspend:00000000 $t
     /tmp/ccfLT38m.s:967    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccfLT38m.s:2335   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccfLT38m.s:1071   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/ccfLT38m.s:1076   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/ccfLT38m.s:1164   .text.vTaskResume:00000000 $t
     /tmp/ccfLT38m.s:1169   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccfLT38m.s:1277   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccfLT38m.s:1282   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccfLT38m.s:1405   .rodata:00000000 $d
     /tmp/ccfLT38m.s:1406   .rodata:00000000 .LC0
     /tmp/ccfLT38m.s:1409   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccfLT38m.s:1414   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccfLT38m.s:3095   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccfLT38m.s:1494   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccfLT38m.s:1499   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccfLT38m.s:1528   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccfLT38m.s:1563   .text.xTaskResumeAll:00000000 $t
     /tmp/ccfLT38m.s:2029   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/ccfLT38m.s:1753   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccfLT38m.s:1758   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccfLT38m.s:1795   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccfLT38m.s:1800   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccfLT38m.s:1841   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccfLT38m.s:1846   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccfLT38m.s:1873   .text.uxTaskGetSystemState:00000000 $t
     /tmp/ccfLT38m.s:1878   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
     /tmp/ccfLT38m.s:3597   .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
     /tmp/ccfLT38m.s:2024   .text.xTaskIncrementTick:00000000 $t
     /tmp/ccfLT38m.s:2330   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccfLT38m.s:4190   .rodata.ucExpectedStackBytes.8450:00000000 ucExpectedStackBytes.8450
     /tmp/ccfLT38m.s:2505   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccfLT38m.s:2510   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccfLT38m.s:2588   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccfLT38m.s:2593   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
     /tmp/ccfLT38m.s:2655   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccfLT38m.s:2660   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccfLT38m.s:2783   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccfLT38m.s:2788   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccfLT38m.s:2836   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccfLT38m.s:2841   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccfLT38m.s:2962   .text.vTaskMissedYield:00000000 $t
     /tmp/ccfLT38m.s:2967   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccfLT38m.s:2994   .text.uxTaskGetTaskNumber:00000000 $t
     /tmp/ccfLT38m.s:2999   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
     /tmp/ccfLT38m.s:3046   .text.vTaskSetTaskNumber:00000000 $t
     /tmp/ccfLT38m.s:3051   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
     /tmp/ccfLT38m.s:3091   .text.prvIdleTask:00000000 $t
     /tmp/ccfLT38m.s:3338   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccfLT38m.s:3135   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccfLT38m.s:3248   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccfLT38m.s:3334   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccfLT38m.s:3831   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccfLT38m.s:3429   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccfLT38m.s:3509   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccfLT38m.s:3593   .text.prvListTaskWithinSingleList:00000000 $t
     /tmp/ccfLT38m.s:3773   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
     /tmp/ccfLT38m.s:3769   .text.prvTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccfLT38m.s:3827   .text.prvDeleteTCB:00000000 $t
     /tmp/ccfLT38m.s:3865   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccfLT38m.s:3870   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccfLT38m.s:3904   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccfLT38m.s:3909   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccfLT38m.s:3964   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccfLT38m.s:3969   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccfLT38m.s:4095   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/ccfLT38m.s:4100   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/ccfLT38m.s:4187   .rodata.ucExpectedStackBytes.8450:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYield
uxListRemove
vPortValidateInterruptPriority
vPortClearInterruptMask
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vApplicationStackOverflowHook
memcmp
vListInsert
vApplicationIdleHook
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
