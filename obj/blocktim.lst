   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"blocktim.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xTestQueue,"aw",%nobits
  20              		.align	2
  23              	xTestQueue:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xSecondary,"aw",%nobits
  26              		.align	2
  29              	xSecondary:
  30 0000 00000000 		.space	4
  31              		.section	.bss.xPrimaryCycles,"aw",%nobits
  32              		.align	2
  35              	xPrimaryCycles:
  36 0000 00000000 		.space	4
  37              		.section	.bss.xSecondaryCycles,"aw",%nobits
  38              		.align	2
  41              	xSecondaryCycles:
  42 0000 00000000 		.space	4
  43              		.section	.bss.xErrorOccurred,"aw",%nobits
  44              		.align	2
  47              	xErrorOccurred:
  48 0000 00000000 		.space	4
  49              		.section	.bss.xRunIndicator,"aw",%nobits
  50              		.align	2
  53              	xRunIndicator:
  54 0000 00000000 		.space	4
  55              		.section	.rodata
  56              		.align	2
  57              	.LC0:
  58 0000 426C6F63 		.ascii	"Block_Time_Queue\000"
  58      6B5F5469 
  58      6D655F51 
  58      75657565 
  58      00
  59 0011 000000   		.align	2
  60              	.LC1:
  61 0014 42546573 		.ascii	"BTest1\000"
  61      743100
  62 001b 00       		.align	2
  63              	.LC2:
  64 001c 42546573 		.ascii	"BTest2\000"
  64      743200
  65 0023 00       		.section	.text.vCreateBlockTimeTasks,"ax",%progbits
  66              		.align	2
  67              		.global	vCreateBlockTimeTasks
  68              		.thumb
  69              		.thumb_func
  71              	vCreateBlockTimeTasks:
  72              	.LFB110:
  73              		.file 1 "App/Common/Minimal/blocktim.c"
   1:App/Common/Minimal/blocktim.c **** /*
   2:App/Common/Minimal/blocktim.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/blocktim.c ****     All rights reserved
   4:App/Common/Minimal/blocktim.c **** 
   5:App/Common/Minimal/blocktim.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/blocktim.c **** 
   7:App/Common/Minimal/blocktim.c ****     ***************************************************************************
   8:App/Common/Minimal/blocktim.c ****      *                                                                       *
   9:App/Common/Minimal/blocktim.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/blocktim.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/blocktim.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/blocktim.c ****      *                                                                       *
  13:App/Common/Minimal/blocktim.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/blocktim.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/blocktim.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/blocktim.c ****      *                                                                       *
  17:App/Common/Minimal/blocktim.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/blocktim.c ****      *                                                                       *
  19:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  20:App/Common/Minimal/blocktim.c **** 
  21:App/Common/Minimal/blocktim.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/blocktim.c **** 
  23:App/Common/Minimal/blocktim.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/blocktim.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/blocktim.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/blocktim.c **** 
  27:App/Common/Minimal/blocktim.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/blocktim.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/blocktim.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/blocktim.c ****     >>! kernel.
  31:App/Common/Minimal/blocktim.c **** 
  32:App/Common/Minimal/blocktim.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/blocktim.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/blocktim.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/blocktim.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/blocktim.c **** 
  37:App/Common/Minimal/blocktim.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/blocktim.c **** 
  39:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  40:App/Common/Minimal/blocktim.c ****      *                                                                       *
  41:App/Common/Minimal/blocktim.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/blocktim.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/blocktim.c ****      *                                                                       *
  44:App/Common/Minimal/blocktim.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/blocktim.c ****      *                                                                       *
  46:App/Common/Minimal/blocktim.c ****     ***************************************************************************
  47:App/Common/Minimal/blocktim.c **** 
  48:App/Common/Minimal/blocktim.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/blocktim.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/blocktim.c **** 
  51:App/Common/Minimal/blocktim.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/blocktim.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/blocktim.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/blocktim.c **** 
  55:App/Common/Minimal/blocktim.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/blocktim.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/blocktim.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/blocktim.c **** 
  59:App/Common/Minimal/blocktim.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/blocktim.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/blocktim.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/blocktim.c **** 
  63:App/Common/Minimal/blocktim.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/blocktim.c **** */
  65:App/Common/Minimal/blocktim.c **** 
  66:App/Common/Minimal/blocktim.c **** /*
  67:App/Common/Minimal/blocktim.c ****  * This file contains some test scenarios that ensure tasks do not exit queue
  68:App/Common/Minimal/blocktim.c ****  * send or receive functions prematurely.  A description of the tests is
  69:App/Common/Minimal/blocktim.c ****  * included within the code.
  70:App/Common/Minimal/blocktim.c ****  */
  71:App/Common/Minimal/blocktim.c **** 
  72:App/Common/Minimal/blocktim.c **** /* Kernel includes. */
  73:App/Common/Minimal/blocktim.c **** #include "FreeRTOS.h"
  74:App/Common/Minimal/blocktim.c **** #include "task.h"
  75:App/Common/Minimal/blocktim.c **** #include "queue.h"
  76:App/Common/Minimal/blocktim.c **** 
  77:App/Common/Minimal/blocktim.c **** /* Demo includes. */
  78:App/Common/Minimal/blocktim.c **** #include "blocktim.h"
  79:App/Common/Minimal/blocktim.c **** 
  80:App/Common/Minimal/blocktim.c **** /* Task priorities.  Allow these to be overridden. */
  81:App/Common/Minimal/blocktim.c **** #ifndef bktPRIMARY_PRIORITY
  82:App/Common/Minimal/blocktim.c **** 	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
  83:App/Common/Minimal/blocktim.c **** #endif
  84:App/Common/Minimal/blocktim.c **** 
  85:App/Common/Minimal/blocktim.c **** #ifndef bktSECONDARY_PRIORITY
  86:App/Common/Minimal/blocktim.c **** 	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
  87:App/Common/Minimal/blocktim.c **** #endif
  88:App/Common/Minimal/blocktim.c **** 
  89:App/Common/Minimal/blocktim.c **** /* Task behaviour. */
  90:App/Common/Minimal/blocktim.c **** #define bktQUEUE_LENGTH				( 5 )
  91:App/Common/Minimal/blocktim.c **** #define bktSHORT_WAIT				( ( ( portTickType ) 20 ) / portTICK_RATE_MS )
  92:App/Common/Minimal/blocktim.c **** #define bktPRIMARY_BLOCK_TIME		( 10 )
  93:App/Common/Minimal/blocktim.c **** #define bktALLOWABLE_MARGIN			( 15 )
  94:App/Common/Minimal/blocktim.c **** #define bktTIME_TO_BLOCK			( 175 )
  95:App/Common/Minimal/blocktim.c **** #define bktDONT_BLOCK				( ( portTickType ) 0 )
  96:App/Common/Minimal/blocktim.c **** #define bktRUN_INDICATOR			( ( unsigned portBASE_TYPE ) 0x55 )
  97:App/Common/Minimal/blocktim.c **** 
  98:App/Common/Minimal/blocktim.c **** /* The queue on which the tasks block. */
  99:App/Common/Minimal/blocktim.c **** static xQueueHandle xTestQueue;
 100:App/Common/Minimal/blocktim.c **** 
 101:App/Common/Minimal/blocktim.c **** /* Handle to the secondary task is required by the primary task for calls
 102:App/Common/Minimal/blocktim.c **** to vTaskSuspend/Resume(). */
 103:App/Common/Minimal/blocktim.c **** static xTaskHandle xSecondary;
 104:App/Common/Minimal/blocktim.c **** 
 105:App/Common/Minimal/blocktim.c **** /* Used to ensure that tasks are still executing without error. */
 106:App/Common/Minimal/blocktim.c **** static volatile portBASE_TYPE xPrimaryCycles = 0, xSecondaryCycles = 0;
 107:App/Common/Minimal/blocktim.c **** static volatile portBASE_TYPE xErrorOccurred = pdFALSE;
 108:App/Common/Minimal/blocktim.c **** 
 109:App/Common/Minimal/blocktim.c **** /* Provides a simple mechanism for the primary task to know when the
 110:App/Common/Minimal/blocktim.c **** secondary task has executed. */
 111:App/Common/Minimal/blocktim.c **** static volatile unsigned portBASE_TYPE xRunIndicator;
 112:App/Common/Minimal/blocktim.c **** 
 113:App/Common/Minimal/blocktim.c **** /* The two test tasks.  Their behaviour is commented within the files. */
 114:App/Common/Minimal/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters );
 115:App/Common/Minimal/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters );
 116:App/Common/Minimal/blocktim.c **** 
 117:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 118:App/Common/Minimal/blocktim.c **** 
 119:App/Common/Minimal/blocktim.c **** void vCreateBlockTimeTasks( void )
 120:App/Common/Minimal/blocktim.c **** {
  74              		.loc 1 120 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 1, uses_anonymous_args = 0
  78 0000 80B5     		push	{r7, lr}
  79              	.LCFI0:
  80              		.cfi_def_cfa_offset 8
  81              		.cfi_offset 7, -8
  82              		.cfi_offset 14, -4
  83 0002 84B0     		sub	sp, sp, #16
  84              	.LCFI1:
  85              		.cfi_def_cfa_offset 24
  86 0004 04AF     		add	r7, sp, #16
  87              	.LCFI2:
  88              		.cfi_def_cfa 7, 8
 121:App/Common/Minimal/blocktim.c **** 	/* Create the queue on which the two tasks block. */
 122:App/Common/Minimal/blocktim.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
  89              		.loc 1 122 0
  90 0006 4FF00500 		mov	r0, #5
  91 000a 4FF00401 		mov	r1, #4
  92 000e 4FF00002 		mov	r2, #0
  93 0012 FFF7FEFF 		bl	xQueueGenericCreate
  94 0016 0246     		mov	r2, r0
  95 0018 40F20003 		movw	r3, #:lower16:xTestQueue
  96 001c C0F20003 		movt	r3, #:upper16:xTestQueue
  97 0020 1A60     		str	r2, [r3, #0]
 123:App/Common/Minimal/blocktim.c **** 
 124:App/Common/Minimal/blocktim.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 125:App/Common/Minimal/blocktim.c **** 	in use.  The queue registry is provided as a means for kernel aware
 126:App/Common/Minimal/blocktim.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 127:App/Common/Minimal/blocktim.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 128:App/Common/Minimal/blocktim.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 129:App/Common/Minimal/blocktim.c **** 	defined to be less than 1. */
 130:App/Common/Minimal/blocktim.c **** 	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );
  98              		.loc 1 130 0
  99 0022 40F20003 		movw	r3, #:lower16:xTestQueue
 100 0026 C0F20003 		movt	r3, #:upper16:xTestQueue
 101 002a 1B68     		ldr	r3, [r3, #0]
 102 002c 1846     		mov	r0, r3
 103 002e 40F20001 		movw	r1, #:lower16:.LC0
 104 0032 C0F20001 		movt	r1, #:upper16:.LC0
 105 0036 FFF7FEFF 		bl	vQueueAddToRegistry
 131:App/Common/Minimal/blocktim.c **** 
 132:App/Common/Minimal/blocktim.c **** 	/* Create the two test tasks. */
 133:App/Common/Minimal/blocktim.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL,
 106              		.loc 1 133 0
 107 003a 4FF00203 		mov	r3, #2
 108 003e 0093     		str	r3, [sp, #0]
 109 0040 4FF00003 		mov	r3, #0
 110 0044 0193     		str	r3, [sp, #4]
 111 0046 4FF00003 		mov	r3, #0
 112 004a 0293     		str	r3, [sp, #8]
 113 004c 4FF00003 		mov	r3, #0
 114 0050 0393     		str	r3, [sp, #12]
 115 0052 40F20000 		movw	r0, #:lower16:vPrimaryBlockTimeTestTask
 116 0056 C0F20000 		movt	r0, #:upper16:vPrimaryBlockTimeTestTask
 117 005a 40F20001 		movw	r1, #:lower16:.LC1
 118 005e C0F20001 		movt	r1, #:upper16:.LC1
 119 0062 4FF08202 		mov	r2, #130
 120 0066 4FF00003 		mov	r3, #0
 121 006a FFF7FEFF 		bl	xTaskGenericCreate
 134:App/Common/Minimal/blocktim.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NUL
 122              		.loc 1 134 0
 123 006e 4FF00103 		mov	r3, #1
 124 0072 0093     		str	r3, [sp, #0]
 125 0074 40F20003 		movw	r3, #:lower16:xSecondary
 126 0078 C0F20003 		movt	r3, #:upper16:xSecondary
 127 007c 0193     		str	r3, [sp, #4]
 128 007e 4FF00003 		mov	r3, #0
 129 0082 0293     		str	r3, [sp, #8]
 130 0084 4FF00003 		mov	r3, #0
 131 0088 0393     		str	r3, [sp, #12]
 132 008a 40F20000 		movw	r0, #:lower16:vSecondaryBlockTimeTestTask
 133 008e C0F20000 		movt	r0, #:upper16:vSecondaryBlockTimeTestTask
 134 0092 40F20001 		movw	r1, #:lower16:.LC2
 135 0096 C0F20001 		movt	r1, #:upper16:.LC2
 136 009a 4FF08202 		mov	r2, #130
 137 009e 4FF00003 		mov	r3, #0
 138 00a2 FFF7FEFF 		bl	xTaskGenericCreate
 135:App/Common/Minimal/blocktim.c **** }
 139              		.loc 1 135 0
 140 00a6 BD46     		mov	sp, r7
 141 00a8 80BD     		pop	{r7, pc}
 142              		.cfi_endproc
 143              	.LFE110:
 145 00aa 00BF     		.section	.text.vPrimaryBlockTimeTestTask,"ax",%progbits
 146              		.align	2
 147              		.thumb
 148              		.thumb_func
 150              	vPrimaryBlockTimeTestTask:
 151              	.LFB111:
 136:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 137:App/Common/Minimal/blocktim.c **** 
 138:App/Common/Minimal/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters )
 139:App/Common/Minimal/blocktim.c **** {
 152              		.loc 1 139 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 32
 155              		@ frame_needed = 1, uses_anonymous_args = 0
 156 0000 80B5     		push	{r7, lr}
 157              	.LCFI3:
 158              		.cfi_def_cfa_offset 8
 159              		.cfi_offset 7, -8
 160              		.cfi_offset 14, -4
 161 0002 88B0     		sub	sp, sp, #32
 162              	.LCFI4:
 163              		.cfi_def_cfa_offset 40
 164 0004 00AF     		add	r7, sp, #0
 165              	.LCFI5:
 166              		.cfi_def_cfa_register 7
 167 0006 7860     		str	r0, [r7, #4]
 168              	.L39:
 140:App/Common/Minimal/blocktim.c **** portBASE_TYPE xItem, xData;
 141:App/Common/Minimal/blocktim.c **** portTickType xTimeWhenBlocking;
 142:App/Common/Minimal/blocktim.c **** portTickType xTimeToBlock, xBlockedTime;
 143:App/Common/Minimal/blocktim.c **** 
 144:App/Common/Minimal/blocktim.c **** 	( void ) pvParameters;
 145:App/Common/Minimal/blocktim.c **** 
 146:App/Common/Minimal/blocktim.c **** 	for( ;; )
 147:App/Common/Minimal/blocktim.c **** 	{
 148:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 149:App/Common/Minimal/blocktim.c ****         Test 1
 150:App/Common/Minimal/blocktim.c **** 
 151:App/Common/Minimal/blocktim.c ****         Simple block time wakeup test on queue receives. */
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 169              		.loc 1 152 0
 170 0008 4FF00003 		mov	r3, #0
 171 000c 3B61     		str	r3, [r7, #16]
 172 000e 42E0     		b	.L3
 173              	.L7:
 153:App/Common/Minimal/blocktim.c **** 		{
 154:App/Common/Minimal/blocktim.c **** 			/* The queue is empty. Attempt to read from the queue using a block
 155:App/Common/Minimal/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 156:App/Common/Minimal/blocktim.c **** 			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
 174              		.loc 1 156 0
 175 0010 3B69     		ldr	r3, [r7, #16]
 176 0012 4FF00A02 		mov	r2, #10
 177 0016 02FA03F3 		lsl	r3, r2, r3
 178 001a FB61     		str	r3, [r7, #28]
 157:App/Common/Minimal/blocktim.c **** 
 158:App/Common/Minimal/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 179              		.loc 1 158 0
 180 001c FFF7FEFF 		bl	xTaskGetTickCount
 181 0020 B861     		str	r0, [r7, #24]
 159:App/Common/Minimal/blocktim.c **** 
 160:App/Common/Minimal/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 161:App/Common/Minimal/blocktim.c **** 			anything on the queue. */
 162:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 182              		.loc 1 162 0
 183 0022 40F20003 		movw	r3, #:lower16:xTestQueue
 184 0026 C0F20003 		movt	r3, #:upper16:xTestQueue
 185 002a 1A68     		ldr	r2, [r3, #0]
 186 002c 07F10C03 		add	r3, r7, #12
 187 0030 1046     		mov	r0, r2
 188 0032 1946     		mov	r1, r3
 189 0034 FA69     		ldr	r2, [r7, #28]
 190 0036 4FF00003 		mov	r3, #0
 191 003a FFF7FEFF 		bl	xQueueGenericReceive
 192 003e 0346     		mov	r3, r0
 193 0040 002B     		cmp	r3, #0
 194 0042 06D0     		beq	.L4
 163:App/Common/Minimal/blocktim.c **** 			{
 164:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 195              		.loc 1 164 0
 196 0044 40F20003 		movw	r3, #:lower16:xErrorOccurred
 197 0048 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 198 004c 4FF00102 		mov	r2, #1
 199 0050 1A60     		str	r2, [r3, #0]
 200              	.L4:
 165:App/Common/Minimal/blocktim.c **** 			}
 166:App/Common/Minimal/blocktim.c **** 
 167:App/Common/Minimal/blocktim.c **** 			/* How long were we blocked for? */
 168:App/Common/Minimal/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 201              		.loc 1 168 0
 202 0052 FFF7FEFF 		bl	xTaskGetTickCount
 203 0056 0246     		mov	r2, r0
 204 0058 BB69     		ldr	r3, [r7, #24]
 205 005a D31A     		subs	r3, r2, r3
 206 005c 7B61     		str	r3, [r7, #20]
 169:App/Common/Minimal/blocktim.c **** 
 170:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 207              		.loc 1 170 0
 208 005e 7A69     		ldr	r2, [r7, #20]
 209 0060 FB69     		ldr	r3, [r7, #28]
 210 0062 9A42     		cmp	r2, r3
 211 0064 06D2     		bcs	.L5
 171:App/Common/Minimal/blocktim.c **** 			{
 172:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 173:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 212              		.loc 1 173 0
 213 0066 40F20003 		movw	r3, #:lower16:xErrorOccurred
 214 006a C0F20003 		movt	r3, #:upper16:xErrorOccurred
 215 006e 4FF00102 		mov	r2, #1
 216 0072 1A60     		str	r2, [r3, #0]
 217              	.L5:
 174:App/Common/Minimal/blocktim.c **** 			}
 175:App/Common/Minimal/blocktim.c **** 
 176:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 218              		.loc 1 176 0
 219 0074 FB69     		ldr	r3, [r7, #28]
 220 0076 03F10F02 		add	r2, r3, #15
 221 007a 7B69     		ldr	r3, [r7, #20]
 222 007c 9A42     		cmp	r2, r3
 223 007e 06D2     		bcs	.L6
 177:App/Common/Minimal/blocktim.c **** 			{
 178:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 179:App/Common/Minimal/blocktim.c **** 				although we would not necessarily run as soon as we were
 180:App/Common/Minimal/blocktim.c **** 				unblocked so a margin is allowed. */
 181:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 224              		.loc 1 181 0
 225 0080 40F20003 		movw	r3, #:lower16:xErrorOccurred
 226 0084 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 227 0088 4FF00102 		mov	r2, #1
 228 008c 1A60     		str	r2, [r3, #0]
 229              	.L6:
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 230              		.loc 1 152 0
 231 008e 3B69     		ldr	r3, [r7, #16]
 232 0090 03F10103 		add	r3, r3, #1
 233 0094 3B61     		str	r3, [r7, #16]
 234              	.L3:
 152:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 235              		.loc 1 152 0 is_stmt 0 discriminator 1
 236 0096 3B69     		ldr	r3, [r7, #16]
 237 0098 042B     		cmp	r3, #4
 238 009a B9DD     		ble	.L7
 182:App/Common/Minimal/blocktim.c **** 			}
 183:App/Common/Minimal/blocktim.c **** 		}
 184:App/Common/Minimal/blocktim.c **** 
 185:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 186:App/Common/Minimal/blocktim.c ****         Test 2
 187:App/Common/Minimal/blocktim.c **** 
 188:App/Common/Minimal/blocktim.c ****         Simple block time wakeup test on queue sends.
 189:App/Common/Minimal/blocktim.c **** 
 190:App/Common/Minimal/blocktim.c **** 		First fill the queue.  It should be empty so all sends should pass. */
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 239              		.loc 1 191 0 is_stmt 1
 240 009c 4FF00003 		mov	r3, #0
 241 00a0 3B61     		str	r3, [r7, #16]
 242 00a2 1CE0     		b	.L8
 243              	.L10:
 192:App/Common/Minimal/blocktim.c **** 		{
 193:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 244              		.loc 1 193 0
 245 00a4 40F20003 		movw	r3, #:lower16:xTestQueue
 246 00a8 C0F20003 		movt	r3, #:upper16:xTestQueue
 247 00ac 1A68     		ldr	r2, [r3, #0]
 248 00ae 07F11003 		add	r3, r7, #16
 249 00b2 1046     		mov	r0, r2
 250 00b4 1946     		mov	r1, r3
 251 00b6 4FF00002 		mov	r2, #0
 252 00ba 4FF00003 		mov	r3, #0
 253 00be FFF7FEFF 		bl	xQueueGenericSend
 254 00c2 0346     		mov	r3, r0
 255 00c4 012B     		cmp	r3, #1
 256 00c6 06D0     		beq	.L9
 194:App/Common/Minimal/blocktim.c **** 			{
 195:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 257              		.loc 1 195 0
 258 00c8 40F20003 		movw	r3, #:lower16:xErrorOccurred
 259 00cc C0F20003 		movt	r3, #:upper16:xErrorOccurred
 260 00d0 4FF00102 		mov	r2, #1
 261 00d4 1A60     		str	r2, [r3, #0]
 262              	.L9:
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 263              		.loc 1 191 0
 264 00d6 3B69     		ldr	r3, [r7, #16]
 265 00d8 03F10103 		add	r3, r3, #1
 266 00dc 3B61     		str	r3, [r7, #16]
 267              	.L8:
 191:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 268              		.loc 1 191 0 is_stmt 0 discriminator 1
 269 00de 3B69     		ldr	r3, [r7, #16]
 270 00e0 042B     		cmp	r3, #4
 271 00e2 DFDD     		ble	.L10
 196:App/Common/Minimal/blocktim.c **** 			}
 197:App/Common/Minimal/blocktim.c **** 
 198:App/Common/Minimal/blocktim.c **** 			#if configUSE_PREEMPTION == 0
 199:App/Common/Minimal/blocktim.c **** 				taskYIELD();
 200:App/Common/Minimal/blocktim.c **** 			#endif
 201:App/Common/Minimal/blocktim.c **** 		}
 202:App/Common/Minimal/blocktim.c **** 
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 272              		.loc 1 203 0 is_stmt 1
 273 00e4 4FF00003 		mov	r3, #0
 274 00e8 3B61     		str	r3, [r7, #16]
 275 00ea 42E0     		b	.L11
 276              	.L15:
 204:App/Common/Minimal/blocktim.c **** 		{
 205:App/Common/Minimal/blocktim.c **** 			/* The queue is full. Attempt to write to the queue using a block
 206:App/Common/Minimal/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 207:App/Common/Minimal/blocktim.c **** 			xTimeToBlock = ( portTickType ) ( bktPRIMARY_BLOCK_TIME << xItem );
 277              		.loc 1 207 0
 278 00ec 3B69     		ldr	r3, [r7, #16]
 279 00ee 4FF00A02 		mov	r2, #10
 280 00f2 02FA03F3 		lsl	r3, r2, r3
 281 00f6 FB61     		str	r3, [r7, #28]
 208:App/Common/Minimal/blocktim.c **** 
 209:App/Common/Minimal/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 282              		.loc 1 209 0
 283 00f8 FFF7FEFF 		bl	xTaskGetTickCount
 284 00fc B861     		str	r0, [r7, #24]
 210:App/Common/Minimal/blocktim.c **** 
 211:App/Common/Minimal/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 212:App/Common/Minimal/blocktim.c **** 			anything on the queue. */
 213:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 285              		.loc 1 213 0
 286 00fe 40F20003 		movw	r3, #:lower16:xTestQueue
 287 0102 C0F20003 		movt	r3, #:upper16:xTestQueue
 288 0106 1A68     		ldr	r2, [r3, #0]
 289 0108 07F11003 		add	r3, r7, #16
 290 010c 1046     		mov	r0, r2
 291 010e 1946     		mov	r1, r3
 292 0110 FA69     		ldr	r2, [r7, #28]
 293 0112 4FF00003 		mov	r3, #0
 294 0116 FFF7FEFF 		bl	xQueueGenericSend
 295 011a 0346     		mov	r3, r0
 296 011c 002B     		cmp	r3, #0
 297 011e 06D0     		beq	.L12
 214:App/Common/Minimal/blocktim.c **** 			{
 215:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 298              		.loc 1 215 0
 299 0120 40F20003 		movw	r3, #:lower16:xErrorOccurred
 300 0124 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 301 0128 4FF00102 		mov	r2, #1
 302 012c 1A60     		str	r2, [r3, #0]
 303              	.L12:
 216:App/Common/Minimal/blocktim.c **** 			}
 217:App/Common/Minimal/blocktim.c **** 
 218:App/Common/Minimal/blocktim.c **** 			/* How long were we blocked for? */
 219:App/Common/Minimal/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 304              		.loc 1 219 0
 305 012e FFF7FEFF 		bl	xTaskGetTickCount
 306 0132 0246     		mov	r2, r0
 307 0134 BB69     		ldr	r3, [r7, #24]
 308 0136 D31A     		subs	r3, r2, r3
 309 0138 7B61     		str	r3, [r7, #20]
 220:App/Common/Minimal/blocktim.c **** 
 221:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 310              		.loc 1 221 0
 311 013a 7A69     		ldr	r2, [r7, #20]
 312 013c FB69     		ldr	r3, [r7, #28]
 313 013e 9A42     		cmp	r2, r3
 314 0140 06D2     		bcs	.L13
 222:App/Common/Minimal/blocktim.c **** 			{
 223:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 224:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 315              		.loc 1 224 0
 316 0142 40F20003 		movw	r3, #:lower16:xErrorOccurred
 317 0146 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 318 014a 4FF00102 		mov	r2, #1
 319 014e 1A60     		str	r2, [r3, #0]
 320              	.L13:
 225:App/Common/Minimal/blocktim.c **** 			}
 226:App/Common/Minimal/blocktim.c **** 
 227:App/Common/Minimal/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 321              		.loc 1 227 0
 322 0150 FB69     		ldr	r3, [r7, #28]
 323 0152 03F10F02 		add	r2, r3, #15
 324 0156 7B69     		ldr	r3, [r7, #20]
 325 0158 9A42     		cmp	r2, r3
 326 015a 06D2     		bcs	.L14
 228:App/Common/Minimal/blocktim.c **** 			{
 229:App/Common/Minimal/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 230:App/Common/Minimal/blocktim.c **** 				although we would not necessarily run as soon as we were
 231:App/Common/Minimal/blocktim.c **** 				unblocked so a margin is allowed. */
 232:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 327              		.loc 1 232 0
 328 015c 40F20003 		movw	r3, #:lower16:xErrorOccurred
 329 0160 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 330 0164 4FF00102 		mov	r2, #1
 331 0168 1A60     		str	r2, [r3, #0]
 332              	.L14:
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 333              		.loc 1 203 0
 334 016a 3B69     		ldr	r3, [r7, #16]
 335 016c 03F10103 		add	r3, r3, #1
 336 0170 3B61     		str	r3, [r7, #16]
 337              	.L11:
 203:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 338              		.loc 1 203 0 is_stmt 0 discriminator 1
 339 0172 3B69     		ldr	r3, [r7, #16]
 340 0174 042B     		cmp	r3, #4
 341 0176 B9DD     		ble	.L15
 233:App/Common/Minimal/blocktim.c **** 			}
 234:App/Common/Minimal/blocktim.c **** 		}
 235:App/Common/Minimal/blocktim.c **** 
 236:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 237:App/Common/Minimal/blocktim.c ****         Test 3
 238:App/Common/Minimal/blocktim.c **** 
 239:App/Common/Minimal/blocktim.c **** 		Wake the other task, it will block attempting to post to the queue.
 240:App/Common/Minimal/blocktim.c **** 		When we read from the queue the other task will wake, but before it
 241:App/Common/Minimal/blocktim.c **** 		can run we will post to the queue again.  When the other task runs it
 242:App/Common/Minimal/blocktim.c **** 		will find the queue still full, even though it was woken.  It should
 243:App/Common/Minimal/blocktim.c **** 		recognise that its block time has not expired and return to block for
 244:App/Common/Minimal/blocktim.c **** 		the remains of its block time.
 245:App/Common/Minimal/blocktim.c **** 
 246:App/Common/Minimal/blocktim.c **** 		Wake the other task so it blocks attempting to post to the already
 247:App/Common/Minimal/blocktim.c **** 		full queue. */
 248:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 342              		.loc 1 248 0 is_stmt 1
 343 0178 40F20003 		movw	r3, #:lower16:xRunIndicator
 344 017c C0F20003 		movt	r3, #:upper16:xRunIndicator
 345 0180 4FF00002 		mov	r2, #0
 346 0184 1A60     		str	r2, [r3, #0]
 249:App/Common/Minimal/blocktim.c **** 		vTaskResume( xSecondary );
 347              		.loc 1 249 0
 348 0186 40F20003 		movw	r3, #:lower16:xSecondary
 349 018a C0F20003 		movt	r3, #:upper16:xSecondary
 350 018e 1B68     		ldr	r3, [r3, #0]
 351 0190 1846     		mov	r0, r3
 352 0192 FFF7FEFF 		bl	vTaskResume
 250:App/Common/Minimal/blocktim.c **** 
 251:App/Common/Minimal/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 252:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 353              		.loc 1 252 0
 354 0196 03E0     		b	.L16
 355              	.L17:
 253:App/Common/Minimal/blocktim.c **** 		{
 254:App/Common/Minimal/blocktim.c **** 			/* The other task has not yet executed. */
 255:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 356              		.loc 1 255 0
 357 0198 4FF01400 		mov	r0, #20
 358 019c FFF7FEFF 		bl	vTaskDelay
 359              	.L16:
 252:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 360              		.loc 1 252 0 discriminator 1
 361 01a0 40F20003 		movw	r3, #:lower16:xRunIndicator
 362 01a4 C0F20003 		movt	r3, #:upper16:xRunIndicator
 363 01a8 1B68     		ldr	r3, [r3, #0]
 364 01aa 552B     		cmp	r3, #85
 365 01ac F4D1     		bne	.L17
 256:App/Common/Minimal/blocktim.c **** 		}
 257:App/Common/Minimal/blocktim.c **** 		/* Make sure the other task is blocked on the queue. */
 258:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 366              		.loc 1 258 0
 367 01ae 4FF01400 		mov	r0, #20
 368 01b2 FFF7FEFF 		bl	vTaskDelay
 259:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 369              		.loc 1 259 0
 370 01b6 40F20003 		movw	r3, #:lower16:xRunIndicator
 371 01ba C0F20003 		movt	r3, #:upper16:xRunIndicator
 372 01be 4FF00002 		mov	r2, #0
 373 01c2 1A60     		str	r2, [r3, #0]
 260:App/Common/Minimal/blocktim.c **** 
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 374              		.loc 1 261 0
 375 01c4 4FF00003 		mov	r3, #0
 376 01c8 3B61     		str	r3, [r7, #16]
 377 01ca 65E0     		b	.L18
 378              	.L23:
 262:App/Common/Minimal/blocktim.c **** 		{
 263:App/Common/Minimal/blocktim.c **** 			/* Now when we make space on the queue the other task should wake
 264:App/Common/Minimal/blocktim.c **** 			but not execute as this task has higher priority. */
 265:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 379              		.loc 1 265 0
 380 01cc 40F20003 		movw	r3, #:lower16:xTestQueue
 381 01d0 C0F20003 		movt	r3, #:upper16:xTestQueue
 382 01d4 1A68     		ldr	r2, [r3, #0]
 383 01d6 07F10C03 		add	r3, r7, #12
 384 01da 1046     		mov	r0, r2
 385 01dc 1946     		mov	r1, r3
 386 01de 4FF00002 		mov	r2, #0
 387 01e2 4FF00003 		mov	r3, #0
 388 01e6 FFF7FEFF 		bl	xQueueGenericReceive
 389 01ea 0346     		mov	r3, r0
 390 01ec 012B     		cmp	r3, #1
 391 01ee 06D0     		beq	.L19
 266:App/Common/Minimal/blocktim.c **** 			{
 267:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 392              		.loc 1 267 0
 393 01f0 40F20003 		movw	r3, #:lower16:xErrorOccurred
 394 01f4 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 395 01f8 4FF00102 		mov	r2, #1
 396 01fc 1A60     		str	r2, [r3, #0]
 397              	.L19:
 268:App/Common/Minimal/blocktim.c **** 			}
 269:App/Common/Minimal/blocktim.c **** 
 270:App/Common/Minimal/blocktim.c **** 			/* Now fill the queue again before the other task gets a chance to
 271:App/Common/Minimal/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 272:App/Common/Minimal/blocktim.c **** 			full ourselves, and the other task have set xRunIndicator. */
 273:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 398              		.loc 1 273 0
 399 01fe 40F20003 		movw	r3, #:lower16:xTestQueue
 400 0202 C0F20003 		movt	r3, #:upper16:xTestQueue
 401 0206 1A68     		ldr	r2, [r3, #0]
 402 0208 07F11003 		add	r3, r7, #16
 403 020c 1046     		mov	r0, r2
 404 020e 1946     		mov	r1, r3
 405 0210 4FF00002 		mov	r2, #0
 406 0214 4FF00003 		mov	r3, #0
 407 0218 FFF7FEFF 		bl	xQueueGenericSend
 408 021c 0346     		mov	r3, r0
 409 021e 012B     		cmp	r3, #1
 410 0220 06D0     		beq	.L20
 274:App/Common/Minimal/blocktim.c **** 			{
 275:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 411              		.loc 1 275 0
 412 0222 40F20003 		movw	r3, #:lower16:xErrorOccurred
 413 0226 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 414 022a 4FF00102 		mov	r2, #1
 415 022e 1A60     		str	r2, [r3, #0]
 416              	.L20:
 276:App/Common/Minimal/blocktim.c **** 			}
 277:App/Common/Minimal/blocktim.c **** 
 278:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 417              		.loc 1 278 0
 418 0230 40F20003 		movw	r3, #:lower16:xRunIndicator
 419 0234 C0F20003 		movt	r3, #:upper16:xRunIndicator
 420 0238 1B68     		ldr	r3, [r3, #0]
 421 023a 552B     		cmp	r3, #85
 422 023c 06D1     		bne	.L21
 279:App/Common/Minimal/blocktim.c **** 			{
 280:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed. */
 281:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 423              		.loc 1 281 0
 424 023e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 425 0242 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 426 0246 4FF00102 		mov	r2, #1
 427 024a 1A60     		str	r2, [r3, #0]
 428              	.L21:
 282:App/Common/Minimal/blocktim.c **** 			}
 283:App/Common/Minimal/blocktim.c **** 
 284:App/Common/Minimal/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 285:App/Common/Minimal/blocktim.c **** 			on the queue again. */
 286:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 429              		.loc 1 286 0
 430 024c 40F20003 		movw	r3, #:lower16:xSecondary
 431 0250 C0F20003 		movt	r3, #:upper16:xSecondary
 432 0254 1B68     		ldr	r3, [r3, #0]
 433 0256 1846     		mov	r0, r3
 434 0258 4FF00401 		mov	r1, #4
 435 025c FFF7FEFF 		bl	vTaskPrioritySet
 287:App/Common/Minimal/blocktim.c **** 
 288:App/Common/Minimal/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 289:App/Common/Minimal/blocktim.c **** 			queue function. */
 290:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 436              		.loc 1 290 0
 437 0260 40F20003 		movw	r3, #:lower16:xRunIndicator
 438 0264 C0F20003 		movt	r3, #:upper16:xRunIndicator
 439 0268 1B68     		ldr	r3, [r3, #0]
 440 026a 552B     		cmp	r3, #85
 441 026c 06D1     		bne	.L22
 291:App/Common/Minimal/blocktim.c **** 			{
 292:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed outside of the
 293:App/Common/Minimal/blocktim.c **** 				queue function. */
 294:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 442              		.loc 1 294 0
 443 026e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 444 0272 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 445 0276 4FF00102 		mov	r2, #1
 446 027a 1A60     		str	r2, [r3, #0]
 447              	.L22:
 295:App/Common/Minimal/blocktim.c **** 			}
 296:App/Common/Minimal/blocktim.c **** 
 297:App/Common/Minimal/blocktim.c **** 			/* Set the priority back down. */
 298:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 448              		.loc 1 298 0
 449 027c 40F20003 		movw	r3, #:lower16:xSecondary
 450 0280 C0F20003 		movt	r3, #:upper16:xSecondary
 451 0284 1B68     		ldr	r3, [r3, #0]
 452 0286 1846     		mov	r0, r3
 453 0288 4FF00101 		mov	r1, #1
 454 028c FFF7FEFF 		bl	vTaskPrioritySet
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 455              		.loc 1 261 0
 456 0290 3B69     		ldr	r3, [r7, #16]
 457 0292 03F10103 		add	r3, r3, #1
 458 0296 3B61     		str	r3, [r7, #16]
 459              	.L18:
 261:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 460              		.loc 1 261 0 is_stmt 0 discriminator 1
 461 0298 3B69     		ldr	r3, [r7, #16]
 462 029a 042B     		cmp	r3, #4
 463 029c 96DD     		ble	.L23
 299:App/Common/Minimal/blocktim.c **** 		}
 300:App/Common/Minimal/blocktim.c **** 
 301:App/Common/Minimal/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 302:App/Common/Minimal/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 303:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 464              		.loc 1 303 0 is_stmt 1
 465 029e 03E0     		b	.L24
 466              	.L25:
 304:App/Common/Minimal/blocktim.c **** 		{
 305:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 467              		.loc 1 305 0
 468 02a0 4FF01400 		mov	r0, #20
 469 02a4 FFF7FEFF 		bl	vTaskDelay
 470              	.L24:
 303:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 471              		.loc 1 303 0 discriminator 1
 472 02a8 40F20003 		movw	r3, #:lower16:xRunIndicator
 473 02ac C0F20003 		movt	r3, #:upper16:xRunIndicator
 474 02b0 1B68     		ldr	r3, [r3, #0]
 475 02b2 552B     		cmp	r3, #85
 476 02b4 F4D1     		bne	.L25
 306:App/Common/Minimal/blocktim.c **** 		}
 307:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 477              		.loc 1 307 0
 478 02b6 4FF01400 		mov	r0, #20
 479 02ba FFF7FEFF 		bl	vTaskDelay
 308:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 480              		.loc 1 308 0
 481 02be 40F20003 		movw	r3, #:lower16:xRunIndicator
 482 02c2 C0F20003 		movt	r3, #:upper16:xRunIndicator
 483 02c6 4FF00002 		mov	r2, #0
 484 02ca 1A60     		str	r2, [r3, #0]
 309:App/Common/Minimal/blocktim.c **** 
 310:App/Common/Minimal/blocktim.c **** 
 311:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 312:App/Common/Minimal/blocktim.c ****         Test 4
 313:App/Common/Minimal/blocktim.c **** 
 314:App/Common/Minimal/blocktim.c **** 		As per test 3 - but with the send and receive the other way around.
 315:App/Common/Minimal/blocktim.c **** 		The other task blocks attempting to read from the queue.
 316:App/Common/Minimal/blocktim.c **** 
 317:App/Common/Minimal/blocktim.c **** 		Empty the queue.  We should find that it is full. */
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 485              		.loc 1 318 0
 486 02cc 4FF00003 		mov	r3, #0
 487 02d0 3B61     		str	r3, [r7, #16]
 488 02d2 1CE0     		b	.L26
 489              	.L28:
 319:App/Common/Minimal/blocktim.c **** 		{
 320:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 490              		.loc 1 320 0
 491 02d4 40F20003 		movw	r3, #:lower16:xTestQueue
 492 02d8 C0F20003 		movt	r3, #:upper16:xTestQueue
 493 02dc 1A68     		ldr	r2, [r3, #0]
 494 02de 07F10C03 		add	r3, r7, #12
 495 02e2 1046     		mov	r0, r2
 496 02e4 1946     		mov	r1, r3
 497 02e6 4FF00002 		mov	r2, #0
 498 02ea 4FF00003 		mov	r3, #0
 499 02ee FFF7FEFF 		bl	xQueueGenericReceive
 500 02f2 0346     		mov	r3, r0
 501 02f4 012B     		cmp	r3, #1
 502 02f6 06D0     		beq	.L27
 321:App/Common/Minimal/blocktim.c **** 			{
 322:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 503              		.loc 1 322 0
 504 02f8 40F20003 		movw	r3, #:lower16:xErrorOccurred
 505 02fc C0F20003 		movt	r3, #:upper16:xErrorOccurred
 506 0300 4FF00102 		mov	r2, #1
 507 0304 1A60     		str	r2, [r3, #0]
 508              	.L27:
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 509              		.loc 1 318 0
 510 0306 3B69     		ldr	r3, [r7, #16]
 511 0308 03F10103 		add	r3, r3, #1
 512 030c 3B61     		str	r3, [r7, #16]
 513              	.L26:
 318:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 514              		.loc 1 318 0 is_stmt 0 discriminator 1
 515 030e 3B69     		ldr	r3, [r7, #16]
 516 0310 042B     		cmp	r3, #4
 517 0312 DFDD     		ble	.L28
 323:App/Common/Minimal/blocktim.c **** 			}
 324:App/Common/Minimal/blocktim.c **** 		}
 325:App/Common/Minimal/blocktim.c **** 
 326:App/Common/Minimal/blocktim.c **** 		/* Wake the other task so it blocks attempting to read from  the
 327:App/Common/Minimal/blocktim.c **** 		already	empty queue. */
 328:App/Common/Minimal/blocktim.c **** 		vTaskResume( xSecondary );
 518              		.loc 1 328 0 is_stmt 1
 519 0314 40F20003 		movw	r3, #:lower16:xSecondary
 520 0318 C0F20003 		movt	r3, #:upper16:xSecondary
 521 031c 1B68     		ldr	r3, [r3, #0]
 522 031e 1846     		mov	r0, r3
 523 0320 FFF7FEFF 		bl	vTaskResume
 329:App/Common/Minimal/blocktim.c **** 
 330:App/Common/Minimal/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 331:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 524              		.loc 1 331 0
 525 0324 03E0     		b	.L29
 526              	.L30:
 332:App/Common/Minimal/blocktim.c **** 		{
 333:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 527              		.loc 1 333 0
 528 0326 4FF01400 		mov	r0, #20
 529 032a FFF7FEFF 		bl	vTaskDelay
 530              	.L29:
 331:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 531              		.loc 1 331 0 discriminator 1
 532 032e 40F20003 		movw	r3, #:lower16:xRunIndicator
 533 0332 C0F20003 		movt	r3, #:upper16:xRunIndicator
 534 0336 1B68     		ldr	r3, [r3, #0]
 535 0338 552B     		cmp	r3, #85
 536 033a F4D1     		bne	.L30
 334:App/Common/Minimal/blocktim.c **** 		}
 335:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 537              		.loc 1 335 0
 538 033c 4FF01400 		mov	r0, #20
 539 0340 FFF7FEFF 		bl	vTaskDelay
 336:App/Common/Minimal/blocktim.c **** 		xRunIndicator = 0;
 540              		.loc 1 336 0
 541 0344 40F20003 		movw	r3, #:lower16:xRunIndicator
 542 0348 C0F20003 		movt	r3, #:upper16:xRunIndicator
 543 034c 4FF00002 		mov	r2, #0
 544 0350 1A60     		str	r2, [r3, #0]
 337:App/Common/Minimal/blocktim.c **** 
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 545              		.loc 1 338 0
 546 0352 4FF00003 		mov	r3, #0
 547 0356 3B61     		str	r3, [r7, #16]
 548 0358 65E0     		b	.L31
 549              	.L36:
 339:App/Common/Minimal/blocktim.c **** 		{
 340:App/Common/Minimal/blocktim.c **** 			/* Now when we place an item on the queue the other task should
 341:App/Common/Minimal/blocktim.c **** 			wake but not execute as this task has higher priority. */
 342:App/Common/Minimal/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 550              		.loc 1 342 0
 551 035a 40F20003 		movw	r3, #:lower16:xTestQueue
 552 035e C0F20003 		movt	r3, #:upper16:xTestQueue
 553 0362 1A68     		ldr	r2, [r3, #0]
 554 0364 07F11003 		add	r3, r7, #16
 555 0368 1046     		mov	r0, r2
 556 036a 1946     		mov	r1, r3
 557 036c 4FF00002 		mov	r2, #0
 558 0370 4FF00003 		mov	r3, #0
 559 0374 FFF7FEFF 		bl	xQueueGenericSend
 560 0378 0346     		mov	r3, r0
 561 037a 012B     		cmp	r3, #1
 562 037c 06D0     		beq	.L32
 343:App/Common/Minimal/blocktim.c **** 			{
 344:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 563              		.loc 1 344 0
 564 037e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 565 0382 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 566 0386 4FF00102 		mov	r2, #1
 567 038a 1A60     		str	r2, [r3, #0]
 568              	.L32:
 345:App/Common/Minimal/blocktim.c **** 			}
 346:App/Common/Minimal/blocktim.c **** 
 347:App/Common/Minimal/blocktim.c **** 			/* Now empty the queue again before the other task gets a chance to
 348:App/Common/Minimal/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 349:App/Common/Minimal/blocktim.c **** 			empty ourselves, and the other task would be suspended. */
 350:App/Common/Minimal/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 569              		.loc 1 350 0
 570 038c 40F20003 		movw	r3, #:lower16:xTestQueue
 571 0390 C0F20003 		movt	r3, #:upper16:xTestQueue
 572 0394 1A68     		ldr	r2, [r3, #0]
 573 0396 07F10C03 		add	r3, r7, #12
 574 039a 1046     		mov	r0, r2
 575 039c 1946     		mov	r1, r3
 576 039e 4FF00002 		mov	r2, #0
 577 03a2 4FF00003 		mov	r3, #0
 578 03a6 FFF7FEFF 		bl	xQueueGenericReceive
 579 03aa 0346     		mov	r3, r0
 580 03ac 012B     		cmp	r3, #1
 581 03ae 06D0     		beq	.L33
 351:App/Common/Minimal/blocktim.c **** 			{
 352:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 582              		.loc 1 352 0
 583 03b0 40F20003 		movw	r3, #:lower16:xErrorOccurred
 584 03b4 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 585 03b8 4FF00102 		mov	r2, #1
 586 03bc 1A60     		str	r2, [r3, #0]
 587              	.L33:
 353:App/Common/Minimal/blocktim.c **** 			}
 354:App/Common/Minimal/blocktim.c **** 
 355:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 588              		.loc 1 355 0
 589 03be 40F20003 		movw	r3, #:lower16:xRunIndicator
 590 03c2 C0F20003 		movt	r3, #:upper16:xRunIndicator
 591 03c6 1B68     		ldr	r3, [r3, #0]
 592 03c8 552B     		cmp	r3, #85
 593 03ca 06D1     		bne	.L34
 356:App/Common/Minimal/blocktim.c **** 			{
 357:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed. */
 358:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 594              		.loc 1 358 0
 595 03cc 40F20003 		movw	r3, #:lower16:xErrorOccurred
 596 03d0 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 597 03d4 4FF00102 		mov	r2, #1
 598 03d8 1A60     		str	r2, [r3, #0]
 599              	.L34:
 359:App/Common/Minimal/blocktim.c **** 			}
 360:App/Common/Minimal/blocktim.c **** 
 361:App/Common/Minimal/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 362:App/Common/Minimal/blocktim.c **** 			on the queue again. */
 363:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 600              		.loc 1 363 0
 601 03da 40F20003 		movw	r3, #:lower16:xSecondary
 602 03de C0F20003 		movt	r3, #:upper16:xSecondary
 603 03e2 1B68     		ldr	r3, [r3, #0]
 604 03e4 1846     		mov	r0, r3
 605 03e6 4FF00401 		mov	r1, #4
 606 03ea FFF7FEFF 		bl	vTaskPrioritySet
 364:App/Common/Minimal/blocktim.c **** 
 365:App/Common/Minimal/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 366:App/Common/Minimal/blocktim.c **** 			queue function. */
 367:App/Common/Minimal/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 607              		.loc 1 367 0
 608 03ee 40F20003 		movw	r3, #:lower16:xRunIndicator
 609 03f2 C0F20003 		movt	r3, #:upper16:xRunIndicator
 610 03f6 1B68     		ldr	r3, [r3, #0]
 611 03f8 552B     		cmp	r3, #85
 612 03fa 06D1     		bne	.L35
 368:App/Common/Minimal/blocktim.c **** 			{
 369:App/Common/Minimal/blocktim.c **** 				/* The other task should not have executed outside of the
 370:App/Common/Minimal/blocktim.c **** 				queue function. */
 371:App/Common/Minimal/blocktim.c **** 				xErrorOccurred = pdTRUE;
 613              		.loc 1 371 0
 614 03fc 40F20003 		movw	r3, #:lower16:xErrorOccurred
 615 0400 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 616 0404 4FF00102 		mov	r2, #1
 617 0408 1A60     		str	r2, [r3, #0]
 618              	.L35:
 372:App/Common/Minimal/blocktim.c **** 			}
 373:App/Common/Minimal/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 619              		.loc 1 373 0
 620 040a 40F20003 		movw	r3, #:lower16:xSecondary
 621 040e C0F20003 		movt	r3, #:upper16:xSecondary
 622 0412 1B68     		ldr	r3, [r3, #0]
 623 0414 1846     		mov	r0, r3
 624 0416 4FF00101 		mov	r1, #1
 625 041a FFF7FEFF 		bl	vTaskPrioritySet
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 626              		.loc 1 338 0
 627 041e 3B69     		ldr	r3, [r7, #16]
 628 0420 03F10103 		add	r3, r3, #1
 629 0424 3B61     		str	r3, [r7, #16]
 630              	.L31:
 338:App/Common/Minimal/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 631              		.loc 1 338 0 is_stmt 0 discriminator 1
 632 0426 3B69     		ldr	r3, [r7, #16]
 633 0428 042B     		cmp	r3, #4
 634 042a 96DD     		ble	.L36
 374:App/Common/Minimal/blocktim.c **** 		}
 375:App/Common/Minimal/blocktim.c **** 
 376:App/Common/Minimal/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 377:App/Common/Minimal/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 378:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 635              		.loc 1 378 0 is_stmt 1
 636 042c 03E0     		b	.L37
 637              	.L38:
 379:App/Common/Minimal/blocktim.c **** 		{
 380:App/Common/Minimal/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 638              		.loc 1 380 0
 639 042e 4FF01400 		mov	r0, #20
 640 0432 FFF7FEFF 		bl	vTaskDelay
 641              	.L37:
 378:App/Common/Minimal/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 642              		.loc 1 378 0 discriminator 1
 643 0436 40F20003 		movw	r3, #:lower16:xRunIndicator
 644 043a C0F20003 		movt	r3, #:upper16:xRunIndicator
 645 043e 1B68     		ldr	r3, [r3, #0]
 646 0440 552B     		cmp	r3, #85
 647 0442 F4D1     		bne	.L38
 381:App/Common/Minimal/blocktim.c **** 		}
 382:App/Common/Minimal/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 648              		.loc 1 382 0
 649 0444 4FF01400 		mov	r0, #20
 650 0448 FFF7FEFF 		bl	vTaskDelay
 383:App/Common/Minimal/blocktim.c **** 
 384:App/Common/Minimal/blocktim.c **** 		xPrimaryCycles++;
 651              		.loc 1 384 0
 652 044c 40F20003 		movw	r3, #:lower16:xPrimaryCycles
 653 0450 C0F20003 		movt	r3, #:upper16:xPrimaryCycles
 654 0454 1B68     		ldr	r3, [r3, #0]
 655 0456 03F10102 		add	r2, r3, #1
 656 045a 40F20003 		movw	r3, #:lower16:xPrimaryCycles
 657 045e C0F20003 		movt	r3, #:upper16:xPrimaryCycles
 658 0462 1A60     		str	r2, [r3, #0]
 385:App/Common/Minimal/blocktim.c **** 	}
 659              		.loc 1 385 0
 660 0464 D0E5     		b	.L39
 661              		.cfi_endproc
 662              	.LFE111:
 664 0466 00BF     		.section	.text.vSecondaryBlockTimeTestTask,"ax",%progbits
 665              		.align	2
 666              		.thumb
 667              		.thumb_func
 669              	vSecondaryBlockTimeTestTask:
 670              	.LFB112:
 386:App/Common/Minimal/blocktim.c **** }
 387:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 388:App/Common/Minimal/blocktim.c **** 
 389:App/Common/Minimal/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters )
 390:App/Common/Minimal/blocktim.c **** {
 671              		.loc 1 390 0
 672              		.cfi_startproc
 673              		@ args = 0, pretend = 0, frame = 24
 674              		@ frame_needed = 1, uses_anonymous_args = 0
 675 0000 80B5     		push	{r7, lr}
 676              	.LCFI6:
 677              		.cfi_def_cfa_offset 8
 678              		.cfi_offset 7, -8
 679              		.cfi_offset 14, -4
 680 0002 86B0     		sub	sp, sp, #24
 681              	.LCFI7:
 682              		.cfi_def_cfa_offset 32
 683 0004 00AF     		add	r7, sp, #0
 684              	.LCFI8:
 685              		.cfi_def_cfa_register 7
 686 0006 7860     		str	r0, [r7, #4]
 687              	.L47:
 391:App/Common/Minimal/blocktim.c **** portTickType xTimeWhenBlocking, xBlockedTime;
 392:App/Common/Minimal/blocktim.c **** portBASE_TYPE xData;
 393:App/Common/Minimal/blocktim.c **** 
 394:App/Common/Minimal/blocktim.c **** 	( void ) pvParameters;
 395:App/Common/Minimal/blocktim.c **** 
 396:App/Common/Minimal/blocktim.c **** 	for( ;; )
 397:App/Common/Minimal/blocktim.c **** 	{
 398:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 399:App/Common/Minimal/blocktim.c ****         Test 1 and 2
 400:App/Common/Minimal/blocktim.c **** 
 401:App/Common/Minimal/blocktim.c **** 		This task does does not participate in these tests. */
 402:App/Common/Minimal/blocktim.c **** 		vTaskSuspend( NULL );
 688              		.loc 1 402 0
 689 0008 4FF00000 		mov	r0, #0
 690 000c FFF7FEFF 		bl	vTaskSuspend
 403:App/Common/Minimal/blocktim.c **** 
 404:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 405:App/Common/Minimal/blocktim.c ****         Test 3
 406:App/Common/Minimal/blocktim.c **** 
 407:App/Common/Minimal/blocktim.c **** 		The first thing we do is attempt to read from the queue.  It should be
 408:App/Common/Minimal/blocktim.c **** 		full so we block.  Note the time before we block so we can check the
 409:App/Common/Minimal/blocktim.c **** 		wake time is as per that expected. */
 410:App/Common/Minimal/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 691              		.loc 1 410 0
 692 0010 FFF7FEFF 		bl	xTaskGetTickCount
 693 0014 7861     		str	r0, [r7, #20]
 411:App/Common/Minimal/blocktim.c **** 
 412:App/Common/Minimal/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not sent
 413:App/Common/Minimal/blocktim.c **** 		anything to the queue. */
 414:App/Common/Minimal/blocktim.c **** 		xData = 0;
 694              		.loc 1 414 0
 695 0016 4FF00003 		mov	r3, #0
 696 001a FB60     		str	r3, [r7, #12]
 415:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 697              		.loc 1 415 0
 698 001c 40F20003 		movw	r3, #:lower16:xRunIndicator
 699 0020 C0F20003 		movt	r3, #:upper16:xRunIndicator
 700 0024 4FF05502 		mov	r2, #85
 701 0028 1A60     		str	r2, [r3, #0]
 416:App/Common/Minimal/blocktim.c **** 		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 702              		.loc 1 416 0
 703 002a 40F20003 		movw	r3, #:lower16:xTestQueue
 704 002e C0F20003 		movt	r3, #:upper16:xTestQueue
 705 0032 1A68     		ldr	r2, [r3, #0]
 706 0034 07F10C03 		add	r3, r7, #12
 707 0038 1046     		mov	r0, r2
 708 003a 1946     		mov	r1, r3
 709 003c 4FF0AF02 		mov	r2, #175
 710 0040 4FF00003 		mov	r3, #0
 711 0044 FFF7FEFF 		bl	xQueueGenericSend
 712 0048 0346     		mov	r3, r0
 713 004a 002B     		cmp	r3, #0
 714 004c 06D0     		beq	.L41
 417:App/Common/Minimal/blocktim.c **** 		{
 418:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 715              		.loc 1 418 0
 716 004e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 717 0052 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 718 0056 4FF00102 		mov	r2, #1
 719 005a 1A60     		str	r2, [r3, #0]
 720              	.L41:
 419:App/Common/Minimal/blocktim.c **** 		}
 420:App/Common/Minimal/blocktim.c **** 
 421:App/Common/Minimal/blocktim.c **** 		/* How long were we inside the send function? */
 422:App/Common/Minimal/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 721              		.loc 1 422 0
 722 005c FFF7FEFF 		bl	xTaskGetTickCount
 723 0060 0246     		mov	r2, r0
 724 0062 7B69     		ldr	r3, [r7, #20]
 725 0064 D31A     		subs	r3, r2, r3
 726 0066 3B61     		str	r3, [r7, #16]
 423:App/Common/Minimal/blocktim.c **** 
 424:App/Common/Minimal/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 425:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 727              		.loc 1 425 0
 728 0068 3B69     		ldr	r3, [r7, #16]
 729 006a AE2B     		cmp	r3, #174
 730 006c 06D8     		bhi	.L42
 426:App/Common/Minimal/blocktim.c **** 		{
 427:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 731              		.loc 1 427 0
 732 006e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 733 0072 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 734 0076 4FF00102 		mov	r2, #1
 735 007a 1A60     		str	r2, [r3, #0]
 736              	.L42:
 428:App/Common/Minimal/blocktim.c **** 		}
 429:App/Common/Minimal/blocktim.c **** 
 430:App/Common/Minimal/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 431:App/Common/Minimal/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as
 432:App/Common/Minimal/blocktim.c **** 		soon as we unblocked. */
 433:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 737              		.loc 1 433 0
 738 007c 3B69     		ldr	r3, [r7, #16]
 739 007e BE2B     		cmp	r3, #190
 740 0080 06D9     		bls	.L43
 434:App/Common/Minimal/blocktim.c **** 		{
 435:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 741              		.loc 1 435 0
 742 0082 40F20003 		movw	r3, #:lower16:xErrorOccurred
 743 0086 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 744 008a 4FF00102 		mov	r2, #1
 745 008e 1A60     		str	r2, [r3, #0]
 746              	.L43:
 436:App/Common/Minimal/blocktim.c **** 		}
 437:App/Common/Minimal/blocktim.c **** 
 438:App/Common/Minimal/blocktim.c **** 		/* Suspend ready for test 3. */
 439:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 747              		.loc 1 439 0
 748 0090 40F20003 		movw	r3, #:lower16:xRunIndicator
 749 0094 C0F20003 		movt	r3, #:upper16:xRunIndicator
 750 0098 4FF05502 		mov	r2, #85
 751 009c 1A60     		str	r2, [r3, #0]
 440:App/Common/Minimal/blocktim.c **** 		vTaskSuspend( NULL );
 752              		.loc 1 440 0
 753 009e 4FF00000 		mov	r0, #0
 754 00a2 FFF7FEFF 		bl	vTaskSuspend
 441:App/Common/Minimal/blocktim.c **** 
 442:App/Common/Minimal/blocktim.c **** 		/*********************************************************************
 443:App/Common/Minimal/blocktim.c ****         Test 4
 444:App/Common/Minimal/blocktim.c **** 
 445:App/Common/Minimal/blocktim.c **** 		As per test three, but with the send and receive reversed. */
 446:App/Common/Minimal/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 755              		.loc 1 446 0
 756 00a6 FFF7FEFF 		bl	xTaskGetTickCount
 757 00aa 7861     		str	r0, [r7, #20]
 447:App/Common/Minimal/blocktim.c **** 
 448:App/Common/Minimal/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not received
 449:App/Common/Minimal/blocktim.c **** 		anything on the queue. */
 450:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 758              		.loc 1 450 0
 759 00ac 40F20003 		movw	r3, #:lower16:xRunIndicator
 760 00b0 C0F20003 		movt	r3, #:upper16:xRunIndicator
 761 00b4 4FF05502 		mov	r2, #85
 762 00b8 1A60     		str	r2, [r3, #0]
 451:App/Common/Minimal/blocktim.c **** 		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 763              		.loc 1 451 0
 764 00ba 40F20003 		movw	r3, #:lower16:xTestQueue
 765 00be C0F20003 		movt	r3, #:upper16:xTestQueue
 766 00c2 1A68     		ldr	r2, [r3, #0]
 767 00c4 07F10C03 		add	r3, r7, #12
 768 00c8 1046     		mov	r0, r2
 769 00ca 1946     		mov	r1, r3
 770 00cc 4FF0AF02 		mov	r2, #175
 771 00d0 4FF00003 		mov	r3, #0
 772 00d4 FFF7FEFF 		bl	xQueueGenericReceive
 773 00d8 0346     		mov	r3, r0
 774 00da 002B     		cmp	r3, #0
 775 00dc 06D0     		beq	.L44
 452:App/Common/Minimal/blocktim.c **** 		{
 453:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 776              		.loc 1 453 0
 777 00de 40F20003 		movw	r3, #:lower16:xErrorOccurred
 778 00e2 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 779 00e6 4FF00102 		mov	r2, #1
 780 00ea 1A60     		str	r2, [r3, #0]
 781              	.L44:
 454:App/Common/Minimal/blocktim.c **** 		}
 455:App/Common/Minimal/blocktim.c **** 
 456:App/Common/Minimal/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 782              		.loc 1 456 0
 783 00ec FFF7FEFF 		bl	xTaskGetTickCount
 784 00f0 0246     		mov	r2, r0
 785 00f2 7B69     		ldr	r3, [r7, #20]
 786 00f4 D31A     		subs	r3, r2, r3
 787 00f6 3B61     		str	r3, [r7, #16]
 457:App/Common/Minimal/blocktim.c **** 
 458:App/Common/Minimal/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 459:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 788              		.loc 1 459 0
 789 00f8 3B69     		ldr	r3, [r7, #16]
 790 00fa AE2B     		cmp	r3, #174
 791 00fc 06D8     		bhi	.L45
 460:App/Common/Minimal/blocktim.c **** 		{
 461:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 792              		.loc 1 461 0
 793 00fe 40F20003 		movw	r3, #:lower16:xErrorOccurred
 794 0102 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 795 0106 4FF00102 		mov	r2, #1
 796 010a 1A60     		str	r2, [r3, #0]
 797              	.L45:
 462:App/Common/Minimal/blocktim.c **** 		}
 463:App/Common/Minimal/blocktim.c **** 
 464:App/Common/Minimal/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 465:App/Common/Minimal/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as soon
 466:App/Common/Minimal/blocktim.c **** 		as we unblocked. */
 467:App/Common/Minimal/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 798              		.loc 1 467 0
 799 010c 3B69     		ldr	r3, [r7, #16]
 800 010e BE2B     		cmp	r3, #190
 801 0110 06D9     		bls	.L46
 468:App/Common/Minimal/blocktim.c **** 		{
 469:App/Common/Minimal/blocktim.c **** 			xErrorOccurred = pdTRUE;
 802              		.loc 1 469 0
 803 0112 40F20003 		movw	r3, #:lower16:xErrorOccurred
 804 0116 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 805 011a 4FF00102 		mov	r2, #1
 806 011e 1A60     		str	r2, [r3, #0]
 807              	.L46:
 470:App/Common/Minimal/blocktim.c **** 		}
 471:App/Common/Minimal/blocktim.c **** 
 472:App/Common/Minimal/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 808              		.loc 1 472 0
 809 0120 40F20003 		movw	r3, #:lower16:xRunIndicator
 810 0124 C0F20003 		movt	r3, #:upper16:xRunIndicator
 811 0128 4FF05502 		mov	r2, #85
 812 012c 1A60     		str	r2, [r3, #0]
 473:App/Common/Minimal/blocktim.c **** 
 474:App/Common/Minimal/blocktim.c **** 		xSecondaryCycles++;
 813              		.loc 1 474 0
 814 012e 40F20003 		movw	r3, #:lower16:xSecondaryCycles
 815 0132 C0F20003 		movt	r3, #:upper16:xSecondaryCycles
 816 0136 1B68     		ldr	r3, [r3, #0]
 817 0138 03F10102 		add	r2, r3, #1
 818 013c 40F20003 		movw	r3, #:lower16:xSecondaryCycles
 819 0140 C0F20003 		movt	r3, #:upper16:xSecondaryCycles
 820 0144 1A60     		str	r2, [r3, #0]
 475:App/Common/Minimal/blocktim.c **** 	}
 821              		.loc 1 475 0
 822 0146 5FE7     		b	.L47
 823              		.cfi_endproc
 824              	.LFE112:
 826              		.section	.text.xAreBlockTimeTestTasksStillRunning,"ax",%progbits
 827              		.align	2
 828              		.global	xAreBlockTimeTestTasksStillRunning
 829              		.thumb
 830              		.thumb_func
 832              	xAreBlockTimeTestTasksStillRunning:
 833              	.LFB113:
 476:App/Common/Minimal/blocktim.c **** }
 477:App/Common/Minimal/blocktim.c **** /*-----------------------------------------------------------*/
 478:App/Common/Minimal/blocktim.c **** 
 479:App/Common/Minimal/blocktim.c **** portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
 480:App/Common/Minimal/blocktim.c **** {
 834              		.loc 1 480 0
 835              		.cfi_startproc
 836              		@ args = 0, pretend = 0, frame = 8
 837              		@ frame_needed = 1, uses_anonymous_args = 0
 838              		@ link register save eliminated.
 839 0000 80B4     		push	{r7}
 840              	.LCFI9:
 841              		.cfi_def_cfa_offset 4
 842              		.cfi_offset 7, -4
 843 0002 83B0     		sub	sp, sp, #12
 844              	.LCFI10:
 845              		.cfi_def_cfa_offset 16
 846 0004 00AF     		add	r7, sp, #0
 847              	.LCFI11:
 848              		.cfi_def_cfa_register 7
 481:App/Common/Minimal/blocktim.c **** static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
 482:App/Common/Minimal/blocktim.c **** portBASE_TYPE xReturn = pdPASS;
 849              		.loc 1 482 0
 850 0006 4FF00103 		mov	r3, #1
 851 000a 7B60     		str	r3, [r7, #4]
 483:App/Common/Minimal/blocktim.c **** 
 484:App/Common/Minimal/blocktim.c **** 	/* Have both tasks performed at least one cycle since this function was
 485:App/Common/Minimal/blocktim.c **** 	last called? */
 486:App/Common/Minimal/blocktim.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 852              		.loc 1 486 0
 853 000c 40F20003 		movw	r3, #:lower16:xPrimaryCycles
 854 0010 C0F20003 		movt	r3, #:upper16:xPrimaryCycles
 855 0014 1A68     		ldr	r2, [r3, #0]
 856 0016 40F20003 		movw	r3, #:lower16:xLastPrimaryCycleCount.7681
 857 001a C0F20003 		movt	r3, #:upper16:xLastPrimaryCycleCount.7681
 858 001e 1B68     		ldr	r3, [r3, #0]
 859 0020 9A42     		cmp	r2, r3
 860 0022 02D1     		bne	.L49
 487:App/Common/Minimal/blocktim.c **** 	{
 488:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 861              		.loc 1 488 0
 862 0024 4FF00003 		mov	r3, #0
 863 0028 7B60     		str	r3, [r7, #4]
 864              	.L49:
 489:App/Common/Minimal/blocktim.c **** 	}
 490:App/Common/Minimal/blocktim.c **** 
 491:App/Common/Minimal/blocktim.c **** 	if( xSecondaryCycles == xLastSecondaryCycleCount )
 865              		.loc 1 491 0
 866 002a 40F20003 		movw	r3, #:lower16:xSecondaryCycles
 867 002e C0F20003 		movt	r3, #:upper16:xSecondaryCycles
 868 0032 1A68     		ldr	r2, [r3, #0]
 869 0034 40F20003 		movw	r3, #:lower16:xLastSecondaryCycleCount.7682
 870 0038 C0F20003 		movt	r3, #:upper16:xLastSecondaryCycleCount.7682
 871 003c 1B68     		ldr	r3, [r3, #0]
 872 003e 9A42     		cmp	r2, r3
 873 0040 02D1     		bne	.L50
 492:App/Common/Minimal/blocktim.c **** 	{
 493:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 874              		.loc 1 493 0
 875 0042 4FF00003 		mov	r3, #0
 876 0046 7B60     		str	r3, [r7, #4]
 877              	.L50:
 494:App/Common/Minimal/blocktim.c **** 	}
 495:App/Common/Minimal/blocktim.c **** 
 496:App/Common/Minimal/blocktim.c **** 	if( xErrorOccurred == pdTRUE )
 878              		.loc 1 496 0
 879 0048 40F20003 		movw	r3, #:lower16:xErrorOccurred
 880 004c C0F20003 		movt	r3, #:upper16:xErrorOccurred
 881 0050 1B68     		ldr	r3, [r3, #0]
 882 0052 012B     		cmp	r3, #1
 883 0054 02D1     		bne	.L51
 497:App/Common/Minimal/blocktim.c **** 	{
 498:App/Common/Minimal/blocktim.c **** 		xReturn = pdFAIL;
 884              		.loc 1 498 0
 885 0056 4FF00003 		mov	r3, #0
 886 005a 7B60     		str	r3, [r7, #4]
 887              	.L51:
 499:App/Common/Minimal/blocktim.c **** 	}
 500:App/Common/Minimal/blocktim.c **** 
 501:App/Common/Minimal/blocktim.c **** 	xLastSecondaryCycleCount = xSecondaryCycles;
 888              		.loc 1 501 0
 889 005c 40F20003 		movw	r3, #:lower16:xSecondaryCycles
 890 0060 C0F20003 		movt	r3, #:upper16:xSecondaryCycles
 891 0064 1A68     		ldr	r2, [r3, #0]
 892 0066 40F20003 		movw	r3, #:lower16:xLastSecondaryCycleCount.7682
 893 006a C0F20003 		movt	r3, #:upper16:xLastSecondaryCycleCount.7682
 894 006e 1A60     		str	r2, [r3, #0]
 502:App/Common/Minimal/blocktim.c **** 	xLastPrimaryCycleCount = xPrimaryCycles;
 895              		.loc 1 502 0
 896 0070 40F20003 		movw	r3, #:lower16:xPrimaryCycles
 897 0074 C0F20003 		movt	r3, #:upper16:xPrimaryCycles
 898 0078 1A68     		ldr	r2, [r3, #0]
 899 007a 40F20003 		movw	r3, #:lower16:xLastPrimaryCycleCount.7681
 900 007e C0F20003 		movt	r3, #:upper16:xLastPrimaryCycleCount.7681
 901 0082 1A60     		str	r2, [r3, #0]
 503:App/Common/Minimal/blocktim.c **** 
 504:App/Common/Minimal/blocktim.c **** 	return xReturn;
 902              		.loc 1 504 0
 903 0084 7B68     		ldr	r3, [r7, #4]
 505:App/Common/Minimal/blocktim.c **** }
 904              		.loc 1 505 0
 905 0086 1846     		mov	r0, r3
 906 0088 07F10C07 		add	r7, r7, #12
 907 008c BD46     		mov	sp, r7
 908 008e 80BC     		pop	{r7}
 909 0090 7047     		bx	lr
 910              		.cfi_endproc
 911              	.LFE113:
 913 0092 00BF     		.section	.bss.xLastPrimaryCycleCount.7681,"aw",%nobits
 914              		.align	2
 917              	xLastPrimaryCycleCount.7681:
 918 0000 00000000 		.space	4
 919              		.section	.bss.xLastSecondaryCycleCount.7682,"aw",%nobits
 920              		.align	2
 923              	xLastSecondaryCycleCount.7682:
 924 0000 00000000 		.space	4
 925              		.text
 926              	.Letext0:
 927              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 928              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 929              		.file 4 "Source/include/task.h"
 930              		.file 5 "Source/include/queue.h"
 931              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 blocktim.c
     /tmp/ccLq47Gm.s:20     .bss.xTestQueue:00000000 $d
     /tmp/ccLq47Gm.s:23     .bss.xTestQueue:00000000 xTestQueue
     /tmp/ccLq47Gm.s:26     .bss.xSecondary:00000000 $d
     /tmp/ccLq47Gm.s:29     .bss.xSecondary:00000000 xSecondary
     /tmp/ccLq47Gm.s:32     .bss.xPrimaryCycles:00000000 $d
     /tmp/ccLq47Gm.s:35     .bss.xPrimaryCycles:00000000 xPrimaryCycles
     /tmp/ccLq47Gm.s:38     .bss.xSecondaryCycles:00000000 $d
     /tmp/ccLq47Gm.s:41     .bss.xSecondaryCycles:00000000 xSecondaryCycles
     /tmp/ccLq47Gm.s:44     .bss.xErrorOccurred:00000000 $d
     /tmp/ccLq47Gm.s:47     .bss.xErrorOccurred:00000000 xErrorOccurred
     /tmp/ccLq47Gm.s:50     .bss.xRunIndicator:00000000 $d
     /tmp/ccLq47Gm.s:53     .bss.xRunIndicator:00000000 xRunIndicator
     /tmp/ccLq47Gm.s:56     .rodata:00000000 $d
     /tmp/ccLq47Gm.s:57     .rodata:00000000 .LC0
     /tmp/ccLq47Gm.s:60     .rodata:00000014 .LC1
     /tmp/ccLq47Gm.s:63     .rodata:0000001c .LC2
     /tmp/ccLq47Gm.s:66     .text.vCreateBlockTimeTasks:00000000 $t
     /tmp/ccLq47Gm.s:71     .text.vCreateBlockTimeTasks:00000000 vCreateBlockTimeTasks
     /tmp/ccLq47Gm.s:150    .text.vPrimaryBlockTimeTestTask:00000000 vPrimaryBlockTimeTestTask
     /tmp/ccLq47Gm.s:669    .text.vSecondaryBlockTimeTestTask:00000000 vSecondaryBlockTimeTestTask
     /tmp/ccLq47Gm.s:146    .text.vPrimaryBlockTimeTestTask:00000000 $t
     /tmp/ccLq47Gm.s:665    .text.vSecondaryBlockTimeTestTask:00000000 $t
     /tmp/ccLq47Gm.s:827    .text.xAreBlockTimeTestTasksStillRunning:00000000 $t
     /tmp/ccLq47Gm.s:832    .text.xAreBlockTimeTestTasksStillRunning:00000000 xAreBlockTimeTestTasksStillRunning
     /tmp/ccLq47Gm.s:917    .bss.xLastPrimaryCycleCount.7681:00000000 xLastPrimaryCycleCount.7681
     /tmp/ccLq47Gm.s:923    .bss.xLastSecondaryCycleCount.7682:00000000 xLastSecondaryCycleCount.7682
     /tmp/ccLq47Gm.s:914    .bss.xLastPrimaryCycleCount.7681:00000000 $d
     /tmp/ccLq47Gm.s:920    .bss.xLastSecondaryCycleCount.7682:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericCreate
vQueueAddToRegistry
xTaskGenericCreate
xTaskGetTickCount
xQueueGenericReceive
xQueueGenericSend
vTaskResume
vTaskDelay
vTaskPrioritySet
vTaskSuspend
