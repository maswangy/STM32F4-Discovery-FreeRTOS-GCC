   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"PollQ.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xPollingConsumerCount,"aw",%nobits
  20              		.align	2
  23              	xPollingConsumerCount:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xPollingProducerCount,"aw",%nobits
  26              		.align	2
  29              	xPollingProducerCount:
  30 0000 00000000 		.space	4
  31              		.section	.rodata
  32              		.align	2
  33              	.LC0:
  34 0000 506F6C6C 		.ascii	"Poll_Test_Queue\000"
  34      5F546573 
  34      745F5175 
  34      65756500 
  35              		.align	2
  36              	.LC1:
  37 0010 51436F6E 		.ascii	"QConsNB\000"
  37      734E4200 
  38              		.align	2
  39              	.LC2:
  40 0018 5150726F 		.ascii	"QProdNB\000"
  40      644E4200 
  41              		.section	.text.vStartPolledQueueTasks,"ax",%progbits
  42              		.align	2
  43              		.global	vStartPolledQueueTasks
  44              		.thumb
  45              		.thumb_func
  47              	vStartPolledQueueTasks:
  48              	.LFB110:
  49              		.file 1 "App/Common/Minimal/PollQ.c"
   1:App/Common/Minimal/PollQ.c **** /*
   2:App/Common/Minimal/PollQ.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/PollQ.c ****     All rights reserved
   4:App/Common/Minimal/PollQ.c **** 
   5:App/Common/Minimal/PollQ.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/PollQ.c **** 
   7:App/Common/Minimal/PollQ.c ****     ***************************************************************************
   8:App/Common/Minimal/PollQ.c ****      *                                                                       *
   9:App/Common/Minimal/PollQ.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/PollQ.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/PollQ.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/PollQ.c ****      *                                                                       *
  13:App/Common/Minimal/PollQ.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/PollQ.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/PollQ.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/PollQ.c ****      *                                                                       *
  17:App/Common/Minimal/PollQ.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/PollQ.c ****      *                                                                       *
  19:App/Common/Minimal/PollQ.c ****     ***************************************************************************
  20:App/Common/Minimal/PollQ.c **** 
  21:App/Common/Minimal/PollQ.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/PollQ.c **** 
  23:App/Common/Minimal/PollQ.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/PollQ.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/PollQ.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/PollQ.c **** 
  27:App/Common/Minimal/PollQ.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/PollQ.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/PollQ.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/PollQ.c ****     >>! kernel.
  31:App/Common/Minimal/PollQ.c **** 
  32:App/Common/Minimal/PollQ.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/PollQ.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/PollQ.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/PollQ.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/PollQ.c **** 
  37:App/Common/Minimal/PollQ.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/PollQ.c **** 
  39:App/Common/Minimal/PollQ.c ****     ***************************************************************************
  40:App/Common/Minimal/PollQ.c ****      *                                                                       *
  41:App/Common/Minimal/PollQ.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/PollQ.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/PollQ.c ****      *                                                                       *
  44:App/Common/Minimal/PollQ.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/PollQ.c ****      *                                                                       *
  46:App/Common/Minimal/PollQ.c ****     ***************************************************************************
  47:App/Common/Minimal/PollQ.c **** 
  48:App/Common/Minimal/PollQ.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/PollQ.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/PollQ.c **** 
  51:App/Common/Minimal/PollQ.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/PollQ.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/PollQ.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/PollQ.c **** 
  55:App/Common/Minimal/PollQ.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/PollQ.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/PollQ.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/PollQ.c **** 
  59:App/Common/Minimal/PollQ.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/PollQ.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/PollQ.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/PollQ.c **** 
  63:App/Common/Minimal/PollQ.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/PollQ.c **** */
  65:App/Common/Minimal/PollQ.c **** 
  66:App/Common/Minimal/PollQ.c **** /*
  67:App/Common/Minimal/PollQ.c ****  * This version of PollQ. c is for use on systems that have limited stack
  68:App/Common/Minimal/PollQ.c ****  * space and no display facilities.  The complete version can be found in
  69:App/Common/Minimal/PollQ.c ****  * the Demo/Common/Full directory.
  70:App/Common/Minimal/PollQ.c ****  *
  71:App/Common/Minimal/PollQ.c ****  * Creates two tasks that communicate over a single queue.  One task acts as a
  72:App/Common/Minimal/PollQ.c ****  * producer, the other a consumer.
  73:App/Common/Minimal/PollQ.c ****  *
  74:App/Common/Minimal/PollQ.c ****  * The producer loops for three iteration, posting an incrementing number onto the
  75:App/Common/Minimal/PollQ.c ****  * queue each cycle.  It then delays for a fixed period before doing exactly the
  76:App/Common/Minimal/PollQ.c ****  * same again.
  77:App/Common/Minimal/PollQ.c ****  *
  78:App/Common/Minimal/PollQ.c ****  * The consumer loops emptying the queue.  Each item removed from the queue is
  79:App/Common/Minimal/PollQ.c ****  * checked to ensure it contains the expected value.  When the queue is empty it
  80:App/Common/Minimal/PollQ.c ****  * blocks for a fixed period, then does the same again.
  81:App/Common/Minimal/PollQ.c ****  *
  82:App/Common/Minimal/PollQ.c ****  * All queue access is performed without blocking.  The consumer completely empties
  83:App/Common/Minimal/PollQ.c ****  * the queue each time it runs so the producer should never find the queue full.
  84:App/Common/Minimal/PollQ.c ****  *
  85:App/Common/Minimal/PollQ.c ****  * An error is flagged if the consumer obtains an unexpected value or the producer
  86:App/Common/Minimal/PollQ.c ****  * find the queue is full.
  87:App/Common/Minimal/PollQ.c ****  */
  88:App/Common/Minimal/PollQ.c **** 
  89:App/Common/Minimal/PollQ.c **** /*
  90:App/Common/Minimal/PollQ.c **** Changes from V2.0.0
  91:App/Common/Minimal/PollQ.c **** 
  92:App/Common/Minimal/PollQ.c **** 	+ Delay periods are now specified using variables and constants of
  93:App/Common/Minimal/PollQ.c **** 	  portTickType rather than unsigned long.
  94:App/Common/Minimal/PollQ.c **** */
  95:App/Common/Minimal/PollQ.c **** 
  96:App/Common/Minimal/PollQ.c **** #include <stdlib.h>
  97:App/Common/Minimal/PollQ.c **** 
  98:App/Common/Minimal/PollQ.c **** /* Scheduler include files. */
  99:App/Common/Minimal/PollQ.c **** #include "FreeRTOS.h"
 100:App/Common/Minimal/PollQ.c **** #include "task.h"
 101:App/Common/Minimal/PollQ.c **** #include "queue.h"
 102:App/Common/Minimal/PollQ.c **** 
 103:App/Common/Minimal/PollQ.c **** /* Demo program include files. */
 104:App/Common/Minimal/PollQ.c **** #include "PollQ.h"
 105:App/Common/Minimal/PollQ.c **** 
 106:App/Common/Minimal/PollQ.c **** #define pollqSTACK_SIZE			configMINIMAL_STACK_SIZE
 107:App/Common/Minimal/PollQ.c **** #define pollqQUEUE_SIZE			( 10 )
 108:App/Common/Minimal/PollQ.c **** #define pollqPRODUCER_DELAY		( ( portTickType ) 200 / portTICK_RATE_MS )
 109:App/Common/Minimal/PollQ.c **** #define pollqCONSUMER_DELAY		( pollqPRODUCER_DELAY - ( portTickType ) ( 20 / portTICK_RATE_MS ) )
 110:App/Common/Minimal/PollQ.c **** #define pollqNO_DELAY			( ( portTickType ) 0 )
 111:App/Common/Minimal/PollQ.c **** #define pollqVALUES_TO_PRODUCE	( ( signed portBASE_TYPE ) 3 )
 112:App/Common/Minimal/PollQ.c **** #define pollqINITIAL_VALUE		( ( signed portBASE_TYPE ) 0 )
 113:App/Common/Minimal/PollQ.c **** 
 114:App/Common/Minimal/PollQ.c **** /* The task that posts the incrementing number onto the queue. */
 115:App/Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueProducer, pvParameters );
 116:App/Common/Minimal/PollQ.c **** 
 117:App/Common/Minimal/PollQ.c **** /* The task that empties the queue. */
 118:App/Common/Minimal/PollQ.c **** static portTASK_FUNCTION_PROTO( vPolledQueueConsumer, pvParameters );
 119:App/Common/Minimal/PollQ.c **** 
 120:App/Common/Minimal/PollQ.c **** /* Variables that are used to check that the tasks are still running with no
 121:App/Common/Minimal/PollQ.c **** errors. */
 122:App/Common/Minimal/PollQ.c **** static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCo
 123:App/Common/Minimal/PollQ.c **** 
 124:App/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 125:App/Common/Minimal/PollQ.c **** 
 126:App/Common/Minimal/PollQ.c **** void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
 127:App/Common/Minimal/PollQ.c **** {
  50              		.loc 1 127 0
  51              		.cfi_startproc
  52              		@ args = 0, pretend = 0, frame = 8
  53              		@ frame_needed = 1, uses_anonymous_args = 0
  54 0000 80B5     		push	{r7, lr}
  55              	.LCFI0:
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 86B0     		sub	sp, sp, #24
  60              	.LCFI1:
  61              		.cfi_def_cfa_offset 32
  62 0004 04AF     		add	r7, sp, #16
  63              	.LCFI2:
  64              		.cfi_def_cfa 7, 16
  65 0006 7860     		str	r0, [r7, #4]
 128:App/Common/Minimal/PollQ.c **** static xQueueHandle xPolledQueue;
 129:App/Common/Minimal/PollQ.c **** 
 130:App/Common/Minimal/PollQ.c **** 	/* Create the queue used by the producer and consumer. */
 131:App/Common/Minimal/PollQ.c **** 	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) 
  66              		.loc 1 131 0
  67 0008 4FF00A00 		mov	r0, #10
  68 000c 4FF00201 		mov	r1, #2
  69 0010 4FF00002 		mov	r2, #0
  70 0014 FFF7FEFF 		bl	xQueueGenericCreate
  71 0018 0246     		mov	r2, r0
  72 001a 40F20003 		movw	r3, #:lower16:xPolledQueue.8199
  73 001e C0F20003 		movt	r3, #:upper16:xPolledQueue.8199
  74 0022 1A60     		str	r2, [r3, #0]
 132:App/Common/Minimal/PollQ.c **** 
 133:App/Common/Minimal/PollQ.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 134:App/Common/Minimal/PollQ.c **** 	in use.  The queue registry is provided as a means for kernel aware 
 135:App/Common/Minimal/PollQ.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 136:App/Common/Minimal/PollQ.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 137:App/Common/Minimal/PollQ.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 138:App/Common/Minimal/PollQ.c **** 	defined to be less than 1. */
 139:App/Common/Minimal/PollQ.c **** 	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );
  75              		.loc 1 139 0
  76 0024 40F20003 		movw	r3, #:lower16:xPolledQueue.8199
  77 0028 C0F20003 		movt	r3, #:upper16:xPolledQueue.8199
  78 002c 1B68     		ldr	r3, [r3, #0]
  79 002e 1846     		mov	r0, r3
  80 0030 40F20001 		movw	r1, #:lower16:.LC0
  81 0034 C0F20001 		movt	r1, #:upper16:.LC0
  82 0038 FFF7FEFF 		bl	vQueueAddToRegistry
 140:App/Common/Minimal/PollQ.c **** 
 141:App/Common/Minimal/PollQ.c **** 	/* Spawn the producer and consumer. */
 142:App/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPoll
  83              		.loc 1 142 0
  84 003c 7B68     		ldr	r3, [r7, #4]
  85 003e 0093     		str	r3, [sp, #0]
  86 0040 4FF00003 		mov	r3, #0
  87 0044 0193     		str	r3, [sp, #4]
  88 0046 4FF00003 		mov	r3, #0
  89 004a 0293     		str	r3, [sp, #8]
  90 004c 4FF00003 		mov	r3, #0
  91 0050 0393     		str	r3, [sp, #12]
  92 0052 40F20000 		movw	r0, #:lower16:vPolledQueueConsumer
  93 0056 C0F20000 		movt	r0, #:upper16:vPolledQueueConsumer
  94 005a 40F20001 		movw	r1, #:lower16:.LC1
  95 005e C0F20001 		movt	r1, #:upper16:.LC1
  96 0062 4FF08202 		mov	r2, #130
  97 0066 40F20003 		movw	r3, #:lower16:xPolledQueue.8199
  98 006a C0F20003 		movt	r3, #:upper16:xPolledQueue.8199
  99 006e FFF7FEFF 		bl	xTaskGenericCreate
 143:App/Common/Minimal/PollQ.c **** 	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPoll
 100              		.loc 1 143 0
 101 0072 7B68     		ldr	r3, [r7, #4]
 102 0074 0093     		str	r3, [sp, #0]
 103 0076 4FF00003 		mov	r3, #0
 104 007a 0193     		str	r3, [sp, #4]
 105 007c 4FF00003 		mov	r3, #0
 106 0080 0293     		str	r3, [sp, #8]
 107 0082 4FF00003 		mov	r3, #0
 108 0086 0393     		str	r3, [sp, #12]
 109 0088 40F20000 		movw	r0, #:lower16:vPolledQueueProducer
 110 008c C0F20000 		movt	r0, #:upper16:vPolledQueueProducer
 111 0090 40F20001 		movw	r1, #:lower16:.LC2
 112 0094 C0F20001 		movt	r1, #:upper16:.LC2
 113 0098 4FF08202 		mov	r2, #130
 114 009c 40F20003 		movw	r3, #:lower16:xPolledQueue.8199
 115 00a0 C0F20003 		movt	r3, #:upper16:xPolledQueue.8199
 116 00a4 FFF7FEFF 		bl	xTaskGenericCreate
 144:App/Common/Minimal/PollQ.c **** }
 117              		.loc 1 144 0
 118 00a8 07F10807 		add	r7, r7, #8
 119 00ac BD46     		mov	sp, r7
 120 00ae 80BD     		pop	{r7, pc}
 121              		.cfi_endproc
 122              	.LFE110:
 124              		.section	.text.vPolledQueueProducer,"ax",%progbits
 125              		.align	2
 126              		.thumb
 127              		.thumb_func
 129              	vPolledQueueProducer:
 130              	.LFB111:
 145:App/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 146:App/Common/Minimal/PollQ.c **** 
 147:App/Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
 148:App/Common/Minimal/PollQ.c **** {
 131              		.loc 1 148 0
 132              		.cfi_startproc
 133              		@ args = 0, pretend = 0, frame = 24
 134              		@ frame_needed = 1, uses_anonymous_args = 0
 135 0000 80B5     		push	{r7, lr}
 136              	.LCFI3:
 137              		.cfi_def_cfa_offset 8
 138              		.cfi_offset 7, -8
 139              		.cfi_offset 14, -4
 140 0002 86B0     		sub	sp, sp, #24
 141              	.LCFI4:
 142              		.cfi_def_cfa_offset 32
 143 0004 00AF     		add	r7, sp, #0
 144              	.LCFI5:
 145              		.cfi_def_cfa_register 7
 146 0006 7860     		str	r0, [r7, #4]
 149:App/Common/Minimal/PollQ.c **** unsigned short usValue = ( unsigned short ) 0;
 147              		.loc 1 149 0
 148 0008 4FF00003 		mov	r3, #0
 149 000c FB81     		strh	r3, [r7, #14]	@ movhi
 150:App/Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE, xLoop;
 150              		.loc 1 150 0
 151 000e 4FF00003 		mov	r3, #0
 152 0012 7B61     		str	r3, [r7, #20]
 153              	.L8:
 151:App/Common/Minimal/PollQ.c **** 
 152:App/Common/Minimal/PollQ.c **** 	for( ;; )
 153:App/Common/Minimal/PollQ.c **** 	{		
 154:App/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 154              		.loc 1 154 0
 155 0014 4FF00003 		mov	r3, #0
 156 0018 3B61     		str	r3, [r7, #16]
 157 001a 2EE0     		b	.L3
 158              	.L7:
 155:App/Common/Minimal/PollQ.c **** 		{
 156:App/Common/Minimal/PollQ.c **** 			/* Send an incrementing number on the queue without blocking. */
 157:App/Common/Minimal/PollQ.c **** 			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pd
 159              		.loc 1 157 0
 160 001c 7B68     		ldr	r3, [r7, #4]
 161 001e 1A68     		ldr	r2, [r3, #0]
 162 0020 07F10E03 		add	r3, r7, #14
 163 0024 1046     		mov	r0, r2
 164 0026 1946     		mov	r1, r3
 165 0028 4FF00002 		mov	r2, #0
 166 002c 4FF00003 		mov	r3, #0
 167 0030 FFF7FEFF 		bl	xQueueGenericSend
 168 0034 0346     		mov	r3, r0
 169 0036 012B     		cmp	r3, #1
 170 0038 03D0     		beq	.L4
 158:App/Common/Minimal/PollQ.c **** 			{
 159:App/Common/Minimal/PollQ.c **** 				/* We should never find the queue full so if we get here there
 160:App/Common/Minimal/PollQ.c **** 				has been an error. */
 161:App/Common/Minimal/PollQ.c **** 				xError = pdTRUE;
 171              		.loc 1 161 0
 172 003a 4FF00103 		mov	r3, #1
 173 003e 7B61     		str	r3, [r7, #20]
 174 0040 17E0     		b	.L5
 175              	.L4:
 162:App/Common/Minimal/PollQ.c **** 			}
 163:App/Common/Minimal/PollQ.c **** 			else
 164:App/Common/Minimal/PollQ.c **** 			{
 165:App/Common/Minimal/PollQ.c **** 				if( xError == pdFALSE )
 176              		.loc 1 165 0
 177 0042 7B69     		ldr	r3, [r7, #20]
 178 0044 002B     		cmp	r3, #0
 179 0046 0FD1     		bne	.L6
 166:App/Common/Minimal/PollQ.c **** 				{
 167:App/Common/Minimal/PollQ.c **** 					/* If an error has ever been recorded we stop incrementing the
 168:App/Common/Minimal/PollQ.c **** 					check variable. */
 169:App/Common/Minimal/PollQ.c **** 					portENTER_CRITICAL();
 180              		.loc 1 169 0
 181 0048 FFF7FEFF 		bl	vPortEnterCritical
 170:App/Common/Minimal/PollQ.c **** 						xPollingProducerCount++;
 182              		.loc 1 170 0
 183 004c 40F20003 		movw	r3, #:lower16:xPollingProducerCount
 184 0050 C0F20003 		movt	r3, #:upper16:xPollingProducerCount
 185 0054 1B68     		ldr	r3, [r3, #0]
 186 0056 03F10102 		add	r2, r3, #1
 187 005a 40F20003 		movw	r3, #:lower16:xPollingProducerCount
 188 005e C0F20003 		movt	r3, #:upper16:xPollingProducerCount
 189 0062 1A60     		str	r2, [r3, #0]
 171:App/Common/Minimal/PollQ.c **** 					portEXIT_CRITICAL();
 190              		.loc 1 171 0
 191 0064 FFF7FEFF 		bl	vPortExitCritical
 192              	.L6:
 172:App/Common/Minimal/PollQ.c **** 				}
 173:App/Common/Minimal/PollQ.c **** 
 174:App/Common/Minimal/PollQ.c **** 				/* Update the value we are going to post next time around. */
 175:App/Common/Minimal/PollQ.c **** 				usValue++;
 193              		.loc 1 175 0
 194 0068 FB89     		ldrh	r3, [r7, #14]
 195 006a 03F10103 		add	r3, r3, #1
 196 006e 9BB2     		uxth	r3, r3
 197 0070 FB81     		strh	r3, [r7, #14]	@ movhi
 198              	.L5:
 154:App/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 199              		.loc 1 154 0
 200 0072 3B69     		ldr	r3, [r7, #16]
 201 0074 03F10103 		add	r3, r3, #1
 202 0078 3B61     		str	r3, [r7, #16]
 203              	.L3:
 154:App/Common/Minimal/PollQ.c **** 		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 204              		.loc 1 154 0 is_stmt 0 discriminator 1
 205 007a 3B69     		ldr	r3, [r7, #16]
 206 007c 022B     		cmp	r3, #2
 207 007e CDDD     		ble	.L7
 176:App/Common/Minimal/PollQ.c **** 			}
 177:App/Common/Minimal/PollQ.c **** 		}
 178:App/Common/Minimal/PollQ.c **** 
 179:App/Common/Minimal/PollQ.c **** 		/* Wait before we start posting again to ensure the consumer runs and
 180:App/Common/Minimal/PollQ.c **** 		empties the queue. */
 181:App/Common/Minimal/PollQ.c **** 		vTaskDelay( pollqPRODUCER_DELAY );
 208              		.loc 1 181 0 is_stmt 1
 209 0080 4FF0C800 		mov	r0, #200
 210 0084 FFF7FEFF 		bl	vTaskDelay
 182:App/Common/Minimal/PollQ.c **** 	}
 211              		.loc 1 182 0
 212 0088 C4E7     		b	.L8
 213              		.cfi_endproc
 214              	.LFE111:
 216 008a 00BF     		.section	.text.vPolledQueueConsumer,"ax",%progbits
 217              		.align	2
 218              		.thumb
 219              		.thumb_func
 221              	vPolledQueueConsumer:
 222              	.LFB112:
 183:App/Common/Minimal/PollQ.c **** }  /*lint !e818 Function prototype must conform to API. */
 184:App/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 185:App/Common/Minimal/PollQ.c **** 
 186:App/Common/Minimal/PollQ.c **** static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
 187:App/Common/Minimal/PollQ.c **** {
 223              		.loc 1 187 0
 224              		.cfi_startproc
 225              		@ args = 0, pretend = 0, frame = 24
 226              		@ frame_needed = 1, uses_anonymous_args = 0
 227 0000 80B5     		push	{r7, lr}
 228              	.LCFI6:
 229              		.cfi_def_cfa_offset 8
 230              		.cfi_offset 7, -8
 231              		.cfi_offset 14, -4
 232 0002 86B0     		sub	sp, sp, #24
 233              	.LCFI7:
 234              		.cfi_def_cfa_offset 32
 235 0004 00AF     		add	r7, sp, #0
 236              	.LCFI8:
 237              		.cfi_def_cfa_register 7
 238 0006 7860     		str	r0, [r7, #4]
 188:App/Common/Minimal/PollQ.c **** unsigned short usData, usExpectedValue = ( unsigned short ) 0;
 239              		.loc 1 188 0
 240 0008 4FF00003 		mov	r3, #0
 241 000c FB82     		strh	r3, [r7, #22]	@ movhi
 189:App/Common/Minimal/PollQ.c **** signed portBASE_TYPE xError = pdFALSE;
 242              		.loc 1 189 0
 243 000e 4FF00003 		mov	r3, #0
 244 0012 3B61     		str	r3, [r7, #16]
 190:App/Common/Minimal/PollQ.c **** 
 191:App/Common/Minimal/PollQ.c **** 	for( ;; )
 192:App/Common/Minimal/PollQ.c **** 	{		
 193:App/Common/Minimal/PollQ.c **** 		/* Loop until the queue is empty. */
 194:App/Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 245              		.loc 1 194 0
 246 0014 2FE0     		b	.L10
 247              	.L13:
 195:App/Common/Minimal/PollQ.c **** 		{
 196:App/Common/Minimal/PollQ.c **** 			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 248              		.loc 1 196 0
 249 0016 7B68     		ldr	r3, [r7, #4]
 250 0018 1A68     		ldr	r2, [r3, #0]
 251 001a 07F10E03 		add	r3, r7, #14
 252 001e 1046     		mov	r0, r2
 253 0020 1946     		mov	r1, r3
 254 0022 4FF00002 		mov	r2, #0
 255 0026 4FF00003 		mov	r3, #0
 256 002a FFF7FEFF 		bl	xQueueGenericReceive
 257 002e 0346     		mov	r3, r0
 258 0030 012B     		cmp	r3, #1
 259 0032 20D1     		bne	.L10
 197:App/Common/Minimal/PollQ.c **** 			{
 198:App/Common/Minimal/PollQ.c **** 				if( usData != usExpectedValue )
 260              		.loc 1 198 0
 261 0034 FB89     		ldrh	r3, [r7, #14]
 262 0036 FA8A     		ldrh	r2, [r7, #22]
 263 0038 9A42     		cmp	r2, r3
 264 003a 05D0     		beq	.L11
 199:App/Common/Minimal/PollQ.c **** 				{
 200:App/Common/Minimal/PollQ.c **** 					/* This is not what we expected to receive so an error has
 201:App/Common/Minimal/PollQ.c **** 					occurred. */
 202:App/Common/Minimal/PollQ.c **** 					xError = pdTRUE;
 265              		.loc 1 202 0
 266 003c 4FF00103 		mov	r3, #1
 267 0040 3B61     		str	r3, [r7, #16]
 203:App/Common/Minimal/PollQ.c **** 
 204:App/Common/Minimal/PollQ.c **** 					/* Catch-up to the value we received so our next expected
 205:App/Common/Minimal/PollQ.c **** 					value should again be correct. */
 206:App/Common/Minimal/PollQ.c **** 					usExpectedValue = usData;
 268              		.loc 1 206 0
 269 0042 FB89     		ldrh	r3, [r7, #14]	@ movhi
 270 0044 FB82     		strh	r3, [r7, #22]	@ movhi
 271 0046 12E0     		b	.L12
 272              	.L11:
 207:App/Common/Minimal/PollQ.c **** 				}
 208:App/Common/Minimal/PollQ.c **** 				else
 209:App/Common/Minimal/PollQ.c **** 				{
 210:App/Common/Minimal/PollQ.c **** 					if( xError == pdFALSE )
 273              		.loc 1 210 0
 274 0048 3B69     		ldr	r3, [r7, #16]
 275 004a 002B     		cmp	r3, #0
 276 004c 0FD1     		bne	.L12
 211:App/Common/Minimal/PollQ.c **** 					{
 212:App/Common/Minimal/PollQ.c **** 						/* Only increment the check variable if no errors have
 213:App/Common/Minimal/PollQ.c **** 						occurred. */
 214:App/Common/Minimal/PollQ.c **** 						portENTER_CRITICAL();
 277              		.loc 1 214 0
 278 004e FFF7FEFF 		bl	vPortEnterCritical
 215:App/Common/Minimal/PollQ.c **** 							xPollingConsumerCount++;
 279              		.loc 1 215 0
 280 0052 40F20003 		movw	r3, #:lower16:xPollingConsumerCount
 281 0056 C0F20003 		movt	r3, #:upper16:xPollingConsumerCount
 282 005a 1B68     		ldr	r3, [r3, #0]
 283 005c 03F10102 		add	r2, r3, #1
 284 0060 40F20003 		movw	r3, #:lower16:xPollingConsumerCount
 285 0064 C0F20003 		movt	r3, #:upper16:xPollingConsumerCount
 286 0068 1A60     		str	r2, [r3, #0]
 216:App/Common/Minimal/PollQ.c **** 						portEXIT_CRITICAL();
 287              		.loc 1 216 0
 288 006a FFF7FEFF 		bl	vPortExitCritical
 289              	.L12:
 217:App/Common/Minimal/PollQ.c **** 					}
 218:App/Common/Minimal/PollQ.c **** 				}
 219:App/Common/Minimal/PollQ.c **** 
 220:App/Common/Minimal/PollQ.c **** 				/* Next time round we would expect the number to be one higher. */
 221:App/Common/Minimal/PollQ.c **** 				usExpectedValue++;
 290              		.loc 1 221 0
 291 006e FB8A     		ldrh	r3, [r7, #22]	@ movhi
 292 0070 03F10103 		add	r3, r3, #1
 293 0074 FB82     		strh	r3, [r7, #22]	@ movhi
 294              	.L10:
 194:App/Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 295              		.loc 1 194 0 discriminator 1
 296 0076 7B68     		ldr	r3, [r7, #4]
 297 0078 1B68     		ldr	r3, [r3, #0]
 298 007a 1846     		mov	r0, r3
 299 007c FFF7FEFF 		bl	uxQueueMessagesWaiting
 300 0080 0346     		mov	r3, r0
 301 0082 002B     		cmp	r3, #0
 302 0084 C7D1     		bne	.L13
 222:App/Common/Minimal/PollQ.c **** 			}
 223:App/Common/Minimal/PollQ.c **** 		}
 224:App/Common/Minimal/PollQ.c **** 
 225:App/Common/Minimal/PollQ.c **** 		/* Now the queue is empty we block, allowing the producer to place more
 226:App/Common/Minimal/PollQ.c **** 		items in the queue. */
 227:App/Common/Minimal/PollQ.c **** 		vTaskDelay( pollqCONSUMER_DELAY );
 303              		.loc 1 227 0
 304 0086 4FF0B400 		mov	r0, #180
 305 008a FFF7FEFF 		bl	vTaskDelay
 228:App/Common/Minimal/PollQ.c **** 	}
 306              		.loc 1 228 0
 307 008e 00BF     		nop
 194:App/Common/Minimal/PollQ.c **** 		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
 308              		.loc 1 194 0
 309 0090 F1E7     		b	.L10
 310              		.cfi_endproc
 311              	.LFE112:
 313 0092 00BF     		.section	.text.xArePollingQueuesStillRunning,"ax",%progbits
 314              		.align	2
 315              		.global	xArePollingQueuesStillRunning
 316              		.thumb
 317              		.thumb_func
 319              	xArePollingQueuesStillRunning:
 320              	.LFB113:
 229:App/Common/Minimal/PollQ.c **** } /*lint !e818 Function prototype must conform to API. */
 230:App/Common/Minimal/PollQ.c **** /*-----------------------------------------------------------*/
 231:App/Common/Minimal/PollQ.c **** 
 232:App/Common/Minimal/PollQ.c **** /* This is called to check that all the created tasks are still running with no errors. */
 233:App/Common/Minimal/PollQ.c **** portBASE_TYPE xArePollingQueuesStillRunning( void )
 234:App/Common/Minimal/PollQ.c **** {
 321              		.loc 1 234 0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 8
 324              		@ frame_needed = 1, uses_anonymous_args = 0
 325              		@ link register save eliminated.
 326 0000 80B4     		push	{r7}
 327              	.LCFI9:
 328              		.cfi_def_cfa_offset 4
 329              		.cfi_offset 7, -4
 330 0002 83B0     		sub	sp, sp, #12
 331              	.LCFI10:
 332              		.cfi_def_cfa_offset 16
 333 0004 00AF     		add	r7, sp, #0
 334              	.LCFI11:
 335              		.cfi_def_cfa_register 7
 235:App/Common/Minimal/PollQ.c **** portBASE_TYPE xReturn;
 236:App/Common/Minimal/PollQ.c **** 
 237:App/Common/Minimal/PollQ.c **** 	/* Check both the consumer and producer poll count to check they have both
 238:App/Common/Minimal/PollQ.c **** 	been changed since out last trip round.  We do not need a critical section
 239:App/Common/Minimal/PollQ.c **** 	around the check variables as this is called from a higher priority than
 240:App/Common/Minimal/PollQ.c **** 	the other tasks that access the same variables. */
 241:App/Common/Minimal/PollQ.c **** 	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 336              		.loc 1 241 0
 337 0006 40F20003 		movw	r3, #:lower16:xPollingConsumerCount
 338 000a C0F20003 		movt	r3, #:upper16:xPollingConsumerCount
 339 000e 1B68     		ldr	r3, [r3, #0]
 340 0010 002B     		cmp	r3, #0
 341 0012 06D0     		beq	.L16
 242:App/Common/Minimal/PollQ.c **** 		( xPollingProducerCount == pollqINITIAL_VALUE )
 342              		.loc 1 242 0 discriminator 1
 343 0014 40F20003 		movw	r3, #:lower16:xPollingProducerCount
 344 0018 C0F20003 		movt	r3, #:upper16:xPollingProducerCount
 345 001c 1B68     		ldr	r3, [r3, #0]
 241:App/Common/Minimal/PollQ.c **** 	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 346              		.loc 1 241 0 discriminator 1
 347 001e 002B     		cmp	r3, #0
 348 0020 03D1     		bne	.L17
 349              	.L16:
 243:App/Common/Minimal/PollQ.c **** 	  )
 244:App/Common/Minimal/PollQ.c **** 	{
 245:App/Common/Minimal/PollQ.c **** 		xReturn = pdFALSE;
 350              		.loc 1 245 0
 351 0022 4FF00003 		mov	r3, #0
 352 0026 7B60     		str	r3, [r7, #4]
 353 0028 02E0     		b	.L18
 354              	.L17:
 246:App/Common/Minimal/PollQ.c **** 	}
 247:App/Common/Minimal/PollQ.c **** 	else
 248:App/Common/Minimal/PollQ.c **** 	{
 249:App/Common/Minimal/PollQ.c **** 		xReturn = pdTRUE;
 355              		.loc 1 249 0
 356 002a 4FF00103 		mov	r3, #1
 357 002e 7B60     		str	r3, [r7, #4]
 358              	.L18:
 250:App/Common/Minimal/PollQ.c **** 	}
 251:App/Common/Minimal/PollQ.c **** 
 252:App/Common/Minimal/PollQ.c **** 	/* Set the check variables back down so we know if they have been
 253:App/Common/Minimal/PollQ.c **** 	incremented the next time around. */
 254:App/Common/Minimal/PollQ.c **** 	xPollingConsumerCount = pollqINITIAL_VALUE;
 359              		.loc 1 254 0
 360 0030 40F20003 		movw	r3, #:lower16:xPollingConsumerCount
 361 0034 C0F20003 		movt	r3, #:upper16:xPollingConsumerCount
 362 0038 4FF00002 		mov	r2, #0
 363 003c 1A60     		str	r2, [r3, #0]
 255:App/Common/Minimal/PollQ.c **** 	xPollingProducerCount = pollqINITIAL_VALUE;
 364              		.loc 1 255 0
 365 003e 40F20003 		movw	r3, #:lower16:xPollingProducerCount
 366 0042 C0F20003 		movt	r3, #:upper16:xPollingProducerCount
 367 0046 4FF00002 		mov	r2, #0
 368 004a 1A60     		str	r2, [r3, #0]
 256:App/Common/Minimal/PollQ.c **** 
 257:App/Common/Minimal/PollQ.c **** 	return xReturn;
 369              		.loc 1 257 0
 370 004c 7B68     		ldr	r3, [r7, #4]
 258:App/Common/Minimal/PollQ.c **** }
 371              		.loc 1 258 0
 372 004e 1846     		mov	r0, r3
 373 0050 07F10C07 		add	r7, r7, #12
 374 0054 BD46     		mov	sp, r7
 375 0056 80BC     		pop	{r7}
 376 0058 7047     		bx	lr
 377              		.cfi_endproc
 378              	.LFE113:
 380 005a 00BF     		.section	.bss.xPolledQueue.8199,"aw",%nobits
 381              		.align	2
 384              	xPolledQueue.8199:
 385 0000 00000000 		.space	4
 386              		.text
 387              	.Letext0:
 388              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 389              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 390              		.file 4 "Source/include/task.h"
 391              		.file 5 "Source/include/queue.h"
 392              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 PollQ.c
     /tmp/ccPW5zE5.s:20     .bss.xPollingConsumerCount:00000000 $d
     /tmp/ccPW5zE5.s:23     .bss.xPollingConsumerCount:00000000 xPollingConsumerCount
     /tmp/ccPW5zE5.s:26     .bss.xPollingProducerCount:00000000 $d
     /tmp/ccPW5zE5.s:29     .bss.xPollingProducerCount:00000000 xPollingProducerCount
     /tmp/ccPW5zE5.s:32     .rodata:00000000 $d
     /tmp/ccPW5zE5.s:33     .rodata:00000000 .LC0
     /tmp/ccPW5zE5.s:36     .rodata:00000010 .LC1
     /tmp/ccPW5zE5.s:39     .rodata:00000018 .LC2
     /tmp/ccPW5zE5.s:42     .text.vStartPolledQueueTasks:00000000 $t
     /tmp/ccPW5zE5.s:47     .text.vStartPolledQueueTasks:00000000 vStartPolledQueueTasks
     /tmp/ccPW5zE5.s:384    .bss.xPolledQueue.8199:00000000 xPolledQueue.8199
     /tmp/ccPW5zE5.s:221    .text.vPolledQueueConsumer:00000000 vPolledQueueConsumer
     /tmp/ccPW5zE5.s:129    .text.vPolledQueueProducer:00000000 vPolledQueueProducer
     /tmp/ccPW5zE5.s:125    .text.vPolledQueueProducer:00000000 $t
     /tmp/ccPW5zE5.s:217    .text.vPolledQueueConsumer:00000000 $t
     /tmp/ccPW5zE5.s:314    .text.xArePollingQueuesStillRunning:00000000 $t
     /tmp/ccPW5zE5.s:319    .text.xArePollingQueuesStillRunning:00000000 xArePollingQueuesStillRunning
     /tmp/ccPW5zE5.s:381    .bss.xPolledQueue.8199:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericCreate
vQueueAddToRegistry
xTaskGenericCreate
xQueueGenericSend
vPortEnterCritical
vPortExitCritical
vTaskDelay
xQueueGenericReceive
uxQueueMessagesWaiting
