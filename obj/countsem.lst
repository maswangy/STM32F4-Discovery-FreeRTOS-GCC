   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"countsem.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xErrorDetected,"aw",%nobits
  20              		.align	2
  23              	xErrorDetected:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xParameters,"aw",%nobits
  26              		.align	2
  29              	xParameters:
  30 0000 00000000 		.space	24
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.rodata
  32              		.align	2
  33              	.LC0:
  34 0000 436F756E 		.ascii	"Counting_Sem_1\000"
  34      74696E67 
  34      5F53656D 
  34      5F3100
  35 000f 00       		.align	2
  36              	.LC1:
  37 0010 436F756E 		.ascii	"Counting_Sem_2\000"
  37      74696E67 
  37      5F53656D 
  37      5F3200
  38 001f 00       		.align	2
  39              	.LC2:
  40 0020 434E5431 		.ascii	"CNT1\000"
  40      00
  41 0025 000000   		.align	2
  42              	.LC3:
  43 0028 434E5432 		.ascii	"CNT2\000"
  43      00
  44 002d 000000   		.section	.text.vStartCountingSemaphoreTasks,"ax",%progbits
  45              		.align	2
  46              		.global	vStartCountingSemaphoreTasks
  47              		.thumb
  48              		.thumb_func
  50              	vStartCountingSemaphoreTasks:
  51              	.LFB110:
  52              		.file 1 "App/Common/Minimal/countsem.c"
   1:App/Common/Minimal/countsem.c **** /*
   2:App/Common/Minimal/countsem.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/countsem.c ****     All rights reserved
   4:App/Common/Minimal/countsem.c **** 
   5:App/Common/Minimal/countsem.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/countsem.c **** 
   7:App/Common/Minimal/countsem.c ****     ***************************************************************************
   8:App/Common/Minimal/countsem.c ****      *                                                                       *
   9:App/Common/Minimal/countsem.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/countsem.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/countsem.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/countsem.c ****      *                                                                       *
  13:App/Common/Minimal/countsem.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/countsem.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/countsem.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/countsem.c ****      *                                                                       *
  17:App/Common/Minimal/countsem.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/countsem.c ****      *                                                                       *
  19:App/Common/Minimal/countsem.c ****     ***************************************************************************
  20:App/Common/Minimal/countsem.c **** 
  21:App/Common/Minimal/countsem.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/countsem.c **** 
  23:App/Common/Minimal/countsem.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/countsem.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/countsem.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/countsem.c **** 
  27:App/Common/Minimal/countsem.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/countsem.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/countsem.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/countsem.c ****     >>! kernel.
  31:App/Common/Minimal/countsem.c **** 
  32:App/Common/Minimal/countsem.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/countsem.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/countsem.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/countsem.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/countsem.c **** 
  37:App/Common/Minimal/countsem.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/countsem.c **** 
  39:App/Common/Minimal/countsem.c ****     ***************************************************************************
  40:App/Common/Minimal/countsem.c ****      *                                                                       *
  41:App/Common/Minimal/countsem.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/countsem.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/countsem.c ****      *                                                                       *
  44:App/Common/Minimal/countsem.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/countsem.c ****      *                                                                       *
  46:App/Common/Minimal/countsem.c ****     ***************************************************************************
  47:App/Common/Minimal/countsem.c **** 
  48:App/Common/Minimal/countsem.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/countsem.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/countsem.c **** 
  51:App/Common/Minimal/countsem.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/countsem.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/countsem.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/countsem.c **** 
  55:App/Common/Minimal/countsem.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/countsem.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/countsem.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/countsem.c **** 
  59:App/Common/Minimal/countsem.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/countsem.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/countsem.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/countsem.c **** 
  63:App/Common/Minimal/countsem.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/countsem.c **** */
  65:App/Common/Minimal/countsem.c **** 
  66:App/Common/Minimal/countsem.c **** 
  67:App/Common/Minimal/countsem.c **** /* 
  68:App/Common/Minimal/countsem.c ****  * Simple demonstration of the usage of counting semaphore.
  69:App/Common/Minimal/countsem.c ****  */
  70:App/Common/Minimal/countsem.c **** 
  71:App/Common/Minimal/countsem.c **** /* Scheduler include files. */
  72:App/Common/Minimal/countsem.c **** #include "FreeRTOS.h"
  73:App/Common/Minimal/countsem.c **** #include "task.h"
  74:App/Common/Minimal/countsem.c **** #include "semphr.h"
  75:App/Common/Minimal/countsem.c **** 
  76:App/Common/Minimal/countsem.c **** /* Demo program include files. */
  77:App/Common/Minimal/countsem.c **** #include "countsem.h"
  78:App/Common/Minimal/countsem.c **** 
  79:App/Common/Minimal/countsem.c **** /* The maximum count value that the semaphore used for the demo can hold. */
  80:App/Common/Minimal/countsem.c **** #define countMAX_COUNT_VALUE	( 200 )
  81:App/Common/Minimal/countsem.c **** 
  82:App/Common/Minimal/countsem.c **** /* Constants used to indicate whether or not the semaphore should have been
  83:App/Common/Minimal/countsem.c **** created with its maximum count value, or its minimum count value.  These 
  84:App/Common/Minimal/countsem.c **** numbers are used to ensure that the pointers passed in as the task parameters
  85:App/Common/Minimal/countsem.c **** are valid. */
  86:App/Common/Minimal/countsem.c **** #define countSTART_AT_MAX_COUNT	( 0xaa )
  87:App/Common/Minimal/countsem.c **** #define countSTART_AT_ZERO		( 0x55 )
  88:App/Common/Minimal/countsem.c **** 
  89:App/Common/Minimal/countsem.c **** /* Two tasks are created for the test.  One uses a semaphore created with its
  90:App/Common/Minimal/countsem.c **** count value set to the maximum, and one with the count value set to zero. */
  91:App/Common/Minimal/countsem.c **** #define countNUM_TEST_TASKS		( 2 )
  92:App/Common/Minimal/countsem.c **** #define countDONT_BLOCK			( 0 )
  93:App/Common/Minimal/countsem.c **** 
  94:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
  95:App/Common/Minimal/countsem.c **** 
  96:App/Common/Minimal/countsem.c **** /* Flag that will be latched to pdTRUE should any unexpected behaviour be
  97:App/Common/Minimal/countsem.c **** detected in any of the tasks. */
  98:App/Common/Minimal/countsem.c **** static volatile portBASE_TYPE xErrorDetected = pdFALSE;
  99:App/Common/Minimal/countsem.c **** 
 100:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 101:App/Common/Minimal/countsem.c **** 
 102:App/Common/Minimal/countsem.c **** /*
 103:App/Common/Minimal/countsem.c ****  * The demo task.  This simply counts the semaphore up to its maximum value,
 104:App/Common/Minimal/countsem.c ****  * the counts it back down again.  The result of each semaphore 'give' and
 105:App/Common/Minimal/countsem.c ****  * 'take' is inspected, with an error being flagged if it is found not to be
 106:App/Common/Minimal/countsem.c ****  * the expected result.
 107:App/Common/Minimal/countsem.c ****  */
 108:App/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters );
 109:App/Common/Minimal/countsem.c **** 
 110:App/Common/Minimal/countsem.c **** /*
 111:App/Common/Minimal/countsem.c ****  * Utility function to increment the semaphore count value up from zero to
 112:App/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE.
 113:App/Common/Minimal/countsem.c ****  */
 114:App/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 115:App/Common/Minimal/countsem.c **** 
 116:App/Common/Minimal/countsem.c **** /*
 117:App/Common/Minimal/countsem.c ****  * Utility function to decrement the semaphore count value up from 
 118:App/Common/Minimal/countsem.c ****  * countMAX_COUNT_VALUE to zero.
 119:App/Common/Minimal/countsem.c ****  */
 120:App/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 121:App/Common/Minimal/countsem.c **** 
 122:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 123:App/Common/Minimal/countsem.c **** 
 124:App/Common/Minimal/countsem.c **** /* The structure that is passed into the task as the task parameter. */
 125:App/Common/Minimal/countsem.c **** typedef struct COUNT_SEM_STRUCT
 126:App/Common/Minimal/countsem.c **** {
 127:App/Common/Minimal/countsem.c **** 	/* The semaphore to be used for the demo. */
 128:App/Common/Minimal/countsem.c **** 	xSemaphoreHandle xSemaphore;
 129:App/Common/Minimal/countsem.c **** 
 130:App/Common/Minimal/countsem.c **** 	/* Set to countSTART_AT_MAX_COUNT if the semaphore should be created with
 131:App/Common/Minimal/countsem.c **** 	its count value set to its max count value, or countSTART_AT_ZERO if it
 132:App/Common/Minimal/countsem.c **** 	should have been created with its count value set to 0. */
 133:App/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxExpectedStartCount;	
 134:App/Common/Minimal/countsem.c **** 
 135:App/Common/Minimal/countsem.c **** 	/* Incremented on each cycle of the demo task.  Used to detect a stalled
 136:App/Common/Minimal/countsem.c **** 	task. */
 137:App/Common/Minimal/countsem.c **** 	unsigned portBASE_TYPE uxLoopCounter;			
 138:App/Common/Minimal/countsem.c **** } xCountSemStruct;
 139:App/Common/Minimal/countsem.c **** 
 140:App/Common/Minimal/countsem.c **** /* Two structures are defined, one is passed to each test task. */
 141:App/Common/Minimal/countsem.c **** static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];
 142:App/Common/Minimal/countsem.c **** 
 143:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 144:App/Common/Minimal/countsem.c **** 
 145:App/Common/Minimal/countsem.c **** void vStartCountingSemaphoreTasks( void )
 146:App/Common/Minimal/countsem.c **** {
  53              		.loc 1 146 0
  54              		.cfi_startproc
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 1, uses_anonymous_args = 0
  57 0000 80B5     		push	{r7, lr}
  58              	.LCFI0:
  59              		.cfi_def_cfa_offset 8
  60              		.cfi_offset 7, -8
  61              		.cfi_offset 14, -4
  62 0002 84B0     		sub	sp, sp, #16
  63              	.LCFI1:
  64              		.cfi_def_cfa_offset 24
  65 0004 04AF     		add	r7, sp, #16
  66              	.LCFI2:
  67              		.cfi_def_cfa 7, 8
 147:App/Common/Minimal/countsem.c **** 	/* Create the semaphores that we are going to use for the test/demo.  The
 148:App/Common/Minimal/countsem.c **** 	first should be created such that it starts at its maximum count value,
 149:App/Common/Minimal/countsem.c **** 	the second should be created such that it starts with a count value of zero. */
 150:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE
  68              		.loc 1 150 0
  69 0006 4FF0C800 		mov	r0, #200
  70 000a 4FF0C801 		mov	r1, #200
  71 000e FFF7FEFF 		bl	xQueueCreateCountingSemaphore
  72 0012 0246     		mov	r2, r0
  73 0014 40F20003 		movw	r3, #:lower16:xParameters
  74 0018 C0F20003 		movt	r3, #:upper16:xParameters
  75 001c 1A60     		str	r2, [r3, #0]
 151:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
  76              		.loc 1 151 0
  77 001e 40F20003 		movw	r3, #:lower16:xParameters
  78 0022 C0F20003 		movt	r3, #:upper16:xParameters
  79 0026 4FF0AA02 		mov	r2, #170
  80 002a 5A60     		str	r2, [r3, #4]
 152:App/Common/Minimal/countsem.c **** 	xParameters[ 0 ].uxLoopCounter = 0;
  81              		.loc 1 152 0
  82 002c 40F20003 		movw	r3, #:lower16:xParameters
  83 0030 C0F20003 		movt	r3, #:upper16:xParameters
  84 0034 4FF00002 		mov	r2, #0
  85 0038 9A60     		str	r2, [r3, #8]
 153:App/Common/Minimal/countsem.c **** 
 154:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
  86              		.loc 1 154 0
  87 003a 4FF0C800 		mov	r0, #200
  88 003e 4FF00001 		mov	r1, #0
  89 0042 FFF7FEFF 		bl	xQueueCreateCountingSemaphore
  90 0046 0246     		mov	r2, r0
  91 0048 40F20003 		movw	r3, #:lower16:xParameters
  92 004c C0F20003 		movt	r3, #:upper16:xParameters
  93 0050 DA60     		str	r2, [r3, #12]
 155:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxExpectedStartCount = 0;
  94              		.loc 1 155 0
  95 0052 40F20003 		movw	r3, #:lower16:xParameters
  96 0056 C0F20003 		movt	r3, #:upper16:xParameters
  97 005a 4FF00002 		mov	r2, #0
  98 005e 1A61     		str	r2, [r3, #16]
 156:App/Common/Minimal/countsem.c **** 	xParameters[ 1 ].uxLoopCounter = 0;
  99              		.loc 1 156 0
 100 0060 40F20003 		movw	r3, #:lower16:xParameters
 101 0064 C0F20003 		movt	r3, #:upper16:xParameters
 102 0068 4FF00002 		mov	r2, #0
 103 006c 5A61     		str	r2, [r3, #20]
 157:App/Common/Minimal/countsem.c **** 
 158:App/Common/Minimal/countsem.c **** 	/* vQueueAddToRegistry() adds the semaphore to the registry, if one is
 159:App/Common/Minimal/countsem.c **** 	in use.  The registry is provided as a means for kernel aware 
 160:App/Common/Minimal/countsem.c **** 	debuggers to locate semaphores and has no purpose if a kernel aware debugger
 161:App/Common/Minimal/countsem.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 162:App/Common/Minimal/countsem.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
 163:App/Common/Minimal/countsem.c **** 	defined to be less than 1. */
 164:App/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting
 104              		.loc 1 164 0
 105 006e 40F20003 		movw	r3, #:lower16:xParameters
 106 0072 C0F20003 		movt	r3, #:upper16:xParameters
 107 0076 1B68     		ldr	r3, [r3, #0]
 108 0078 1846     		mov	r0, r3
 109 007a 40F20001 		movw	r1, #:lower16:.LC0
 110 007e C0F20001 		movt	r1, #:upper16:.LC0
 111 0082 FFF7FEFF 		bl	vQueueAddToRegistry
 165:App/Common/Minimal/countsem.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting
 112              		.loc 1 165 0
 113 0086 40F20003 		movw	r3, #:lower16:xParameters
 114 008a C0F20003 		movt	r3, #:upper16:xParameters
 115 008e DB68     		ldr	r3, [r3, #12]
 116 0090 1846     		mov	r0, r3
 117 0092 40F20001 		movw	r1, #:lower16:.LC1
 118 0096 C0F20001 		movt	r1, #:upper16:.LC1
 119 009a FFF7FEFF 		bl	vQueueAddToRegistry
 166:App/Common/Minimal/countsem.c **** 
 167:App/Common/Minimal/countsem.c **** 
 168:App/Common/Minimal/countsem.c **** 	/* Were the semaphores created? */
 169:App/Common/Minimal/countsem.c **** 	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 120              		.loc 1 169 0
 121 009e 40F20003 		movw	r3, #:lower16:xParameters
 122 00a2 C0F20003 		movt	r3, #:upper16:xParameters
 123 00a6 1B68     		ldr	r3, [r3, #0]
 124 00a8 002B     		cmp	r3, #0
 125 00aa 06D1     		bne	.L2
 126              		.loc 1 169 0 is_stmt 0 discriminator 1
 127 00ac 40F20003 		movw	r3, #:lower16:xParameters
 128 00b0 C0F20003 		movt	r3, #:upper16:xParameters
 129 00b4 DB68     		ldr	r3, [r3, #12]
 130 00b6 002B     		cmp	r3, #0
 131 00b8 34D0     		beq	.L1
 132              	.L2:
 170:App/Common/Minimal/countsem.c **** 	{
 171:App/Common/Minimal/countsem.c **** 		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
 172:App/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( 
 133              		.loc 1 172 0 is_stmt 1
 134 00ba 4FF00003 		mov	r3, #0
 135 00be 0093     		str	r3, [sp, #0]
 136 00c0 4FF00003 		mov	r3, #0
 137 00c4 0193     		str	r3, [sp, #4]
 138 00c6 4FF00003 		mov	r3, #0
 139 00ca 0293     		str	r3, [sp, #8]
 140 00cc 4FF00003 		mov	r3, #0
 141 00d0 0393     		str	r3, [sp, #12]
 142 00d2 40F20000 		movw	r0, #:lower16:prvCountingSemaphoreTask
 143 00d6 C0F20000 		movt	r0, #:upper16:prvCountingSemaphoreTask
 144 00da 40F20001 		movw	r1, #:lower16:.LC2
 145 00de C0F20001 		movt	r1, #:upper16:.LC2
 146 00e2 4FF08202 		mov	r2, #130
 147 00e6 40F20003 		movw	r3, #:lower16:xParameters
 148 00ea C0F20003 		movt	r3, #:upper16:xParameters
 149 00ee FFF7FEFF 		bl	xTaskGenericCreate
 173:App/Common/Minimal/countsem.c **** 		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( 
 150              		.loc 1 173 0
 151 00f2 4FF00003 		mov	r3, #0
 152 00f6 0093     		str	r3, [sp, #0]
 153 00f8 4FF00003 		mov	r3, #0
 154 00fc 0193     		str	r3, [sp, #4]
 155 00fe 4FF00003 		mov	r3, #0
 156 0102 0293     		str	r3, [sp, #8]
 157 0104 4FF00003 		mov	r3, #0
 158 0108 0393     		str	r3, [sp, #12]
 159 010a 40F20000 		movw	r0, #:lower16:prvCountingSemaphoreTask
 160 010e C0F20000 		movt	r0, #:upper16:prvCountingSemaphoreTask
 161 0112 40F20001 		movw	r1, #:lower16:.LC3
 162 0116 C0F20001 		movt	r1, #:upper16:.LC3
 163 011a 4FF08202 		mov	r2, #130
 164 011e 024B     		ldr	r3, .L4
 165 0120 FFF7FEFF 		bl	xTaskGenericCreate
 166              	.L1:
 174:App/Common/Minimal/countsem.c **** 	}
 175:App/Common/Minimal/countsem.c **** }
 167              		.loc 1 175 0
 168 0124 BD46     		mov	sp, r7
 169 0126 80BD     		pop	{r7, pc}
 170              	.L5:
 171              		.align	2
 172              	.L4:
 173 0128 0C000000 		.word	xParameters+12
 174              		.cfi_endproc
 175              	.LFE110:
 177              		.section	.text.prvDecrementSemaphoreCount,"ax",%progbits
 178              		.align	2
 179              		.thumb
 180              		.thumb_func
 182              	prvDecrementSemaphoreCount:
 183              	.LFB111:
 176:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 177:App/Common/Minimal/countsem.c **** 
 178:App/Common/Minimal/countsem.c **** static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 179:App/Common/Minimal/countsem.c **** {
 184              		.loc 1 179 0
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 16
 187              		@ frame_needed = 1, uses_anonymous_args = 0
 188 0000 80B5     		push	{r7, lr}
 189              	.LCFI3:
 190              		.cfi_def_cfa_offset 8
 191              		.cfi_offset 7, -8
 192              		.cfi_offset 14, -4
 193 0002 84B0     		sub	sp, sp, #16
 194              	.LCFI4:
 195              		.cfi_def_cfa_offset 24
 196 0004 00AF     		add	r7, sp, #0
 197              	.LCFI5:
 198              		.cfi_def_cfa_register 7
 199 0006 7860     		str	r0, [r7, #4]
 200 0008 3960     		str	r1, [r7, #0]
 180:App/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 181:App/Common/Minimal/countsem.c **** 
 182:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 183:App/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 184:App/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 201              		.loc 1 184 0
 202 000a 7868     		ldr	r0, [r7, #4]
 203 000c 4FF00001 		mov	r1, #0
 204 0010 4FF00002 		mov	r2, #0
 205 0014 4FF00003 		mov	r3, #0
 206 0018 FFF7FEFF 		bl	xQueueGenericSend
 207 001c 0346     		mov	r3, r0
 208 001e 012B     		cmp	r3, #1
 209 0020 06D1     		bne	.L7
 185:App/Common/Minimal/countsem.c **** 	{
 186:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 210              		.loc 1 186 0
 211 0022 40F20003 		movw	r3, #:lower16:xErrorDetected
 212 0026 C0F20003 		movt	r3, #:upper16:xErrorDetected
 213 002a 4FF00102 		mov	r2, #1
 214 002e 1A60     		str	r2, [r3, #0]
 215              	.L7:
 187:App/Common/Minimal/countsem.c **** 	}
 188:App/Common/Minimal/countsem.c **** 
 189:App/Common/Minimal/countsem.c **** 	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 216              		.loc 1 190 0
 217 0030 4FF00003 		mov	r3, #0
 218 0034 FB60     		str	r3, [r7, #12]
 219 0036 1CE0     		b	.L8
 220              	.L10:
 191:App/Common/Minimal/countsem.c **** 	{
 192:App/Common/Minimal/countsem.c **** 		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
 221              		.loc 1 192 0
 222 0038 7868     		ldr	r0, [r7, #4]
 223 003a 4FF00001 		mov	r1, #0
 224 003e 4FF00002 		mov	r2, #0
 225 0042 4FF00003 		mov	r3, #0
 226 0046 FFF7FEFF 		bl	xQueueGenericReceive
 227 004a 0346     		mov	r3, r0
 228 004c 012B     		cmp	r3, #1
 229 004e 06D0     		beq	.L9
 193:App/Common/Minimal/countsem.c **** 		{
 194:App/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 195:App/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 230              		.loc 1 195 0
 231 0050 40F20003 		movw	r3, #:lower16:xErrorDetected
 232 0054 C0F20003 		movt	r3, #:upper16:xErrorDetected
 233 0058 4FF00102 		mov	r2, #1
 234 005c 1A60     		str	r2, [r3, #0]
 235              	.L9:
 196:App/Common/Minimal/countsem.c **** 		}
 197:App/Common/Minimal/countsem.c **** 
 198:App/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 236              		.loc 1 198 0
 237 005e 3B68     		ldr	r3, [r7, #0]
 238 0060 1B68     		ldr	r3, [r3, #0]
 239 0062 03F10102 		add	r2, r3, #1
 240 0066 3B68     		ldr	r3, [r7, #0]
 241 0068 1A60     		str	r2, [r3, #0]
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 242              		.loc 1 190 0
 243 006a FB68     		ldr	r3, [r7, #12]
 244 006c 03F10103 		add	r3, r3, #1
 245 0070 FB60     		str	r3, [r7, #12]
 246              	.L8:
 190:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 247              		.loc 1 190 0 is_stmt 0 discriminator 1
 248 0072 FB68     		ldr	r3, [r7, #12]
 249 0074 C72B     		cmp	r3, #199
 250 0076 DFD9     		bls	.L10
 199:App/Common/Minimal/countsem.c **** 	}
 200:App/Common/Minimal/countsem.c **** 
 201:App/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 202:App/Common/Minimal/countsem.c **** 		taskYIELD();
 203:App/Common/Minimal/countsem.c **** 	#endif
 204:App/Common/Minimal/countsem.c **** 
 205:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 206:App/Common/Minimal/countsem.c **** 	the semaphore. */
 207:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 251              		.loc 1 207 0 is_stmt 1
 252 0078 7868     		ldr	r0, [r7, #4]
 253 007a 4FF00001 		mov	r1, #0
 254 007e 4FF00002 		mov	r2, #0
 255 0082 4FF00003 		mov	r3, #0
 256 0086 FFF7FEFF 		bl	xQueueGenericReceive
 257 008a 0346     		mov	r3, r0
 258 008c 012B     		cmp	r3, #1
 259 008e 06D1     		bne	.L6
 208:App/Common/Minimal/countsem.c **** 	{
 209:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 260              		.loc 1 209 0
 261 0090 40F20003 		movw	r3, #:lower16:xErrorDetected
 262 0094 C0F20003 		movt	r3, #:upper16:xErrorDetected
 263 0098 4FF00102 		mov	r2, #1
 264 009c 1A60     		str	r2, [r3, #0]
 265              	.L6:
 210:App/Common/Minimal/countsem.c **** 	}
 211:App/Common/Minimal/countsem.c **** }
 266              		.loc 1 211 0
 267 009e 07F11007 		add	r7, r7, #16
 268 00a2 BD46     		mov	sp, r7
 269 00a4 80BD     		pop	{r7, pc}
 270              		.cfi_endproc
 271              	.LFE111:
 273 00a6 00BF     		.section	.text.prvIncrementSemaphoreCount,"ax",%progbits
 274              		.align	2
 275              		.thumb
 276              		.thumb_func
 278              	prvIncrementSemaphoreCount:
 279              	.LFB112:
 212:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 213:App/Common/Minimal/countsem.c **** 
 214:App/Common/Minimal/countsem.c **** static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoo
 215:App/Common/Minimal/countsem.c **** {
 280              		.loc 1 215 0
 281              		.cfi_startproc
 282              		@ args = 0, pretend = 0, frame = 16
 283              		@ frame_needed = 1, uses_anonymous_args = 0
 284 0000 80B5     		push	{r7, lr}
 285              	.LCFI6:
 286              		.cfi_def_cfa_offset 8
 287              		.cfi_offset 7, -8
 288              		.cfi_offset 14, -4
 289 0002 84B0     		sub	sp, sp, #16
 290              	.LCFI7:
 291              		.cfi_def_cfa_offset 24
 292 0004 00AF     		add	r7, sp, #0
 293              	.LCFI8:
 294              		.cfi_def_cfa_register 7
 295 0006 7860     		str	r0, [r7, #4]
 296 0008 3960     		str	r1, [r7, #0]
 216:App/Common/Minimal/countsem.c **** unsigned portBASE_TYPE ux;
 217:App/Common/Minimal/countsem.c **** 
 218:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is zero then we should not be able to	'take' 
 219:App/Common/Minimal/countsem.c **** 	the semaphore. */
 220:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 297              		.loc 1 220 0
 298 000a 7868     		ldr	r0, [r7, #4]
 299 000c 4FF00001 		mov	r1, #0
 300 0010 4FF00002 		mov	r2, #0
 301 0014 4FF00003 		mov	r3, #0
 302 0018 FFF7FEFF 		bl	xQueueGenericReceive
 303 001c 0346     		mov	r3, r0
 304 001e 012B     		cmp	r3, #1
 305 0020 06D1     		bne	.L13
 221:App/Common/Minimal/countsem.c **** 	{
 222:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 306              		.loc 1 222 0
 307 0022 40F20003 		movw	r3, #:lower16:xErrorDetected
 308 0026 C0F20003 		movt	r3, #:upper16:xErrorDetected
 309 002a 4FF00102 		mov	r2, #1
 310 002e 1A60     		str	r2, [r3, #0]
 311              	.L13:
 223:App/Common/Minimal/countsem.c **** 	}
 224:App/Common/Minimal/countsem.c **** 
 225:App/Common/Minimal/countsem.c **** 	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 312              		.loc 1 226 0
 313 0030 4FF00003 		mov	r3, #0
 314 0034 FB60     		str	r3, [r7, #12]
 315 0036 1CE0     		b	.L14
 316              	.L16:
 227:App/Common/Minimal/countsem.c **** 	{
 228:App/Common/Minimal/countsem.c **** 		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 317              		.loc 1 228 0
 318 0038 7868     		ldr	r0, [r7, #4]
 319 003a 4FF00001 		mov	r1, #0
 320 003e 4FF00002 		mov	r2, #0
 321 0042 4FF00003 		mov	r3, #0
 322 0046 FFF7FEFF 		bl	xQueueGenericSend
 323 004a 0346     		mov	r3, r0
 324 004c 012B     		cmp	r3, #1
 325 004e 06D0     		beq	.L15
 229:App/Common/Minimal/countsem.c **** 		{
 230:App/Common/Minimal/countsem.c **** 			/* We expected to be able to take the semaphore. */
 231:App/Common/Minimal/countsem.c **** 			xErrorDetected = pdTRUE;
 326              		.loc 1 231 0
 327 0050 40F20003 		movw	r3, #:lower16:xErrorDetected
 328 0054 C0F20003 		movt	r3, #:upper16:xErrorDetected
 329 0058 4FF00102 		mov	r2, #1
 330 005c 1A60     		str	r2, [r3, #0]
 331              	.L15:
 232:App/Common/Minimal/countsem.c **** 		}
 233:App/Common/Minimal/countsem.c **** 
 234:App/Common/Minimal/countsem.c **** 		( *puxLoopCounter )++;
 332              		.loc 1 234 0
 333 005e 3B68     		ldr	r3, [r7, #0]
 334 0060 1B68     		ldr	r3, [r3, #0]
 335 0062 03F10102 		add	r2, r3, #1
 336 0066 3B68     		ldr	r3, [r7, #0]
 337 0068 1A60     		str	r2, [r3, #0]
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 338              		.loc 1 226 0
 339 006a FB68     		ldr	r3, [r7, #12]
 340 006c 03F10103 		add	r3, r3, #1
 341 0070 FB60     		str	r3, [r7, #12]
 342              	.L14:
 226:App/Common/Minimal/countsem.c **** 	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 343              		.loc 1 226 0 is_stmt 0 discriminator 1
 344 0072 FB68     		ldr	r3, [r7, #12]
 345 0074 C72B     		cmp	r3, #199
 346 0076 DFD9     		bls	.L16
 235:App/Common/Minimal/countsem.c **** 	}
 236:App/Common/Minimal/countsem.c **** 
 237:App/Common/Minimal/countsem.c **** 	#if configUSE_PREEMPTION == 0
 238:App/Common/Minimal/countsem.c **** 		taskYIELD();
 239:App/Common/Minimal/countsem.c **** 	#endif
 240:App/Common/Minimal/countsem.c **** 
 241:App/Common/Minimal/countsem.c **** 	/* If the semaphore count is at its maximum then we should not be able to
 242:App/Common/Minimal/countsem.c **** 	'give' the semaphore. */
 243:App/Common/Minimal/countsem.c **** 	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 347              		.loc 1 243 0 is_stmt 1
 348 0078 7868     		ldr	r0, [r7, #4]
 349 007a 4FF00001 		mov	r1, #0
 350 007e 4FF00002 		mov	r2, #0
 351 0082 4FF00003 		mov	r3, #0
 352 0086 FFF7FEFF 		bl	xQueueGenericSend
 353 008a 0346     		mov	r3, r0
 354 008c 012B     		cmp	r3, #1
 355 008e 06D1     		bne	.L12
 244:App/Common/Minimal/countsem.c **** 	{
 245:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 356              		.loc 1 245 0
 357 0090 40F20003 		movw	r3, #:lower16:xErrorDetected
 358 0094 C0F20003 		movt	r3, #:upper16:xErrorDetected
 359 0098 4FF00102 		mov	r2, #1
 360 009c 1A60     		str	r2, [r3, #0]
 361              	.L12:
 246:App/Common/Minimal/countsem.c **** 	}
 247:App/Common/Minimal/countsem.c **** }
 362              		.loc 1 247 0
 363 009e 07F11007 		add	r7, r7, #16
 364 00a2 BD46     		mov	sp, r7
 365 00a4 80BD     		pop	{r7, pc}
 366              		.cfi_endproc
 367              	.LFE112:
 369 00a6 00BF     		.section	.text.prvCountingSemaphoreTask,"ax",%progbits
 370              		.align	2
 371              		.thumb
 372              		.thumb_func
 374              	prvCountingSemaphoreTask:
 375              	.LFB113:
 248:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 249:App/Common/Minimal/countsem.c **** 
 250:App/Common/Minimal/countsem.c **** static void prvCountingSemaphoreTask( void *pvParameters )
 251:App/Common/Minimal/countsem.c **** {
 376              		.loc 1 251 0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 16
 379              		@ frame_needed = 1, uses_anonymous_args = 0
 380 0000 80B5     		push	{r7, lr}
 381              	.LCFI9:
 382              		.cfi_def_cfa_offset 8
 383              		.cfi_offset 7, -8
 384              		.cfi_offset 14, -4
 385 0002 84B0     		sub	sp, sp, #16
 386              	.LCFI10:
 387              		.cfi_def_cfa_offset 24
 388 0004 00AF     		add	r7, sp, #0
 389              	.LCFI11:
 390              		.cfi_def_cfa_register 7
 391 0006 7860     		str	r0, [r7, #4]
 252:App/Common/Minimal/countsem.c **** xCountSemStruct *pxParameter;
 253:App/Common/Minimal/countsem.c **** 
 254:App/Common/Minimal/countsem.c **** 	#ifdef USE_STDIO
 255:App/Common/Minimal/countsem.c **** 	void vPrintDisplayMessage( const portCHAR * const * ppcMessageToSend );
 256:App/Common/Minimal/countsem.c **** 	
 257:App/Common/Minimal/countsem.c **** 		const portCHAR * const pcTaskStartMsg = "Counting semaphore demo started.\r\n";
 258:App/Common/Minimal/countsem.c **** 
 259:App/Common/Minimal/countsem.c **** 		/* Queue a message for printing to say the task has started. */
 260:App/Common/Minimal/countsem.c **** 		vPrintDisplayMessage( &pcTaskStartMsg );
 261:App/Common/Minimal/countsem.c **** 	#endif
 262:App/Common/Minimal/countsem.c **** 
 263:App/Common/Minimal/countsem.c **** 	/* The semaphore to be used was passed as the parameter. */
 264:App/Common/Minimal/countsem.c **** 	pxParameter = ( xCountSemStruct * ) pvParameters;
 392              		.loc 1 264 0
 393 0008 7B68     		ldr	r3, [r7, #4]
 394 000a FB60     		str	r3, [r7, #12]
 265:App/Common/Minimal/countsem.c **** 
 266:App/Common/Minimal/countsem.c **** 	/* Did we expect to find the semaphore already at its max count value, or
 267:App/Common/Minimal/countsem.c **** 	at zero? */
 268:App/Common/Minimal/countsem.c **** 	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 395              		.loc 1 268 0
 396 000c FB68     		ldr	r3, [r7, #12]
 397 000e 5B68     		ldr	r3, [r3, #4]
 398 0010 AA2B     		cmp	r3, #170
 399 0012 08D1     		bne	.L19
 269:App/Common/Minimal/countsem.c **** 	{
 270:App/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 400              		.loc 1 270 0
 401 0014 FB68     		ldr	r3, [r7, #12]
 402 0016 1A68     		ldr	r2, [r3, #0]
 403 0018 FB68     		ldr	r3, [r7, #12]
 404 001a 03F10803 		add	r3, r3, #8
 405 001e 1046     		mov	r0, r2
 406 0020 1946     		mov	r1, r3
 407 0022 FFF7FEFF 		bl	prvDecrementSemaphoreCount
 408              	.L19:
 271:App/Common/Minimal/countsem.c **** 	}
 272:App/Common/Minimal/countsem.c **** 
 273:App/Common/Minimal/countsem.c **** 	/* Now we expect the semaphore count to be 0, so this time there is an
 274:App/Common/Minimal/countsem.c **** 	error if we can take the semaphore. */
 275:App/Common/Minimal/countsem.c **** 	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 409              		.loc 1 275 0
 410 0026 FB68     		ldr	r3, [r7, #12]
 411 0028 1B68     		ldr	r3, [r3, #0]
 412 002a 1846     		mov	r0, r3
 413 002c 4FF00001 		mov	r1, #0
 414 0030 4FF00002 		mov	r2, #0
 415 0034 4FF00003 		mov	r3, #0
 416 0038 FFF7FEFF 		bl	xQueueGenericReceive
 417 003c 0346     		mov	r3, r0
 418 003e 012B     		cmp	r3, #1
 419 0040 06D1     		bne	.L20
 276:App/Common/Minimal/countsem.c **** 	{
 277:App/Common/Minimal/countsem.c **** 		xErrorDetected = pdTRUE;
 420              		.loc 1 277 0
 421 0042 40F20003 		movw	r3, #:lower16:xErrorDetected
 422 0046 C0F20003 		movt	r3, #:upper16:xErrorDetected
 423 004a 4FF00102 		mov	r2, #1
 424 004e 1A60     		str	r2, [r3, #0]
 425              	.L20:
 278:App/Common/Minimal/countsem.c **** 	}
 279:App/Common/Minimal/countsem.c **** 
 280:App/Common/Minimal/countsem.c **** 	for( ;; )
 281:App/Common/Minimal/countsem.c **** 	{
 282:App/Common/Minimal/countsem.c **** 		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 426              		.loc 1 282 0 discriminator 1
 427 0050 FB68     		ldr	r3, [r7, #12]
 428 0052 1A68     		ldr	r2, [r3, #0]
 429 0054 FB68     		ldr	r3, [r7, #12]
 430 0056 03F10803 		add	r3, r3, #8
 431 005a 1046     		mov	r0, r2
 432 005c 1946     		mov	r1, r3
 433 005e FFF7FEFF 		bl	prvIncrementSemaphoreCount
 283:App/Common/Minimal/countsem.c **** 		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 434              		.loc 1 283 0 discriminator 1
 435 0062 FB68     		ldr	r3, [r7, #12]
 436 0064 1A68     		ldr	r2, [r3, #0]
 437 0066 FB68     		ldr	r3, [r7, #12]
 438 0068 03F10803 		add	r3, r3, #8
 439 006c 1046     		mov	r0, r2
 440 006e 1946     		mov	r1, r3
 441 0070 FFF7FEFF 		bl	prvDecrementSemaphoreCount
 284:App/Common/Minimal/countsem.c **** 	}
 442              		.loc 1 284 0 discriminator 1
 443 0074 ECE7     		b	.L20
 444              		.cfi_endproc
 445              	.LFE113:
 447 0076 00BF     		.section	.text.xAreCountingSemaphoreTasksStillRunning,"ax",%progbits
 448              		.align	2
 449              		.global	xAreCountingSemaphoreTasksStillRunning
 450              		.thumb
 451              		.thumb_func
 453              	xAreCountingSemaphoreTasksStillRunning:
 454              	.LFB114:
 285:App/Common/Minimal/countsem.c **** }
 286:App/Common/Minimal/countsem.c **** /*-----------------------------------------------------------*/
 287:App/Common/Minimal/countsem.c **** 
 288:App/Common/Minimal/countsem.c **** portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
 289:App/Common/Minimal/countsem.c **** {
 455              		.loc 1 289 0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 8
 458              		@ frame_needed = 1, uses_anonymous_args = 0
 459              		@ link register save eliminated.
 460 0000 80B4     		push	{r7}
 461              	.LCFI12:
 462              		.cfi_def_cfa_offset 4
 463              		.cfi_offset 7, -4
 464 0002 83B0     		sub	sp, sp, #12
 465              	.LCFI13:
 466              		.cfi_def_cfa_offset 16
 467 0004 00AF     		add	r7, sp, #0
 468              	.LCFI14:
 469              		.cfi_def_cfa_register 7
 290:App/Common/Minimal/countsem.c **** static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
 291:App/Common/Minimal/countsem.c **** portBASE_TYPE xReturn = pdPASS;
 470              		.loc 1 291 0
 471 0006 4FF00103 		mov	r3, #1
 472 000a 7B60     		str	r3, [r7, #4]
 292:App/Common/Minimal/countsem.c **** 
 293:App/Common/Minimal/countsem.c **** 	/* Return fail if any 'give' or 'take' did not result in the expected
 294:App/Common/Minimal/countsem.c **** 	behaviour. */
 295:App/Common/Minimal/countsem.c **** 	if( xErrorDetected != pdFALSE )
 473              		.loc 1 295 0
 474 000c 40F20003 		movw	r3, #:lower16:xErrorDetected
 475 0010 C0F20003 		movt	r3, #:upper16:xErrorDetected
 476 0014 1B68     		ldr	r3, [r3, #0]
 477 0016 002B     		cmp	r3, #0
 478 0018 02D0     		beq	.L22
 296:App/Common/Minimal/countsem.c **** 	{
 297:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 479              		.loc 1 297 0
 480 001a 4FF00003 		mov	r3, #0
 481 001e 7B60     		str	r3, [r7, #4]
 482              	.L22:
 298:App/Common/Minimal/countsem.c **** 	}
 299:App/Common/Minimal/countsem.c **** 
 300:App/Common/Minimal/countsem.c **** 	/* Return fail if either task is not still incrementing its loop counter. */
 301:App/Common/Minimal/countsem.c **** 	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
 483              		.loc 1 301 0
 484 0020 40F20003 		movw	r3, #:lower16:xParameters
 485 0024 C0F20003 		movt	r3, #:upper16:xParameters
 486 0028 9A68     		ldr	r2, [r3, #8]
 487 002a 40F20003 		movw	r3, #:lower16:uxLastCount0.7662
 488 002e C0F20003 		movt	r3, #:upper16:uxLastCount0.7662
 489 0032 1B68     		ldr	r3, [r3, #0]
 490 0034 9A42     		cmp	r2, r3
 491 0036 03D1     		bne	.L23
 302:App/Common/Minimal/countsem.c **** 	{
 303:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 492              		.loc 1 303 0
 493 0038 4FF00003 		mov	r3, #0
 494 003c 7B60     		str	r3, [r7, #4]
 495 003e 09E0     		b	.L24
 496              	.L23:
 304:App/Common/Minimal/countsem.c **** 	}
 305:App/Common/Minimal/countsem.c **** 	else
 306:App/Common/Minimal/countsem.c **** 	{
 307:App/Common/Minimal/countsem.c **** 		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
 497              		.loc 1 307 0
 498 0040 40F20003 		movw	r3, #:lower16:xParameters
 499 0044 C0F20003 		movt	r3, #:upper16:xParameters
 500 0048 9A68     		ldr	r2, [r3, #8]
 501 004a 40F20003 		movw	r3, #:lower16:uxLastCount0.7662
 502 004e C0F20003 		movt	r3, #:upper16:uxLastCount0.7662
 503 0052 1A60     		str	r2, [r3, #0]
 504              	.L24:
 308:App/Common/Minimal/countsem.c **** 	}
 309:App/Common/Minimal/countsem.c **** 
 310:App/Common/Minimal/countsem.c **** 	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
 505              		.loc 1 310 0
 506 0054 40F20003 		movw	r3, #:lower16:xParameters
 507 0058 C0F20003 		movt	r3, #:upper16:xParameters
 508 005c 5A69     		ldr	r2, [r3, #20]
 509 005e 40F20003 		movw	r3, #:lower16:uxLastCount1.7663
 510 0062 C0F20003 		movt	r3, #:upper16:uxLastCount1.7663
 511 0066 1B68     		ldr	r3, [r3, #0]
 512 0068 9A42     		cmp	r2, r3
 513 006a 03D1     		bne	.L25
 311:App/Common/Minimal/countsem.c **** 	{
 312:App/Common/Minimal/countsem.c **** 		xReturn = pdFAIL;
 514              		.loc 1 312 0
 515 006c 4FF00003 		mov	r3, #0
 516 0070 7B60     		str	r3, [r7, #4]
 517 0072 09E0     		b	.L26
 518              	.L25:
 313:App/Common/Minimal/countsem.c **** 	}
 314:App/Common/Minimal/countsem.c **** 	else
 315:App/Common/Minimal/countsem.c **** 	{
 316:App/Common/Minimal/countsem.c **** 		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
 519              		.loc 1 316 0
 520 0074 40F20003 		movw	r3, #:lower16:xParameters
 521 0078 C0F20003 		movt	r3, #:upper16:xParameters
 522 007c 5A69     		ldr	r2, [r3, #20]
 523 007e 40F20003 		movw	r3, #:lower16:uxLastCount1.7663
 524 0082 C0F20003 		movt	r3, #:upper16:uxLastCount1.7663
 525 0086 1A60     		str	r2, [r3, #0]
 526              	.L26:
 317:App/Common/Minimal/countsem.c **** 	}
 318:App/Common/Minimal/countsem.c **** 
 319:App/Common/Minimal/countsem.c **** 	return xReturn;
 527              		.loc 1 319 0
 528 0088 7B68     		ldr	r3, [r7, #4]
 320:App/Common/Minimal/countsem.c **** }
 529              		.loc 1 320 0
 530 008a 1846     		mov	r0, r3
 531 008c 07F10C07 		add	r7, r7, #12
 532 0090 BD46     		mov	sp, r7
 533 0092 80BC     		pop	{r7}
 534 0094 7047     		bx	lr
 535              		.cfi_endproc
 536              	.LFE114:
 538 0096 00BF     		.section	.bss.uxLastCount0.7662,"aw",%nobits
 539              		.align	2
 542              	uxLastCount0.7662:
 543 0000 00000000 		.space	4
 544              		.section	.bss.uxLastCount1.7663,"aw",%nobits
 545              		.align	2
 548              	uxLastCount1.7663:
 549 0000 00000000 		.space	4
 550              		.text
 551              	.Letext0:
 552              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 553              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 554              		.file 4 "Source/include/queue.h"
 555              		.file 5 "Source/include/semphr.h"
 556              		.file 6 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 countsem.c
     /tmp/cc246Pku.s:20     .bss.xErrorDetected:00000000 $d
     /tmp/cc246Pku.s:23     .bss.xErrorDetected:00000000 xErrorDetected
     /tmp/cc246Pku.s:26     .bss.xParameters:00000000 $d
     /tmp/cc246Pku.s:29     .bss.xParameters:00000000 xParameters
     /tmp/cc246Pku.s:32     .rodata:00000000 $d
     /tmp/cc246Pku.s:33     .rodata:00000000 .LC0
     /tmp/cc246Pku.s:36     .rodata:00000010 .LC1
     /tmp/cc246Pku.s:39     .rodata:00000020 .LC2
     /tmp/cc246Pku.s:42     .rodata:00000028 .LC3
     /tmp/cc246Pku.s:45     .text.vStartCountingSemaphoreTasks:00000000 $t
     /tmp/cc246Pku.s:50     .text.vStartCountingSemaphoreTasks:00000000 vStartCountingSemaphoreTasks
     /tmp/cc246Pku.s:374    .text.prvCountingSemaphoreTask:00000000 prvCountingSemaphoreTask
     /tmp/cc246Pku.s:173    .text.vStartCountingSemaphoreTasks:00000128 $d
     /tmp/cc246Pku.s:178    .text.prvDecrementSemaphoreCount:00000000 $t
     /tmp/cc246Pku.s:182    .text.prvDecrementSemaphoreCount:00000000 prvDecrementSemaphoreCount
     /tmp/cc246Pku.s:274    .text.prvIncrementSemaphoreCount:00000000 $t
     /tmp/cc246Pku.s:278    .text.prvIncrementSemaphoreCount:00000000 prvIncrementSemaphoreCount
     /tmp/cc246Pku.s:370    .text.prvCountingSemaphoreTask:00000000 $t
     /tmp/cc246Pku.s:448    .text.xAreCountingSemaphoreTasksStillRunning:00000000 $t
     /tmp/cc246Pku.s:453    .text.xAreCountingSemaphoreTasksStillRunning:00000000 xAreCountingSemaphoreTasksStillRunning
     /tmp/cc246Pku.s:542    .bss.uxLastCount0.7662:00000000 uxLastCount0.7662
     /tmp/cc246Pku.s:548    .bss.uxLastCount1.7663:00000000 uxLastCount1.7663
     /tmp/cc246Pku.s:539    .bss.uxLastCount0.7662:00000000 $d
     /tmp/cc246Pku.s:545    .bss.uxLastCount1.7663:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueCreateCountingSemaphore
vQueueAddToRegistry
xTaskGenericCreate
xQueueGenericSend
xQueueGenericReceive
