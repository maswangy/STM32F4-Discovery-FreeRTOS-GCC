   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"recmutex.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.bss.xMutex,"aw",%nobits
  20              		.align	2
  23              	xMutex:
  24 0000 00000000 		.space	4
  25              		.section	.bss.xErrorOccurred,"aw",%nobits
  26              		.align	2
  29              	xErrorOccurred:
  30 0000 00000000 		.space	4
  31              		.section	.bss.xControllingIsSuspended,"aw",%nobits
  32              		.align	2
  35              	xControllingIsSuspended:
  36 0000 00000000 		.space	4
  37              		.section	.bss.xBlockingIsSuspended,"aw",%nobits
  38              		.align	2
  41              	xBlockingIsSuspended:
  42 0000 00000000 		.space	4
  43              		.section	.bss.uxControllingCycles,"aw",%nobits
  44              		.align	2
  47              	uxControllingCycles:
  48 0000 00000000 		.space	4
  49              		.section	.bss.uxBlockingCycles,"aw",%nobits
  50              		.align	2
  53              	uxBlockingCycles:
  54 0000 00000000 		.space	4
  55              		.section	.bss.uxPollingCycles,"aw",%nobits
  56              		.align	2
  59              	uxPollingCycles:
  60 0000 00000000 		.space	4
  61              		.section	.bss.xControllingTaskHandle,"aw",%nobits
  62              		.align	2
  65              	xControllingTaskHandle:
  66 0000 00000000 		.space	4
  67              		.section	.bss.xBlockingTaskHandle,"aw",%nobits
  68              		.align	2
  71              	xBlockingTaskHandle:
  72 0000 00000000 		.space	4
  73              		.section	.rodata
  74              		.align	2
  75              	.LC0:
  76 0000 52656375 		.ascii	"Recursive_Mutex\000"
  76      72736976 
  76      655F4D75 
  76      74657800 
  77              		.align	2
  78              	.LC1:
  79 0010 52656331 		.ascii	"Rec1\000"
  79      00
  80 0015 000000   		.align	2
  81              	.LC2:
  82 0018 52656332 		.ascii	"Rec2\000"
  82      00
  83 001d 000000   		.align	2
  84              	.LC3:
  85 0020 52656333 		.ascii	"Rec3\000"
  85      00
  86 0025 000000   		.section	.text.vStartRecursiveMutexTasks,"ax",%progbits
  87              		.align	2
  88              		.global	vStartRecursiveMutexTasks
  89              		.thumb
  90              		.thumb_func
  92              	vStartRecursiveMutexTasks:
  93              	.LFB110:
  94              		.file 1 "App/Common/Minimal/recmutex.c"
   1:App/Common/Minimal/recmutex.c **** /*
   2:App/Common/Minimal/recmutex.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:App/Common/Minimal/recmutex.c ****     All rights reserved
   4:App/Common/Minimal/recmutex.c **** 
   5:App/Common/Minimal/recmutex.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:App/Common/Minimal/recmutex.c **** 
   7:App/Common/Minimal/recmutex.c ****     ***************************************************************************
   8:App/Common/Minimal/recmutex.c ****      *                                                                       *
   9:App/Common/Minimal/recmutex.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:App/Common/Minimal/recmutex.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:App/Common/Minimal/recmutex.c ****      *    platform software that has become a de facto standard.             *
  12:App/Common/Minimal/recmutex.c ****      *                                                                       *
  13:App/Common/Minimal/recmutex.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:App/Common/Minimal/recmutex.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:App/Common/Minimal/recmutex.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:App/Common/Minimal/recmutex.c ****      *                                                                       *
  17:App/Common/Minimal/recmutex.c ****      *    Thank you!                                                         *
  18:App/Common/Minimal/recmutex.c ****      *                                                                       *
  19:App/Common/Minimal/recmutex.c ****     ***************************************************************************
  20:App/Common/Minimal/recmutex.c **** 
  21:App/Common/Minimal/recmutex.c ****     This file is part of the FreeRTOS distribution.
  22:App/Common/Minimal/recmutex.c **** 
  23:App/Common/Minimal/recmutex.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:App/Common/Minimal/recmutex.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:App/Common/Minimal/recmutex.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:App/Common/Minimal/recmutex.c **** 
  27:App/Common/Minimal/recmutex.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:App/Common/Minimal/recmutex.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:App/Common/Minimal/recmutex.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:App/Common/Minimal/recmutex.c ****     >>! kernel.
  31:App/Common/Minimal/recmutex.c **** 
  32:App/Common/Minimal/recmutex.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:App/Common/Minimal/recmutex.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:App/Common/Minimal/recmutex.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:App/Common/Minimal/recmutex.c ****     link: http://www.freertos.org/a00114.html
  36:App/Common/Minimal/recmutex.c **** 
  37:App/Common/Minimal/recmutex.c ****     1 tab == 4 spaces!
  38:App/Common/Minimal/recmutex.c **** 
  39:App/Common/Minimal/recmutex.c ****     ***************************************************************************
  40:App/Common/Minimal/recmutex.c ****      *                                                                       *
  41:App/Common/Minimal/recmutex.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:App/Common/Minimal/recmutex.c ****      *    not run, what could be wrong?"                                     *
  43:App/Common/Minimal/recmutex.c ****      *                                                                       *
  44:App/Common/Minimal/recmutex.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:App/Common/Minimal/recmutex.c ****      *                                                                       *
  46:App/Common/Minimal/recmutex.c ****     ***************************************************************************
  47:App/Common/Minimal/recmutex.c **** 
  48:App/Common/Minimal/recmutex.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:App/Common/Minimal/recmutex.c ****     license and Real Time Engineers Ltd. contact details.
  50:App/Common/Minimal/recmutex.c **** 
  51:App/Common/Minimal/recmutex.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:App/Common/Minimal/recmutex.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:App/Common/Minimal/recmutex.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:App/Common/Minimal/recmutex.c **** 
  55:App/Common/Minimal/recmutex.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:App/Common/Minimal/recmutex.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:App/Common/Minimal/recmutex.c ****     licenses offer ticketed support, indemnification and middleware.
  58:App/Common/Minimal/recmutex.c **** 
  59:App/Common/Minimal/recmutex.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:App/Common/Minimal/recmutex.c ****     engineered and independently SIL3 certified version for use in safety and
  61:App/Common/Minimal/recmutex.c ****     mission critical applications that require provable dependability.
  62:App/Common/Minimal/recmutex.c **** 
  63:App/Common/Minimal/recmutex.c ****     1 tab == 4 spaces!
  64:App/Common/Minimal/recmutex.c **** */
  65:App/Common/Minimal/recmutex.c **** 
  66:App/Common/Minimal/recmutex.c **** /*
  67:App/Common/Minimal/recmutex.c **** 	The tasks defined on this page demonstrate the use of recursive mutexes.
  68:App/Common/Minimal/recmutex.c **** 
  69:App/Common/Minimal/recmutex.c **** 	For recursive mutex functionality the created mutex should be created using
  70:App/Common/Minimal/recmutex.c **** 	xSemaphoreCreateRecursiveMutex(), then be manipulated
  71:App/Common/Minimal/recmutex.c **** 	using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() API
  72:App/Common/Minimal/recmutex.c **** 	functions.
  73:App/Common/Minimal/recmutex.c **** 
  74:App/Common/Minimal/recmutex.c **** 	This demo creates three tasks all of which access the same recursive mutex:
  75:App/Common/Minimal/recmutex.c **** 
  76:App/Common/Minimal/recmutex.c **** 	prvRecursiveMutexControllingTask() has the highest priority so executes
  77:App/Common/Minimal/recmutex.c **** 	first and grabs the mutex.  It then performs some recursive accesses -
  78:App/Common/Minimal/recmutex.c **** 	between each of which it sleeps for a short period to let the lower
  79:App/Common/Minimal/recmutex.c **** 	priority tasks execute.  When it has completed its demo functionality
  80:App/Common/Minimal/recmutex.c **** 	it gives the mutex back before suspending itself.
  81:App/Common/Minimal/recmutex.c **** 
  82:App/Common/Minimal/recmutex.c **** 	prvRecursiveMutexBlockingTask() attempts to access the mutex by performing
  83:App/Common/Minimal/recmutex.c **** 	a blocking 'take'.  The blocking task has a lower priority than the
  84:App/Common/Minimal/recmutex.c **** 	controlling	task so by the time it executes the mutex has already been
  85:App/Common/Minimal/recmutex.c **** 	taken by the controlling task,  causing the blocking task to block.  It
  86:App/Common/Minimal/recmutex.c **** 	does not unblock until the controlling task has given the mutex back,
  87:App/Common/Minimal/recmutex.c **** 	and it does not actually run until the controlling task has suspended
  88:App/Common/Minimal/recmutex.c **** 	itself (due to the relative priorities).  When it eventually does obtain
  89:App/Common/Minimal/recmutex.c **** 	the mutex all it does is give the mutex back prior to also suspending
  90:App/Common/Minimal/recmutex.c **** 	itself.  At this point both the controlling task and the blocking task are
  91:App/Common/Minimal/recmutex.c **** 	suspended.
  92:App/Common/Minimal/recmutex.c **** 
  93:App/Common/Minimal/recmutex.c **** 	prvRecursiveMutexPollingTask() runs at the idle priority.  It spins round
  94:App/Common/Minimal/recmutex.c **** 	a tight loop attempting to obtain the mutex with a non-blocking call.  As
  95:App/Common/Minimal/recmutex.c **** 	the lowest priority task it will not successfully obtain the mutex until
  96:App/Common/Minimal/recmutex.c **** 	both the controlling and blocking tasks are suspended.  Once it eventually
  97:App/Common/Minimal/recmutex.c **** 	does obtain the mutex it first unsuspends both the controlling task and
  98:App/Common/Minimal/recmutex.c **** 	blocking task prior to giving the mutex back - resulting in the polling
  99:App/Common/Minimal/recmutex.c **** 	task temporarily inheriting the controlling tasks priority.
 100:App/Common/Minimal/recmutex.c **** */
 101:App/Common/Minimal/recmutex.c **** 
 102:App/Common/Minimal/recmutex.c **** /* Scheduler include files. */
 103:App/Common/Minimal/recmutex.c **** #include "FreeRTOS.h"
 104:App/Common/Minimal/recmutex.c **** #include "task.h"
 105:App/Common/Minimal/recmutex.c **** #include "semphr.h"
 106:App/Common/Minimal/recmutex.c **** 
 107:App/Common/Minimal/recmutex.c **** /* Demo app include files. */
 108:App/Common/Minimal/recmutex.c **** #include "recmutex.h"
 109:App/Common/Minimal/recmutex.c **** 
 110:App/Common/Minimal/recmutex.c **** /* Priorities assigned to the three tasks.  recmuCONTROLLING_TASK_PRIORITY can
 111:App/Common/Minimal/recmutex.c **** be overridden by a definition in FreeRTOSConfig.h. */
 112:App/Common/Minimal/recmutex.c **** #ifndef recmuCONTROLLING_TASK_PRIORITY
 113:App/Common/Minimal/recmutex.c **** 	#define recmuCONTROLLING_TASK_PRIORITY	( tskIDLE_PRIORITY + 2 )
 114:App/Common/Minimal/recmutex.c **** #endif
 115:App/Common/Minimal/recmutex.c **** #define recmuBLOCKING_TASK_PRIORITY		( tskIDLE_PRIORITY + 1 )
 116:App/Common/Minimal/recmutex.c **** #define recmuPOLLING_TASK_PRIORITY		( tskIDLE_PRIORITY + 0 )
 117:App/Common/Minimal/recmutex.c **** 
 118:App/Common/Minimal/recmutex.c **** /* The recursive call depth. */
 119:App/Common/Minimal/recmutex.c **** #define recmuMAX_COUNT					( 10 )
 120:App/Common/Minimal/recmutex.c **** 
 121:App/Common/Minimal/recmutex.c **** /* Misc. */
 122:App/Common/Minimal/recmutex.c **** #define recmuSHORT_DELAY				( 20 / portTICK_RATE_MS )
 123:App/Common/Minimal/recmutex.c **** #define recmuNO_DELAY					( ( portTickType ) 0 )
 124:App/Common/Minimal/recmutex.c **** #define recmuFIVE_TICK_DELAY			( ( portTickType ) 5 )
 125:App/Common/Minimal/recmutex.c **** 
 126:App/Common/Minimal/recmutex.c **** /* The three tasks as described at the top of this file. */
 127:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexControllingTask( void *pvParameters );
 128:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexBlockingTask( void *pvParameters );
 129:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexPollingTask( void *pvParameters );
 130:App/Common/Minimal/recmutex.c **** 
 131:App/Common/Minimal/recmutex.c **** /* The mutex used by the demo. */
 132:App/Common/Minimal/recmutex.c **** static xSemaphoreHandle xMutex;
 133:App/Common/Minimal/recmutex.c **** 
 134:App/Common/Minimal/recmutex.c **** /* Variables used to detect and latch errors. */
 135:App/Common/Minimal/recmutex.c **** static volatile portBASE_TYPE xErrorOccurred = pdFALSE, xControllingIsSuspended = pdFALSE, xBlockin
 136:App/Common/Minimal/recmutex.c **** static volatile unsigned portBASE_TYPE uxControllingCycles = 0, uxBlockingCycles = 0, uxPollingCycl
 137:App/Common/Minimal/recmutex.c **** 
 138:App/Common/Minimal/recmutex.c **** /* Handles of the two higher priority tasks, required so they can be resumed
 139:App/Common/Minimal/recmutex.c **** (unsuspended). */
 140:App/Common/Minimal/recmutex.c **** static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;
 141:App/Common/Minimal/recmutex.c **** 
 142:App/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 143:App/Common/Minimal/recmutex.c **** 
 144:App/Common/Minimal/recmutex.c **** void vStartRecursiveMutexTasks( void )
 145:App/Common/Minimal/recmutex.c **** {
  95              		.loc 1 145 0
  96              		.cfi_startproc
  97              		@ args = 0, pretend = 0, frame = 0
  98              		@ frame_needed = 1, uses_anonymous_args = 0
  99 0000 80B5     		push	{r7, lr}
 100              	.LCFI0:
 101              		.cfi_def_cfa_offset 8
 102              		.cfi_offset 7, -8
 103              		.cfi_offset 14, -4
 104 0002 84B0     		sub	sp, sp, #16
 105              	.LCFI1:
 106              		.cfi_def_cfa_offset 24
 107 0004 04AF     		add	r7, sp, #16
 108              	.LCFI2:
 109              		.cfi_def_cfa 7, 8
 146:App/Common/Minimal/recmutex.c **** 	/* Just creates the mutex and the three tasks. */
 147:App/Common/Minimal/recmutex.c **** 
 148:App/Common/Minimal/recmutex.c **** 	xMutex = xSemaphoreCreateRecursiveMutex();
 110              		.loc 1 148 0
 111 0006 4FF00400 		mov	r0, #4
 112 000a FFF7FEFF 		bl	xQueueCreateMutex
 113 000e 0246     		mov	r2, r0
 114 0010 40F20003 		movw	r3, #:lower16:xMutex
 115 0014 C0F20003 		movt	r3, #:upper16:xMutex
 116 0018 1A60     		str	r2, [r3, #0]
 149:App/Common/Minimal/recmutex.c **** 
 150:App/Common/Minimal/recmutex.c **** 	/* vQueueAddToRegistry() adds the mutex to the registry, if one is
 151:App/Common/Minimal/recmutex.c **** 	in use.  The registry is provided as a means for kernel aware
 152:App/Common/Minimal/recmutex.c **** 	debuggers to locate mutex and has no purpose if a kernel aware debugger
 153:App/Common/Minimal/recmutex.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 154:App/Common/Minimal/recmutex.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 155:App/Common/Minimal/recmutex.c **** 	defined to be less than 1. */
 156:App/Common/Minimal/recmutex.c **** 	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );
 117              		.loc 1 156 0
 118 001a 40F20003 		movw	r3, #:lower16:xMutex
 119 001e C0F20003 		movt	r3, #:upper16:xMutex
 120 0022 1B68     		ldr	r3, [r3, #0]
 121 0024 1846     		mov	r0, r3
 122 0026 40F20001 		movw	r1, #:lower16:.LC0
 123 002a C0F20001 		movt	r1, #:upper16:.LC0
 124 002e FFF7FEFF 		bl	vQueueAddToRegistry
 157:App/Common/Minimal/recmutex.c **** 
 158:App/Common/Minimal/recmutex.c **** 
 159:App/Common/Minimal/recmutex.c **** 	if( xMutex != NULL )
 125              		.loc 1 159 0
 126 0032 40F20003 		movw	r3, #:lower16:xMutex
 127 0036 C0F20003 		movt	r3, #:upper16:xMutex
 128 003a 1B68     		ldr	r3, [r3, #0]
 129 003c 002B     		cmp	r3, #0
 130 003e 51D0     		beq	.L1
 160:App/Common/Minimal/recmutex.c **** 	{
 161:App/Common/Minimal/recmutex.c **** 		xTaskCreate( prvRecursiveMutexControllingTask, ( signed portCHAR * ) "Rec1", configMINIMAL_STACK_
 131              		.loc 1 161 0
 132 0040 4FF00203 		mov	r3, #2
 133 0044 0093     		str	r3, [sp, #0]
 134 0046 40F20003 		movw	r3, #:lower16:xControllingTaskHandle
 135 004a C0F20003 		movt	r3, #:upper16:xControllingTaskHandle
 136 004e 0193     		str	r3, [sp, #4]
 137 0050 4FF00003 		mov	r3, #0
 138 0054 0293     		str	r3, [sp, #8]
 139 0056 4FF00003 		mov	r3, #0
 140 005a 0393     		str	r3, [sp, #12]
 141 005c 40F20000 		movw	r0, #:lower16:prvRecursiveMutexControllingTask
 142 0060 C0F20000 		movt	r0, #:upper16:prvRecursiveMutexControllingTask
 143 0064 40F20001 		movw	r1, #:lower16:.LC1
 144 0068 C0F20001 		movt	r1, #:upper16:.LC1
 145 006c 4FF08202 		mov	r2, #130
 146 0070 4FF00003 		mov	r3, #0
 147 0074 FFF7FEFF 		bl	xTaskGenericCreate
 162:App/Common/Minimal/recmutex.c ****         xTaskCreate( prvRecursiveMutexBlockingTask, ( signed portCHAR * ) "Rec2", configMINIMAL_STA
 148              		.loc 1 162 0
 149 0078 4FF00103 		mov	r3, #1
 150 007c 0093     		str	r3, [sp, #0]
 151 007e 40F20003 		movw	r3, #:lower16:xBlockingTaskHandle
 152 0082 C0F20003 		movt	r3, #:upper16:xBlockingTaskHandle
 153 0086 0193     		str	r3, [sp, #4]
 154 0088 4FF00003 		mov	r3, #0
 155 008c 0293     		str	r3, [sp, #8]
 156 008e 4FF00003 		mov	r3, #0
 157 0092 0393     		str	r3, [sp, #12]
 158 0094 40F20000 		movw	r0, #:lower16:prvRecursiveMutexBlockingTask
 159 0098 C0F20000 		movt	r0, #:upper16:prvRecursiveMutexBlockingTask
 160 009c 40F20001 		movw	r1, #:lower16:.LC2
 161 00a0 C0F20001 		movt	r1, #:upper16:.LC2
 162 00a4 4FF08202 		mov	r2, #130
 163 00a8 4FF00003 		mov	r3, #0
 164 00ac FFF7FEFF 		bl	xTaskGenericCreate
 163:App/Common/Minimal/recmutex.c ****         xTaskCreate( prvRecursiveMutexPollingTask, ( signed portCHAR * ) "Rec3", configMINIMAL_STAC
 165              		.loc 1 163 0
 166 00b0 4FF00003 		mov	r3, #0
 167 00b4 0093     		str	r3, [sp, #0]
 168 00b6 4FF00003 		mov	r3, #0
 169 00ba 0193     		str	r3, [sp, #4]
 170 00bc 4FF00003 		mov	r3, #0
 171 00c0 0293     		str	r3, [sp, #8]
 172 00c2 4FF00003 		mov	r3, #0
 173 00c6 0393     		str	r3, [sp, #12]
 174 00c8 40F20000 		movw	r0, #:lower16:prvRecursiveMutexPollingTask
 175 00cc C0F20000 		movt	r0, #:upper16:prvRecursiveMutexPollingTask
 176 00d0 40F20001 		movw	r1, #:lower16:.LC3
 177 00d4 C0F20001 		movt	r1, #:upper16:.LC3
 178 00d8 4FF08202 		mov	r2, #130
 179 00dc 4FF00003 		mov	r3, #0
 180 00e0 FFF7FEFF 		bl	xTaskGenericCreate
 181              	.L1:
 164:App/Common/Minimal/recmutex.c **** 	}
 165:App/Common/Minimal/recmutex.c **** }
 182              		.loc 1 165 0
 183 00e4 BD46     		mov	sp, r7
 184 00e6 80BD     		pop	{r7, pc}
 185              		.cfi_endproc
 186              	.LFE110:
 188              		.section	.text.prvRecursiveMutexControllingTask,"ax",%progbits
 189              		.align	2
 190              		.thumb
 191              		.thumb_func
 193              	prvRecursiveMutexControllingTask:
 194              	.LFB111:
 166:App/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 167:App/Common/Minimal/recmutex.c **** 
 168:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexControllingTask( void *pvParameters )
 169:App/Common/Minimal/recmutex.c **** {
 195              		.loc 1 169 0
 196              		.cfi_startproc
 197              		@ args = 0, pretend = 0, frame = 16
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199 0000 80B5     		push	{r7, lr}
 200              	.LCFI3:
 201              		.cfi_def_cfa_offset 8
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 84B0     		sub	sp, sp, #16
 205              	.LCFI4:
 206              		.cfi_def_cfa_offset 24
 207 0004 00AF     		add	r7, sp, #0
 208              	.LCFI5:
 209              		.cfi_def_cfa_register 7
 210 0006 7860     		str	r0, [r7, #4]
 211              	.L12:
 170:App/Common/Minimal/recmutex.c **** unsigned portBASE_TYPE ux;
 171:App/Common/Minimal/recmutex.c **** 
 172:App/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 173:App/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 174:App/Common/Minimal/recmutex.c **** 
 175:App/Common/Minimal/recmutex.c **** 	for( ;; )
 176:App/Common/Minimal/recmutex.c **** 	{
 177:App/Common/Minimal/recmutex.c **** 		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
 178:App/Common/Minimal/recmutex.c **** 		it.   The first time through, the mutex will not have been used yet,
 179:App/Common/Minimal/recmutex.c **** 		subsequent times through, at this point the mutex will be held by the
 180:App/Common/Minimal/recmutex.c **** 		polling task. */
 181:App/Common/Minimal/recmutex.c **** 		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 212              		.loc 1 181 0
 213 0008 40F20003 		movw	r3, #:lower16:xMutex
 214 000c C0F20003 		movt	r3, #:upper16:xMutex
 215 0010 1B68     		ldr	r3, [r3, #0]
 216 0012 1846     		mov	r0, r3
 217 0014 FFF7FEFF 		bl	xQueueGiveMutexRecursive
 218 0018 0346     		mov	r3, r0
 219 001a 012B     		cmp	r3, #1
 220 001c 06D1     		bne	.L4
 182:App/Common/Minimal/recmutex.c **** 		{
 183:App/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 221              		.loc 1 183 0
 222 001e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 223 0022 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 224 0026 4FF00102 		mov	r2, #1
 225 002a 1A60     		str	r2, [r3, #0]
 226              	.L4:
 184:App/Common/Minimal/recmutex.c **** 		}
 185:App/Common/Minimal/recmutex.c **** 
 186:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 227              		.loc 1 186 0
 228 002c 4FF00003 		mov	r3, #0
 229 0030 FB60     		str	r3, [r7, #12]
 230 0032 1BE0     		b	.L5
 231              	.L7:
 187:App/Common/Minimal/recmutex.c **** 		{
 188:App/Common/Minimal/recmutex.c **** 			/* We should now be able to take the mutex as many times as
 189:App/Common/Minimal/recmutex.c **** 			we like.
 190:App/Common/Minimal/recmutex.c **** 
 191:App/Common/Minimal/recmutex.c **** 			The first time through the mutex will be immediately available, on
 192:App/Common/Minimal/recmutex.c **** 			subsequent times through the mutex will be held by the polling task
 193:App/Common/Minimal/recmutex.c **** 			at this point and this Take will cause the polling task to inherit
 194:App/Common/Minimal/recmutex.c **** 			the priority of this task.  In this case the block time must be
 195:App/Common/Minimal/recmutex.c **** 			long enough to ensure the polling task will execute again before the
 196:App/Common/Minimal/recmutex.c **** 			block time expires.  If the block time does expire then the error
 197:App/Common/Minimal/recmutex.c **** 			flag will be set here. */
 198:App/Common/Minimal/recmutex.c **** 			if( xSemaphoreTakeRecursive( xMutex, recmuFIVE_TICK_DELAY ) != pdPASS )
 232              		.loc 1 198 0
 233 0034 40F20003 		movw	r3, #:lower16:xMutex
 234 0038 C0F20003 		movt	r3, #:upper16:xMutex
 235 003c 1B68     		ldr	r3, [r3, #0]
 236 003e 1846     		mov	r0, r3
 237 0040 4FF00501 		mov	r1, #5
 238 0044 FFF7FEFF 		bl	xQueueTakeMutexRecursive
 239 0048 0346     		mov	r3, r0
 240 004a 012B     		cmp	r3, #1
 241 004c 06D0     		beq	.L6
 199:App/Common/Minimal/recmutex.c **** 			{
 200:App/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 242              		.loc 1 200 0
 243 004e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 244 0052 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 245 0056 4FF00102 		mov	r2, #1
 246 005a 1A60     		str	r2, [r3, #0]
 247              	.L6:
 201:App/Common/Minimal/recmutex.c **** 			}
 202:App/Common/Minimal/recmutex.c **** 
 203:App/Common/Minimal/recmutex.c **** 			/* Ensure the other task attempting to access the mutex (and the
 204:App/Common/Minimal/recmutex.c **** 			other demo tasks) are able to execute to ensure they either block
 205:App/Common/Minimal/recmutex.c **** 			(where a block time is specified) or return an error (where no
 206:App/Common/Minimal/recmutex.c **** 			block time is specified) as the mutex is held by this task. */
 207:App/Common/Minimal/recmutex.c **** 			vTaskDelay( recmuSHORT_DELAY );
 248              		.loc 1 207 0
 249 005c 4FF01400 		mov	r0, #20
 250 0060 FFF7FEFF 		bl	vTaskDelay
 186:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 251              		.loc 1 186 0
 252 0064 FB68     		ldr	r3, [r7, #12]
 253 0066 03F10103 		add	r3, r3, #1
 254 006a FB60     		str	r3, [r7, #12]
 255              	.L5:
 186:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 256              		.loc 1 186 0 is_stmt 0 discriminator 1
 257 006c FB68     		ldr	r3, [r7, #12]
 258 006e 092B     		cmp	r3, #9
 259 0070 E0D9     		bls	.L7
 208:App/Common/Minimal/recmutex.c **** 		}
 209:App/Common/Minimal/recmutex.c **** 
 210:App/Common/Minimal/recmutex.c **** 		/* For each time we took the mutex, give it back. */
 211:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 260              		.loc 1 211 0 is_stmt 1
 261 0072 4FF00003 		mov	r3, #0
 262 0076 FB60     		str	r3, [r7, #12]
 263 0078 19E0     		b	.L8
 264              	.L10:
 212:App/Common/Minimal/recmutex.c **** 		{
 213:App/Common/Minimal/recmutex.c **** 			/* Ensure the other task attempting to access the mutex (and the
 214:App/Common/Minimal/recmutex.c **** 			other demo tasks) are able to execute. */
 215:App/Common/Minimal/recmutex.c **** 			vTaskDelay( recmuSHORT_DELAY );
 265              		.loc 1 215 0
 266 007a 4FF01400 		mov	r0, #20
 267 007e FFF7FEFF 		bl	vTaskDelay
 216:App/Common/Minimal/recmutex.c **** 
 217:App/Common/Minimal/recmutex.c **** 			/* We should now be able to give the mutex as many times as we
 218:App/Common/Minimal/recmutex.c **** 			took it.  When the mutex is available again the Blocking task
 219:App/Common/Minimal/recmutex.c **** 			should be unblocked but not run because it has a lower priority
 220:App/Common/Minimal/recmutex.c **** 			than this task.  The polling task should also not run at this point
 221:App/Common/Minimal/recmutex.c **** 			as it too has a lower priority than this task. */
 222:App/Common/Minimal/recmutex.c **** 			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 268              		.loc 1 222 0
 269 0082 40F20003 		movw	r3, #:lower16:xMutex
 270 0086 C0F20003 		movt	r3, #:upper16:xMutex
 271 008a 1B68     		ldr	r3, [r3, #0]
 272 008c 1846     		mov	r0, r3
 273 008e FFF7FEFF 		bl	xQueueGiveMutexRecursive
 274 0092 0346     		mov	r3, r0
 275 0094 012B     		cmp	r3, #1
 276 0096 06D0     		beq	.L9
 223:App/Common/Minimal/recmutex.c **** 			{
 224:App/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 277              		.loc 1 224 0
 278 0098 40F20003 		movw	r3, #:lower16:xErrorOccurred
 279 009c C0F20003 		movt	r3, #:upper16:xErrorOccurred
 280 00a0 4FF00102 		mov	r2, #1
 281 00a4 1A60     		str	r2, [r3, #0]
 282              	.L9:
 211:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 283              		.loc 1 211 0
 284 00a6 FB68     		ldr	r3, [r7, #12]
 285 00a8 03F10103 		add	r3, r3, #1
 286 00ac FB60     		str	r3, [r7, #12]
 287              	.L8:
 211:App/Common/Minimal/recmutex.c **** 		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 288              		.loc 1 211 0 is_stmt 0 discriminator 1
 289 00ae FB68     		ldr	r3, [r7, #12]
 290 00b0 092B     		cmp	r3, #9
 291 00b2 E2D9     		bls	.L10
 225:App/Common/Minimal/recmutex.c **** 			}
 226:App/Common/Minimal/recmutex.c **** 		}
 227:App/Common/Minimal/recmutex.c **** 
 228:App/Common/Minimal/recmutex.c **** 		/* Having given it back the same number of times as it was taken, we
 229:App/Common/Minimal/recmutex.c **** 		should no longer be the mutex owner, so the next give should fail. */
 230:App/Common/Minimal/recmutex.c **** 		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 292              		.loc 1 230 0 is_stmt 1
 293 00b4 40F20003 		movw	r3, #:lower16:xMutex
 294 00b8 C0F20003 		movt	r3, #:upper16:xMutex
 295 00bc 1B68     		ldr	r3, [r3, #0]
 296 00be 1846     		mov	r0, r3
 297 00c0 FFF7FEFF 		bl	xQueueGiveMutexRecursive
 298 00c4 0346     		mov	r3, r0
 299 00c6 012B     		cmp	r3, #1
 300 00c8 06D1     		bne	.L11
 231:App/Common/Minimal/recmutex.c **** 		{
 232:App/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 301              		.loc 1 232 0
 302 00ca 40F20003 		movw	r3, #:lower16:xErrorOccurred
 303 00ce C0F20003 		movt	r3, #:upper16:xErrorOccurred
 304 00d2 4FF00102 		mov	r2, #1
 305 00d6 1A60     		str	r2, [r3, #0]
 306              	.L11:
 233:App/Common/Minimal/recmutex.c **** 		}
 234:App/Common/Minimal/recmutex.c **** 
 235:App/Common/Minimal/recmutex.c **** 		/* Keep count of the number of cycles this task has performed so a
 236:App/Common/Minimal/recmutex.c **** 		stall can be detected. */
 237:App/Common/Minimal/recmutex.c **** 		uxControllingCycles++;
 307              		.loc 1 237 0
 308 00d8 40F20003 		movw	r3, #:lower16:uxControllingCycles
 309 00dc C0F20003 		movt	r3, #:upper16:uxControllingCycles
 310 00e0 1B68     		ldr	r3, [r3, #0]
 311 00e2 03F10102 		add	r2, r3, #1
 312 00e6 40F20003 		movw	r3, #:lower16:uxControllingCycles
 313 00ea C0F20003 		movt	r3, #:upper16:uxControllingCycles
 314 00ee 1A60     		str	r2, [r3, #0]
 238:App/Common/Minimal/recmutex.c **** 
 239:App/Common/Minimal/recmutex.c **** 		/* Suspend ourselves so the blocking task can execute. */
 240:App/Common/Minimal/recmutex.c **** 		xControllingIsSuspended = pdTRUE;
 315              		.loc 1 240 0
 316 00f0 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 317 00f4 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 318 00f8 4FF00102 		mov	r2, #1
 319 00fc 1A60     		str	r2, [r3, #0]
 241:App/Common/Minimal/recmutex.c **** 		vTaskSuspend( NULL );
 320              		.loc 1 241 0
 321 00fe 4FF00000 		mov	r0, #0
 322 0102 FFF7FEFF 		bl	vTaskSuspend
 242:App/Common/Minimal/recmutex.c **** 		xControllingIsSuspended = pdFALSE;
 323              		.loc 1 242 0
 324 0106 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 325 010a C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 326 010e 4FF00002 		mov	r2, #0
 327 0112 1A60     		str	r2, [r3, #0]
 243:App/Common/Minimal/recmutex.c **** 	}
 328              		.loc 1 243 0
 329 0114 78E7     		b	.L12
 330              		.cfi_endproc
 331              	.LFE111:
 333 0116 00BF     		.section	.text.prvRecursiveMutexBlockingTask,"ax",%progbits
 334              		.align	2
 335              		.thumb
 336              		.thumb_func
 338              	prvRecursiveMutexBlockingTask:
 339              	.LFB112:
 244:App/Common/Minimal/recmutex.c **** }
 245:App/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 246:App/Common/Minimal/recmutex.c **** 
 247:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexBlockingTask( void *pvParameters )
 248:App/Common/Minimal/recmutex.c **** {
 340              		.loc 1 248 0
 341              		.cfi_startproc
 342              		@ args = 0, pretend = 0, frame = 8
 343              		@ frame_needed = 1, uses_anonymous_args = 0
 344 0000 80B5     		push	{r7, lr}
 345              	.LCFI6:
 346              		.cfi_def_cfa_offset 8
 347              		.cfi_offset 7, -8
 348              		.cfi_offset 14, -4
 349 0002 82B0     		sub	sp, sp, #8
 350              	.LCFI7:
 351              		.cfi_def_cfa_offset 16
 352 0004 00AF     		add	r7, sp, #0
 353              	.LCFI8:
 354              		.cfi_def_cfa_register 7
 355 0006 7860     		str	r0, [r7, #4]
 356              	.L19:
 249:App/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 250:App/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 251:App/Common/Minimal/recmutex.c **** 
 252:App/Common/Minimal/recmutex.c **** 	for( ;; )
 253:App/Common/Minimal/recmutex.c **** 	{
 254:App/Common/Minimal/recmutex.c **** 		/* This task will run while the controlling task is blocked, and the
 255:App/Common/Minimal/recmutex.c **** 		controlling task will block only once it has the mutex - therefore
 256:App/Common/Minimal/recmutex.c **** 		this call should block until the controlling task has given up the
 257:App/Common/Minimal/recmutex.c **** 		mutex, and not actually execute	past this call until the controlling
 258:App/Common/Minimal/recmutex.c **** 		task is suspended.  portMAX_DELAY - 1 is used instead of portMAX_DELAY
 259:App/Common/Minimal/recmutex.c **** 		to ensure the task's state is reported as Blocked and not Suspended in
 260:App/Common/Minimal/recmutex.c **** 		a later call to configASSERT() (within the polling task). */
 261:App/Common/Minimal/recmutex.c **** 		if( xSemaphoreTakeRecursive( xMutex, ( portMAX_DELAY - 1 ) ) == pdPASS )
 357              		.loc 1 261 0
 358 0008 40F20003 		movw	r3, #:lower16:xMutex
 359 000c C0F20003 		movt	r3, #:upper16:xMutex
 360 0010 1B68     		ldr	r3, [r3, #0]
 361 0012 1846     		mov	r0, r3
 362 0014 6FF00101 		mvn	r1, #1
 363 0018 FFF7FEFF 		bl	xQueueTakeMutexRecursive
 364 001c 0346     		mov	r3, r0
 365 001e 012B     		cmp	r3, #1
 366 0020 33D1     		bne	.L14
 262:App/Common/Minimal/recmutex.c **** 		{
 263:App/Common/Minimal/recmutex.c **** 			if( xControllingIsSuspended != pdTRUE )
 367              		.loc 1 263 0
 368 0022 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 369 0026 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 370 002a 1B68     		ldr	r3, [r3, #0]
 371 002c 012B     		cmp	r3, #1
 372 002e 07D0     		beq	.L15
 264:App/Common/Minimal/recmutex.c **** 			{
 265:App/Common/Minimal/recmutex.c **** 				/* Did not expect to execute until the controlling task was
 266:App/Common/Minimal/recmutex.c **** 				suspended. */
 267:App/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 373              		.loc 1 267 0
 374 0030 40F20003 		movw	r3, #:lower16:xErrorOccurred
 375 0034 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 376 0038 4FF00102 		mov	r2, #1
 377 003c 1A60     		str	r2, [r3, #0]
 378 003e 2BE0     		b	.L16
 379              	.L15:
 268:App/Common/Minimal/recmutex.c **** 			}
 269:App/Common/Minimal/recmutex.c **** 			else
 270:App/Common/Minimal/recmutex.c **** 			{
 271:App/Common/Minimal/recmutex.c **** 				/* Give the mutex back before suspending ourselves to allow
 272:App/Common/Minimal/recmutex.c **** 				the polling task to obtain the mutex. */
 273:App/Common/Minimal/recmutex.c **** 				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 380              		.loc 1 273 0
 381 0040 40F20003 		movw	r3, #:lower16:xMutex
 382 0044 C0F20003 		movt	r3, #:upper16:xMutex
 383 0048 1B68     		ldr	r3, [r3, #0]
 384 004a 1846     		mov	r0, r3
 385 004c FFF7FEFF 		bl	xQueueGiveMutexRecursive
 386 0050 0346     		mov	r3, r0
 387 0052 012B     		cmp	r3, #1
 388 0054 06D0     		beq	.L17
 274:App/Common/Minimal/recmutex.c **** 				{
 275:App/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 389              		.loc 1 275 0
 390 0056 40F20003 		movw	r3, #:lower16:xErrorOccurred
 391 005a C0F20003 		movt	r3, #:upper16:xErrorOccurred
 392 005e 4FF00102 		mov	r2, #1
 393 0062 1A60     		str	r2, [r3, #0]
 394              	.L17:
 276:App/Common/Minimal/recmutex.c **** 				}
 277:App/Common/Minimal/recmutex.c **** 
 278:App/Common/Minimal/recmutex.c **** 				xBlockingIsSuspended = pdTRUE;
 395              		.loc 1 278 0
 396 0064 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 397 0068 C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 398 006c 4FF00102 		mov	r2, #1
 399 0070 1A60     		str	r2, [r3, #0]
 279:App/Common/Minimal/recmutex.c **** 				vTaskSuspend( NULL );
 400              		.loc 1 279 0
 401 0072 4FF00000 		mov	r0, #0
 402 0076 FFF7FEFF 		bl	vTaskSuspend
 280:App/Common/Minimal/recmutex.c **** 				xBlockingIsSuspended = pdFALSE;
 403              		.loc 1 280 0
 404 007a 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 405 007e C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 406 0082 4FF00002 		mov	r2, #0
 407 0086 1A60     		str	r2, [r3, #0]
 408 0088 06E0     		b	.L16
 409              	.L14:
 281:App/Common/Minimal/recmutex.c **** 			}
 282:App/Common/Minimal/recmutex.c **** 		}
 283:App/Common/Minimal/recmutex.c **** 		else
 284:App/Common/Minimal/recmutex.c **** 		{
 285:App/Common/Minimal/recmutex.c **** 			/* We should not leave the xSemaphoreTakeRecursive() function
 286:App/Common/Minimal/recmutex.c **** 			until the mutex was obtained. */
 287:App/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 410              		.loc 1 287 0
 411 008a 40F20003 		movw	r3, #:lower16:xErrorOccurred
 412 008e C0F20003 		movt	r3, #:upper16:xErrorOccurred
 413 0092 4FF00102 		mov	r2, #1
 414 0096 1A60     		str	r2, [r3, #0]
 415              	.L16:
 288:App/Common/Minimal/recmutex.c **** 		}
 289:App/Common/Minimal/recmutex.c **** 
 290:App/Common/Minimal/recmutex.c **** 		/* The controlling and blocking tasks should be in lock step. */
 291:App/Common/Minimal/recmutex.c **** 		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
 416              		.loc 1 291 0
 417 0098 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 418 009c C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 419 00a0 1B68     		ldr	r3, [r3, #0]
 420 00a2 03F10102 		add	r2, r3, #1
 421 00a6 40F20003 		movw	r3, #:lower16:uxControllingCycles
 422 00aa C0F20003 		movt	r3, #:upper16:uxControllingCycles
 423 00ae 1B68     		ldr	r3, [r3, #0]
 424 00b0 9A42     		cmp	r2, r3
 425 00b2 06D0     		beq	.L18
 292:App/Common/Minimal/recmutex.c **** 		{
 293:App/Common/Minimal/recmutex.c **** 			xErrorOccurred = pdTRUE;
 426              		.loc 1 293 0
 427 00b4 40F20003 		movw	r3, #:lower16:xErrorOccurred
 428 00b8 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 429 00bc 4FF00102 		mov	r2, #1
 430 00c0 1A60     		str	r2, [r3, #0]
 431              	.L18:
 294:App/Common/Minimal/recmutex.c **** 		}
 295:App/Common/Minimal/recmutex.c **** 
 296:App/Common/Minimal/recmutex.c **** 		/* Keep count of the number of cycles this task has performed so a
 297:App/Common/Minimal/recmutex.c **** 		stall can be detected. */
 298:App/Common/Minimal/recmutex.c **** 		uxBlockingCycles++;
 432              		.loc 1 298 0
 433 00c2 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 434 00c6 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 435 00ca 1B68     		ldr	r3, [r3, #0]
 436 00cc 03F10102 		add	r2, r3, #1
 437 00d0 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 438 00d4 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 439 00d8 1A60     		str	r2, [r3, #0]
 299:App/Common/Minimal/recmutex.c **** 	}
 440              		.loc 1 299 0
 441 00da 95E7     		b	.L19
 442              		.cfi_endproc
 443              	.LFE112:
 445              		.section	.text.prvRecursiveMutexPollingTask,"ax",%progbits
 446              		.align	2
 447              		.thumb
 448              		.thumb_func
 450              	prvRecursiveMutexPollingTask:
 451              	.LFB113:
 300:App/Common/Minimal/recmutex.c **** }
 301:App/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 302:App/Common/Minimal/recmutex.c **** 
 303:App/Common/Minimal/recmutex.c **** static void prvRecursiveMutexPollingTask( void *pvParameters )
 304:App/Common/Minimal/recmutex.c **** {
 452              		.loc 1 304 0
 453              		.cfi_startproc
 454              		@ args = 0, pretend = 0, frame = 8
 455              		@ frame_needed = 1, uses_anonymous_args = 0
 456 0000 80B5     		push	{r7, lr}
 457              	.LCFI9:
 458              		.cfi_def_cfa_offset 8
 459              		.cfi_offset 7, -8
 460              		.cfi_offset 14, -4
 461 0002 82B0     		sub	sp, sp, #8
 462              	.LCFI10:
 463              		.cfi_def_cfa_offset 16
 464 0004 00AF     		add	r7, sp, #0
 465              	.LCFI11:
 466              		.cfi_def_cfa_register 7
 467 0006 7860     		str	r0, [r7, #4]
 468 0008 00E0     		b	.L30
 469              	.L31:
 305:App/Common/Minimal/recmutex.c **** 	/* Just to remove compiler warning. */
 306:App/Common/Minimal/recmutex.c **** 	( void ) pvParameters;
 307:App/Common/Minimal/recmutex.c **** 
 308:App/Common/Minimal/recmutex.c **** 	for( ;; )
 309:App/Common/Minimal/recmutex.c **** 	{
 310:App/Common/Minimal/recmutex.c **** 		/* Keep attempting to obtain the mutex.  We should only obtain it when
 311:App/Common/Minimal/recmutex.c **** 		the blocking task has suspended itself, which in turn should only
 312:App/Common/Minimal/recmutex.c **** 		happen when the controlling task is also suspended. */
 313:App/Common/Minimal/recmutex.c **** 		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
 314:App/Common/Minimal/recmutex.c **** 		{
 315:App/Common/Minimal/recmutex.c **** 			#if( INCLUDE_eTaskGetState == 1 )
 316:App/Common/Minimal/recmutex.c **** 			{
 317:App/Common/Minimal/recmutex.c **** 				configASSERT( eTaskGetState( xControllingTaskHandle ) == eSuspended );
 318:App/Common/Minimal/recmutex.c **** 				configASSERT( eTaskGetState( xBlockingTaskHandle ) == eSuspended );
 319:App/Common/Minimal/recmutex.c **** 			}
 320:App/Common/Minimal/recmutex.c **** 			#endif /* INCLUDE_eTaskGetState */
 321:App/Common/Minimal/recmutex.c **** 
 322:App/Common/Minimal/recmutex.c **** 			/* Is the blocking task suspended? */
 323:App/Common/Minimal/recmutex.c **** 			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 324:App/Common/Minimal/recmutex.c **** 			{
 325:App/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 326:App/Common/Minimal/recmutex.c **** 			}
 327:App/Common/Minimal/recmutex.c **** 			else
 328:App/Common/Minimal/recmutex.c **** 			{
 329:App/Common/Minimal/recmutex.c **** 				/* Keep count of the number of cycles this task has performed
 330:App/Common/Minimal/recmutex.c **** 				so a stall can be detected. */
 331:App/Common/Minimal/recmutex.c **** 				uxPollingCycles++;
 332:App/Common/Minimal/recmutex.c **** 
 333:App/Common/Minimal/recmutex.c **** 				/* We can resume the other tasks here even though they have a
 334:App/Common/Minimal/recmutex.c **** 				higher priority than the polling task.  When they execute they
 335:App/Common/Minimal/recmutex.c **** 				will attempt to obtain the mutex but fail because the polling
 336:App/Common/Minimal/recmutex.c **** 				task is still the mutex holder.  The polling task (this task)
 337:App/Common/Minimal/recmutex.c **** 				will then inherit the higher priority.  The Blocking task will
 338:App/Common/Minimal/recmutex.c **** 				block indefinitely when it attempts to obtain the mutex, the
 339:App/Common/Minimal/recmutex.c **** 				Controlling task will only block for a fixed period and an
 340:App/Common/Minimal/recmutex.c **** 				error will be latched if the polling task has not returned the
 341:App/Common/Minimal/recmutex.c **** 				mutex by the time this fixed period has expired. */
 342:App/Common/Minimal/recmutex.c **** 				vTaskResume( xBlockingTaskHandle );
 343:App/Common/Minimal/recmutex.c ****                 vTaskResume( xControllingTaskHandle );
 344:App/Common/Minimal/recmutex.c **** 
 345:App/Common/Minimal/recmutex.c **** 				/* The other two tasks should now have executed and no longer
 346:App/Common/Minimal/recmutex.c **** 				be suspended. */
 347:App/Common/Minimal/recmutex.c **** 				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 348:App/Common/Minimal/recmutex.c **** 				{
 349:App/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 350:App/Common/Minimal/recmutex.c **** 				}
 351:App/Common/Minimal/recmutex.c **** 
 352:App/Common/Minimal/recmutex.c **** 				#if( INCLUDE_uxTaskPriorityGet == 1 )
 353:App/Common/Minimal/recmutex.c **** 				{
 354:App/Common/Minimal/recmutex.c **** 					/* Check priority inherited. */
 355:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
 356:App/Common/Minimal/recmutex.c **** 				}
 357:App/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_uxTaskPriorityGet */
 358:App/Common/Minimal/recmutex.c **** 
 359:App/Common/Minimal/recmutex.c **** 				#if( INCLUDE_eTaskGetState == 1 )
 360:App/Common/Minimal/recmutex.c **** 				{
 361:App/Common/Minimal/recmutex.c **** 					configASSERT( eTaskGetState( xControllingTaskHandle ) == eBlocked );
 362:App/Common/Minimal/recmutex.c **** 					configASSERT( eTaskGetState( xBlockingTaskHandle ) == eBlocked );
 363:App/Common/Minimal/recmutex.c **** 				}
 364:App/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_eTaskGetState */
 365:App/Common/Minimal/recmutex.c **** 
 366:App/Common/Minimal/recmutex.c **** 				/* Release the mutex, disinheriting the higher priority again. */
 367:App/Common/Minimal/recmutex.c **** 				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 368:App/Common/Minimal/recmutex.c **** 				{
 369:App/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 370:App/Common/Minimal/recmutex.c **** 				}
 371:App/Common/Minimal/recmutex.c **** 
 372:App/Common/Minimal/recmutex.c **** 				#if( INCLUDE_uxTaskPriorityGet == 1 )
 373:App/Common/Minimal/recmutex.c **** 				{
 374:App/Common/Minimal/recmutex.c **** 					/* Check priority disinherited. */
 375:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
 376:App/Common/Minimal/recmutex.c **** 				}
 377:App/Common/Minimal/recmutex.c **** 				#endif /* INCLUDE_uxTaskPriorityGet */
 378:App/Common/Minimal/recmutex.c **** 			}
 379:App/Common/Minimal/recmutex.c **** 		}
 380:App/Common/Minimal/recmutex.c **** 
 381:App/Common/Minimal/recmutex.c **** 		#if configUSE_PREEMPTION == 0
 382:App/Common/Minimal/recmutex.c **** 		{
 383:App/Common/Minimal/recmutex.c **** 			taskYIELD();
 384:App/Common/Minimal/recmutex.c **** 		}
 385:App/Common/Minimal/recmutex.c **** 		#endif
 386:App/Common/Minimal/recmutex.c **** 	}
 470              		.loc 1 386 0
 471 000a 00BF     		nop
 472              	.L30:
 313:App/Common/Minimal/recmutex.c **** 		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
 473              		.loc 1 313 0
 474 000c 40F20003 		movw	r3, #:lower16:xMutex
 475 0010 C0F20003 		movt	r3, #:upper16:xMutex
 476 0014 1B68     		ldr	r3, [r3, #0]
 477 0016 1846     		mov	r0, r3
 478 0018 4FF00001 		mov	r1, #0
 479 001c FFF7FEFF 		bl	xQueueTakeMutexRecursive
 480 0020 0346     		mov	r3, r0
 481 0022 012B     		cmp	r3, #1
 482 0024 F1D1     		bne	.L31
 323:App/Common/Minimal/recmutex.c **** 			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 483              		.loc 1 323 0
 484 0026 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 485 002a C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 486 002e 1B68     		ldr	r3, [r3, #0]
 487 0030 012B     		cmp	r3, #1
 488 0032 06D1     		bne	.L22
 323:App/Common/Minimal/recmutex.c **** 			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 489              		.loc 1 323 0 is_stmt 0 discriminator 1
 490 0034 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 491 0038 C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 492 003c 1B68     		ldr	r3, [r3, #0]
 493 003e 012B     		cmp	r3, #1
 494 0040 07D0     		beq	.L23
 495              	.L22:
 325:App/Common/Minimal/recmutex.c **** 				xErrorOccurred = pdTRUE;
 496              		.loc 1 325 0 is_stmt 1
 497 0042 40F20003 		movw	r3, #:lower16:xErrorOccurred
 498 0046 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 499 004a 4FF00102 		mov	r2, #1
 500 004e 1A60     		str	r2, [r3, #0]
 501              		.loc 1 386 0
 502 0050 DBE7     		b	.L31
 503              	.L23:
 331:App/Common/Minimal/recmutex.c **** 				uxPollingCycles++;
 504              		.loc 1 331 0
 505 0052 40F20003 		movw	r3, #:lower16:uxPollingCycles
 506 0056 C0F20003 		movt	r3, #:upper16:uxPollingCycles
 507 005a 1B68     		ldr	r3, [r3, #0]
 508 005c 03F10102 		add	r2, r3, #1
 509 0060 40F20003 		movw	r3, #:lower16:uxPollingCycles
 510 0064 C0F20003 		movt	r3, #:upper16:uxPollingCycles
 511 0068 1A60     		str	r2, [r3, #0]
 342:App/Common/Minimal/recmutex.c **** 				vTaskResume( xBlockingTaskHandle );
 512              		.loc 1 342 0
 513 006a 40F20003 		movw	r3, #:lower16:xBlockingTaskHandle
 514 006e C0F20003 		movt	r3, #:upper16:xBlockingTaskHandle
 515 0072 1B68     		ldr	r3, [r3, #0]
 516 0074 1846     		mov	r0, r3
 517 0076 FFF7FEFF 		bl	vTaskResume
 343:App/Common/Minimal/recmutex.c ****                 vTaskResume( xControllingTaskHandle );
 518              		.loc 1 343 0
 519 007a 40F20003 		movw	r3, #:lower16:xControllingTaskHandle
 520 007e C0F20003 		movt	r3, #:upper16:xControllingTaskHandle
 521 0082 1B68     		ldr	r3, [r3, #0]
 522 0084 1846     		mov	r0, r3
 523 0086 FFF7FEFF 		bl	vTaskResume
 347:App/Common/Minimal/recmutex.c **** 				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 524              		.loc 1 347 0
 525 008a 40F20003 		movw	r3, #:lower16:xBlockingIsSuspended
 526 008e C0F20003 		movt	r3, #:upper16:xBlockingIsSuspended
 527 0092 1B68     		ldr	r3, [r3, #0]
 528 0094 012B     		cmp	r3, #1
 529 0096 06D0     		beq	.L24
 347:App/Common/Minimal/recmutex.c **** 				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 530              		.loc 1 347 0 is_stmt 0 discriminator 1
 531 0098 40F20003 		movw	r3, #:lower16:xControllingIsSuspended
 532 009c C0F20003 		movt	r3, #:upper16:xControllingIsSuspended
 533 00a0 1B68     		ldr	r3, [r3, #0]
 534 00a2 012B     		cmp	r3, #1
 535 00a4 06D1     		bne	.L25
 536              	.L24:
 349:App/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 537              		.loc 1 349 0 is_stmt 1
 538 00a6 40F20003 		movw	r3, #:lower16:xErrorOccurred
 539 00aa C0F20003 		movt	r3, #:upper16:xErrorOccurred
 540 00ae 4FF00102 		mov	r2, #1
 541 00b2 1A60     		str	r2, [r3, #0]
 542              	.L25:
 355:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
 543              		.loc 1 355 0
 544 00b4 4FF00000 		mov	r0, #0
 545 00b8 FFF7FEFF 		bl	uxTaskPriorityGet
 546 00bc 0346     		mov	r3, r0
 547 00be 022B     		cmp	r3, #2
 548 00c0 02D0     		beq	.L26
 355:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
 549              		.loc 1 355 0 is_stmt 0 discriminator 1
 550 00c2 FFF7FEFF 		bl	ulPortSetInterruptMask
 551              	.L27:
 355:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuCONTROLLING_TASK_PRIORITY );
 552              		.loc 1 355 0 discriminator 2
 553 00c6 FEE7     		b	.L27
 554              	.L26:
 367:App/Common/Minimal/recmutex.c **** 				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 555              		.loc 1 367 0 is_stmt 1
 556 00c8 40F20003 		movw	r3, #:lower16:xMutex
 557 00cc C0F20003 		movt	r3, #:upper16:xMutex
 558 00d0 1B68     		ldr	r3, [r3, #0]
 559 00d2 1846     		mov	r0, r3
 560 00d4 FFF7FEFF 		bl	xQueueGiveMutexRecursive
 561 00d8 0346     		mov	r3, r0
 562 00da 012B     		cmp	r3, #1
 563 00dc 06D0     		beq	.L28
 369:App/Common/Minimal/recmutex.c **** 					xErrorOccurred = pdTRUE;
 564              		.loc 1 369 0
 565 00de 40F20003 		movw	r3, #:lower16:xErrorOccurred
 566 00e2 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 567 00e6 4FF00102 		mov	r2, #1
 568 00ea 1A60     		str	r2, [r3, #0]
 569              	.L28:
 375:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
 570              		.loc 1 375 0
 571 00ec 4FF00000 		mov	r0, #0
 572 00f0 FFF7FEFF 		bl	uxTaskPriorityGet
 573 00f4 0346     		mov	r3, r0
 574 00f6 002B     		cmp	r3, #0
 575 00f8 87D0     		beq	.L31
 375:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
 576              		.loc 1 375 0 is_stmt 0 discriminator 1
 577 00fa FFF7FEFF 		bl	ulPortSetInterruptMask
 578              	.L29:
 375:App/Common/Minimal/recmutex.c **** 					configASSERT( uxTaskPriorityGet( NULL ) == recmuPOLLING_TASK_PRIORITY );
 579              		.loc 1 375 0 discriminator 2
 580 00fe FEE7     		b	.L29
 581              		.cfi_endproc
 582              	.LFE113:
 584              		.section	.text.xAreRecursiveMutexTasksStillRunning,"ax",%progbits
 585              		.align	2
 586              		.global	xAreRecursiveMutexTasksStillRunning
 587              		.thumb
 588              		.thumb_func
 590              	xAreRecursiveMutexTasksStillRunning:
 591              	.LFB114:
 387:App/Common/Minimal/recmutex.c **** }
 388:App/Common/Minimal/recmutex.c **** /*-----------------------------------------------------------*/
 389:App/Common/Minimal/recmutex.c **** 
 390:App/Common/Minimal/recmutex.c **** /* This is called to check that all the created tasks are still running. */
 391:App/Common/Minimal/recmutex.c **** portBASE_TYPE xAreRecursiveMutexTasksStillRunning( void )
 392:App/Common/Minimal/recmutex.c **** {
 592              		.loc 1 392 0 is_stmt 1
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 8
 595              		@ frame_needed = 1, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 597 0000 80B4     		push	{r7}
 598              	.LCFI12:
 599              		.cfi_def_cfa_offset 4
 600              		.cfi_offset 7, -4
 601 0002 83B0     		sub	sp, sp, #12
 602              	.LCFI13:
 603              		.cfi_def_cfa_offset 16
 604 0004 00AF     		add	r7, sp, #0
 605              	.LCFI14:
 606              		.cfi_def_cfa_register 7
 393:App/Common/Minimal/recmutex.c **** portBASE_TYPE xReturn;
 394:App/Common/Minimal/recmutex.c **** static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingC
 395:App/Common/Minimal/recmutex.c **** 
 396:App/Common/Minimal/recmutex.c **** 	/* Is the controlling task still cycling? */
 397:App/Common/Minimal/recmutex.c **** 	if( uxLastControllingCycles == uxControllingCycles )
 607              		.loc 1 397 0
 608 0006 40F20003 		movw	r3, #:lower16:uxLastControllingCycles.7663
 609 000a C0F20003 		movt	r3, #:upper16:uxLastControllingCycles.7663
 610 000e 1A68     		ldr	r2, [r3, #0]
 611 0010 40F20003 		movw	r3, #:lower16:uxControllingCycles
 612 0014 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 613 0018 1B68     		ldr	r3, [r3, #0]
 614 001a 9A42     		cmp	r2, r3
 615 001c 07D1     		bne	.L33
 398:App/Common/Minimal/recmutex.c **** 	{
 399:App/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 616              		.loc 1 399 0
 617 001e 40F20003 		movw	r3, #:lower16:xErrorOccurred
 618 0022 C0F20003 		movt	r3, #:upper16:xErrorOccurred
 619 0026 4FF00102 		mov	r2, #1
 620 002a 1A60     		str	r2, [r3, #0]
 621 002c 09E0     		b	.L34
 622              	.L33:
 400:App/Common/Minimal/recmutex.c **** 	}
 401:App/Common/Minimal/recmutex.c **** 	else
 402:App/Common/Minimal/recmutex.c **** 	{
 403:App/Common/Minimal/recmutex.c **** 		uxLastControllingCycles = uxControllingCycles;
 623              		.loc 1 403 0
 624 002e 40F20003 		movw	r3, #:lower16:uxControllingCycles
 625 0032 C0F20003 		movt	r3, #:upper16:uxControllingCycles
 626 0036 1A68     		ldr	r2, [r3, #0]
 627 0038 40F20003 		movw	r3, #:lower16:uxLastControllingCycles.7663
 628 003c C0F20003 		movt	r3, #:upper16:uxLastControllingCycles.7663
 629 0040 1A60     		str	r2, [r3, #0]
 630              	.L34:
 404:App/Common/Minimal/recmutex.c **** 	}
 405:App/Common/Minimal/recmutex.c **** 
 406:App/Common/Minimal/recmutex.c **** 	/* Is the blocking task still cycling? */
 407:App/Common/Minimal/recmutex.c **** 	if( uxLastBlockingCycles == uxBlockingCycles )
 631              		.loc 1 407 0
 632 0042 40F20003 		movw	r3, #:lower16:uxLastBlockingCycles.7664
 633 0046 C0F20003 		movt	r3, #:upper16:uxLastBlockingCycles.7664
 634 004a 1A68     		ldr	r2, [r3, #0]
 635 004c 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 636 0050 C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 637 0054 1B68     		ldr	r3, [r3, #0]
 638 0056 9A42     		cmp	r2, r3
 639 0058 07D1     		bne	.L35
 408:App/Common/Minimal/recmutex.c **** 	{
 409:App/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 640              		.loc 1 409 0
 641 005a 40F20003 		movw	r3, #:lower16:xErrorOccurred
 642 005e C0F20003 		movt	r3, #:upper16:xErrorOccurred
 643 0062 4FF00102 		mov	r2, #1
 644 0066 1A60     		str	r2, [r3, #0]
 645 0068 09E0     		b	.L36
 646              	.L35:
 410:App/Common/Minimal/recmutex.c **** 	}
 411:App/Common/Minimal/recmutex.c **** 	else
 412:App/Common/Minimal/recmutex.c **** 	{
 413:App/Common/Minimal/recmutex.c **** 		uxLastBlockingCycles = uxBlockingCycles;
 647              		.loc 1 413 0
 648 006a 40F20003 		movw	r3, #:lower16:uxBlockingCycles
 649 006e C0F20003 		movt	r3, #:upper16:uxBlockingCycles
 650 0072 1A68     		ldr	r2, [r3, #0]
 651 0074 40F20003 		movw	r3, #:lower16:uxLastBlockingCycles.7664
 652 0078 C0F20003 		movt	r3, #:upper16:uxLastBlockingCycles.7664
 653 007c 1A60     		str	r2, [r3, #0]
 654              	.L36:
 414:App/Common/Minimal/recmutex.c **** 	}
 415:App/Common/Minimal/recmutex.c **** 
 416:App/Common/Minimal/recmutex.c **** 	/* Is the polling task still cycling? */
 417:App/Common/Minimal/recmutex.c **** 	if( uxLastPollingCycles == uxPollingCycles )
 655              		.loc 1 417 0
 656 007e 40F20003 		movw	r3, #:lower16:uxLastPollingCycles.7665
 657 0082 C0F20003 		movt	r3, #:upper16:uxLastPollingCycles.7665
 658 0086 1A68     		ldr	r2, [r3, #0]
 659 0088 40F20003 		movw	r3, #:lower16:uxPollingCycles
 660 008c C0F20003 		movt	r3, #:upper16:uxPollingCycles
 661 0090 1B68     		ldr	r3, [r3, #0]
 662 0092 9A42     		cmp	r2, r3
 663 0094 07D1     		bne	.L37
 418:App/Common/Minimal/recmutex.c **** 	{
 419:App/Common/Minimal/recmutex.c **** 		xErrorOccurred = pdTRUE;
 664              		.loc 1 419 0
 665 0096 40F20003 		movw	r3, #:lower16:xErrorOccurred
 666 009a C0F20003 		movt	r3, #:upper16:xErrorOccurred
 667 009e 4FF00102 		mov	r2, #1
 668 00a2 1A60     		str	r2, [r3, #0]
 669 00a4 09E0     		b	.L38
 670              	.L37:
 420:App/Common/Minimal/recmutex.c **** 	}
 421:App/Common/Minimal/recmutex.c **** 	else
 422:App/Common/Minimal/recmutex.c **** 	{
 423:App/Common/Minimal/recmutex.c **** 		uxLastPollingCycles = uxPollingCycles;
 671              		.loc 1 423 0
 672 00a6 40F20003 		movw	r3, #:lower16:uxPollingCycles
 673 00aa C0F20003 		movt	r3, #:upper16:uxPollingCycles
 674 00ae 1A68     		ldr	r2, [r3, #0]
 675 00b0 40F20003 		movw	r3, #:lower16:uxLastPollingCycles.7665
 676 00b4 C0F20003 		movt	r3, #:upper16:uxLastPollingCycles.7665
 677 00b8 1A60     		str	r2, [r3, #0]
 678              	.L38:
 424:App/Common/Minimal/recmutex.c **** 	}
 425:App/Common/Minimal/recmutex.c **** 
 426:App/Common/Minimal/recmutex.c **** 	if( xErrorOccurred == pdTRUE )
 679              		.loc 1 426 0
 680 00ba 40F20003 		movw	r3, #:lower16:xErrorOccurred
 681 00be C0F20003 		movt	r3, #:upper16:xErrorOccurred
 682 00c2 1B68     		ldr	r3, [r3, #0]
 683 00c4 012B     		cmp	r3, #1
 684 00c6 03D1     		bne	.L39
 427:App/Common/Minimal/recmutex.c **** 	{
 428:App/Common/Minimal/recmutex.c **** 		xReturn = pdFAIL;
 685              		.loc 1 428 0
 686 00c8 4FF00003 		mov	r3, #0
 687 00cc 7B60     		str	r3, [r7, #4]
 688 00ce 02E0     		b	.L40
 689              	.L39:
 429:App/Common/Minimal/recmutex.c **** 	}
 430:App/Common/Minimal/recmutex.c **** 	else
 431:App/Common/Minimal/recmutex.c **** 	{
 432:App/Common/Minimal/recmutex.c **** 		xReturn = pdTRUE;
 690              		.loc 1 432 0
 691 00d0 4FF00103 		mov	r3, #1
 692 00d4 7B60     		str	r3, [r7, #4]
 693              	.L40:
 433:App/Common/Minimal/recmutex.c **** 	}
 434:App/Common/Minimal/recmutex.c **** 
 435:App/Common/Minimal/recmutex.c **** 	return xReturn;
 694              		.loc 1 435 0
 695 00d6 7B68     		ldr	r3, [r7, #4]
 436:App/Common/Minimal/recmutex.c **** }
 696              		.loc 1 436 0
 697 00d8 1846     		mov	r0, r3
 698 00da 07F10C07 		add	r7, r7, #12
 699 00de BD46     		mov	sp, r7
 700 00e0 80BC     		pop	{r7}
 701 00e2 7047     		bx	lr
 702              		.cfi_endproc
 703              	.LFE114:
 705              		.section	.bss.uxLastControllingCycles.7663,"aw",%nobits
 706              		.align	2
 709              	uxLastControllingCycles.7663:
 710 0000 00000000 		.space	4
 711              		.section	.bss.uxLastBlockingCycles.7664,"aw",%nobits
 712              		.align	2
 715              	uxLastBlockingCycles.7664:
 716 0000 00000000 		.space	4
 717              		.section	.bss.uxLastPollingCycles.7665,"aw",%nobits
 718              		.align	2
 721              	uxLastPollingCycles.7665:
 722 0000 00000000 		.space	4
 723              		.text
 724              	.Letext0:
 725              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 726              		.file 3 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 727              		.file 4 "Source/include/task.h"
 728              		.file 5 "Source/include/queue.h"
 729              		.file 6 "Source/include/semphr.h"
 730              		.file 7 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 recmutex.c
     /tmp/ccOTG2ka.s:20     .bss.xMutex:00000000 $d
     /tmp/ccOTG2ka.s:23     .bss.xMutex:00000000 xMutex
     /tmp/ccOTG2ka.s:26     .bss.xErrorOccurred:00000000 $d
     /tmp/ccOTG2ka.s:29     .bss.xErrorOccurred:00000000 xErrorOccurred
     /tmp/ccOTG2ka.s:32     .bss.xControllingIsSuspended:00000000 $d
     /tmp/ccOTG2ka.s:35     .bss.xControllingIsSuspended:00000000 xControllingIsSuspended
     /tmp/ccOTG2ka.s:38     .bss.xBlockingIsSuspended:00000000 $d
     /tmp/ccOTG2ka.s:41     .bss.xBlockingIsSuspended:00000000 xBlockingIsSuspended
     /tmp/ccOTG2ka.s:44     .bss.uxControllingCycles:00000000 $d
     /tmp/ccOTG2ka.s:47     .bss.uxControllingCycles:00000000 uxControllingCycles
     /tmp/ccOTG2ka.s:50     .bss.uxBlockingCycles:00000000 $d
     /tmp/ccOTG2ka.s:53     .bss.uxBlockingCycles:00000000 uxBlockingCycles
     /tmp/ccOTG2ka.s:56     .bss.uxPollingCycles:00000000 $d
     /tmp/ccOTG2ka.s:59     .bss.uxPollingCycles:00000000 uxPollingCycles
     /tmp/ccOTG2ka.s:62     .bss.xControllingTaskHandle:00000000 $d
     /tmp/ccOTG2ka.s:65     .bss.xControllingTaskHandle:00000000 xControllingTaskHandle
     /tmp/ccOTG2ka.s:68     .bss.xBlockingTaskHandle:00000000 $d
     /tmp/ccOTG2ka.s:71     .bss.xBlockingTaskHandle:00000000 xBlockingTaskHandle
     /tmp/ccOTG2ka.s:74     .rodata:00000000 $d
     /tmp/ccOTG2ka.s:75     .rodata:00000000 .LC0
     /tmp/ccOTG2ka.s:78     .rodata:00000010 .LC1
     /tmp/ccOTG2ka.s:81     .rodata:00000018 .LC2
     /tmp/ccOTG2ka.s:84     .rodata:00000020 .LC3
     /tmp/ccOTG2ka.s:87     .text.vStartRecursiveMutexTasks:00000000 $t
     /tmp/ccOTG2ka.s:92     .text.vStartRecursiveMutexTasks:00000000 vStartRecursiveMutexTasks
     /tmp/ccOTG2ka.s:193    .text.prvRecursiveMutexControllingTask:00000000 prvRecursiveMutexControllingTask
     /tmp/ccOTG2ka.s:338    .text.prvRecursiveMutexBlockingTask:00000000 prvRecursiveMutexBlockingTask
     /tmp/ccOTG2ka.s:450    .text.prvRecursiveMutexPollingTask:00000000 prvRecursiveMutexPollingTask
     /tmp/ccOTG2ka.s:189    .text.prvRecursiveMutexControllingTask:00000000 $t
     /tmp/ccOTG2ka.s:334    .text.prvRecursiveMutexBlockingTask:00000000 $t
     /tmp/ccOTG2ka.s:446    .text.prvRecursiveMutexPollingTask:00000000 $t
     /tmp/ccOTG2ka.s:585    .text.xAreRecursiveMutexTasksStillRunning:00000000 $t
     /tmp/ccOTG2ka.s:590    .text.xAreRecursiveMutexTasksStillRunning:00000000 xAreRecursiveMutexTasksStillRunning
     /tmp/ccOTG2ka.s:709    .bss.uxLastControllingCycles.7663:00000000 uxLastControllingCycles.7663
     /tmp/ccOTG2ka.s:715    .bss.uxLastBlockingCycles.7664:00000000 uxLastBlockingCycles.7664
     /tmp/ccOTG2ka.s:721    .bss.uxLastPollingCycles.7665:00000000 uxLastPollingCycles.7665
     /tmp/ccOTG2ka.s:706    .bss.uxLastControllingCycles.7663:00000000 $d
     /tmp/ccOTG2ka.s:712    .bss.uxLastBlockingCycles.7664:00000000 $d
     /tmp/ccOTG2ka.s:718    .bss.uxLastPollingCycles.7665:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueCreateMutex
vQueueAddToRegistry
xTaskGenericCreate
xQueueGiveMutexRecursive
xQueueTakeMutexRecursive
vTaskDelay
vTaskSuspend
vTaskResume
uxTaskPriorityGet
ulPortSetInterruptMask
