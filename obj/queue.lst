   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	xQueueRegistry,64,4
  20              		.section	.text.xQueueGenericReset,"ax",%progbits
  21              		.align	2
  22              		.global	xQueueGenericReset
  23              		.thumb
  24              		.thumb_func
  26              	xQueueGenericReset:
  27              	.LFB110:
  28              		.file 1 "Source/queue.c"
   1:Source/queue.c **** /*
   2:Source/queue.c ****     FreeRTOS V7.5.3 - Copyright (C) 2013 Real Time Engineers Ltd. 
   3:Source/queue.c ****     All rights reserved
   4:Source/queue.c **** 
   5:Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:Source/queue.c **** 
   7:Source/queue.c ****     ***************************************************************************
   8:Source/queue.c ****      *                                                                       *
   9:Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  10:Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  11:Source/queue.c ****      *    platform software that has become a de facto standard.             *
  12:Source/queue.c ****      *                                                                       *
  13:Source/queue.c ****      *    Help yourself get started quickly and support the FreeRTOS         *
  14:Source/queue.c ****      *    project by purchasing a FreeRTOS tutorial book, reference          *
  15:Source/queue.c ****      *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
  16:Source/queue.c ****      *                                                                       *
  17:Source/queue.c ****      *    Thank you!                                                         *
  18:Source/queue.c ****      *                                                                       *
  19:Source/queue.c ****     ***************************************************************************
  20:Source/queue.c **** 
  21:Source/queue.c ****     This file is part of the FreeRTOS distribution.
  22:Source/queue.c **** 
  23:Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  24:Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  25:Source/queue.c ****     Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
  26:Source/queue.c **** 
  27:Source/queue.c ****     >>! NOTE: The modification to the GPL is included to allow you to distribute
  28:Source/queue.c ****     >>! a combined work that includes FreeRTOS without being obliged to provide
  29:Source/queue.c ****     >>! the source code for proprietary components outside of the FreeRTOS
  30:Source/queue.c ****     >>! kernel.
  31:Source/queue.c **** 
  32:Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  33:Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  34:Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available from the following
  35:Source/queue.c ****     link: http://www.freertos.org/a00114.html
  36:Source/queue.c **** 
  37:Source/queue.c ****     1 tab == 4 spaces!
  38:Source/queue.c **** 
  39:Source/queue.c ****     ***************************************************************************
  40:Source/queue.c ****      *                                                                       *
  41:Source/queue.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  42:Source/queue.c ****      *    not run, what could be wrong?"                                     *
  43:Source/queue.c ****      *                                                                       *
  44:Source/queue.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  45:Source/queue.c ****      *                                                                       *
  46:Source/queue.c ****     ***************************************************************************
  47:Source/queue.c **** 
  48:Source/queue.c ****     http://www.FreeRTOS.org - Documentation, books, training, latest versions,
  49:Source/queue.c ****     license and Real Time Engineers Ltd. contact details.
  50:Source/queue.c **** 
  51:Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  52:Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  53:Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  54:Source/queue.c **** 
  55:Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
  56:Source/queue.c ****     Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
  57:Source/queue.c ****     licenses offer ticketed support, indemnification and middleware.
  58:Source/queue.c **** 
  59:Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  60:Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  61:Source/queue.c ****     mission critical applications that require provable dependability.
  62:Source/queue.c **** 
  63:Source/queue.c ****     1 tab == 4 spaces!
  64:Source/queue.c **** */
  65:Source/queue.c **** 
  66:Source/queue.c **** #include <stdlib.h>
  67:Source/queue.c **** #include <string.h>
  68:Source/queue.c **** 
  69:Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  70:Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  71:Source/queue.c **** task.h is included from an application file. */
  72:Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  73:Source/queue.c **** 
  74:Source/queue.c **** #include "FreeRTOS.h"
  75:Source/queue.c **** #include "task.h"
  76:Source/queue.c **** #include "queue.h"
  77:Source/queue.c **** 
  78:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  79:Source/queue.c **** 	#include "croutine.h"
  80:Source/queue.c **** #endif
  81:Source/queue.c **** 
  82:Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  83:Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  84:Source/queue.c **** header files above, but not in this file, in order to generate the correct
  85:Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  86:Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  87:Source/queue.c **** 
  88:Source/queue.c **** 
  89:Source/queue.c **** /* Constants used with the cRxLock and xTxLock structure members. */
  90:Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  91:Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  92:Source/queue.c **** 
  93:Source/queue.c **** /* When the xQUEUE structure is used to represent a base queue its pcHead and
  94:Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  95:Source/queue.c **** xQUEUE structure is used to represent a mutex pcHead and pcTail pointers are
  96:Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  97:Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
  98:Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
  99:Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 100:Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 101:Source/queue.c **** against the coding standard (although an exception to the standard has been
 102:Source/queue.c **** permitted where the dual use also significantly changes the type of the
 103:Source/queue.c **** structure member). */
 104:Source/queue.c **** #define pxMutexHolder					pcTail
 105:Source/queue.c **** #define uxQueueType						pcHead
 106:Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 107:Source/queue.c **** 
 108:Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 109:Source/queue.c **** zero. */
 110:Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
 111:Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
 112:Source/queue.c **** 
 113:Source/queue.c **** 
 114:Source/queue.c **** /*
 115:Source/queue.c ****  * Definition of the queue used by the scheduler.
 116:Source/queue.c ****  * Items are queued by copy, not reference.
 117:Source/queue.c ****  */
 118:Source/queue.c **** typedef struct QueueDefinition
 119:Source/queue.c **** {
 120:Source/queue.c **** 	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
 121:Source/queue.c **** 	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more b
 122:Source/queue.c **** 
 123:Source/queue.c **** 	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
 124:Source/queue.c **** 
 125:Source/queue.c **** 	union									/* Use of a union is an exception to the coding standard to ensure two mutually excl
 126:Source/queue.c **** 	{
 127:Source/queue.c **** 		signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from when the
 128:Source/queue.c **** 		unsigned portBASE_TYPE uxRecursiveCallCount;/*< Maintains a count of the numebr of times a recurs
 129:Source/queue.c **** 	} u;
 130:Source/queue.c **** 
 131:Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 132:Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 133:Source/queue.c **** 
 134:Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 135:Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 136:Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 137:Source/queue.c **** 
 138:Source/queue.c **** 	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (rem
 139:Source/queue.c **** 	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (ad
 140:Source/queue.c **** 
 141:Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 142:Source/queue.c **** 		unsigned char ucQueueNumber;
 143:Source/queue.c **** 		unsigned char ucQueueType;
 144:Source/queue.c **** 	#endif
 145:Source/queue.c **** 
 146:Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 147:Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 148:Source/queue.c **** 	#endif
 149:Source/queue.c **** 
 150:Source/queue.c **** } xQUEUE;
 151:Source/queue.c **** /*-----------------------------------------------------------*/
 152:Source/queue.c **** 
 153:Source/queue.c **** /*
 154:Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 155:Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 156:Source/queue.c ****  */
 157:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 158:Source/queue.c **** 
 159:Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 160:Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 161:Source/queue.c **** 	more user friendly. */
 162:Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 163:Source/queue.c **** 	{
 164:Source/queue.c **** 		signed char *pcQueueName;
 165:Source/queue.c **** 		xQueueHandle xHandle;
 166:Source/queue.c **** 	} xQueueRegistryItem;
 167:Source/queue.c **** 
 168:Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 169:Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 170:Source/queue.c **** 	array position being vacant. */
 171:Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 172:Source/queue.c **** 
 173:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 174:Source/queue.c **** 
 175:Source/queue.c **** /*
 176:Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 177:Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 178:Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 179:Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 180:Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 181:Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 182:Source/queue.c ****  */
 183:Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 184:Source/queue.c **** 
 185:Source/queue.c **** /*
 186:Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 187:Source/queue.c ****  *
 188:Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 189:Source/queue.c ****  */
 190:Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 191:Source/queue.c **** 
 192:Source/queue.c **** /*
 193:Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 194:Source/queue.c ****  *
 195:Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 196:Source/queue.c ****  */
 197:Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
 198:Source/queue.c **** 
 199:Source/queue.c **** /*
 200:Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 201:Source/queue.c ****  * back of the queue.
 202:Source/queue.c ****  */
 203:Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 204:Source/queue.c **** 
 205:Source/queue.c **** /*
 206:Source/queue.c ****  * Copies an item out of a queue.
 207:Source/queue.c ****  */
 208:Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer ) PRIVILEGED_
 209:Source/queue.c **** 
 210:Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 211:Source/queue.c **** 	/*
 212:Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 213:Source/queue.c **** 	 * the queue set that the queue contains data.
 214:Source/queue.c **** 	 */
 215:Source/queue.c **** 	static portBASE_TYPE prvNotifyQueueSetContainer( const xQUEUE * const pxQueue, portBASE_TYPE xCopy
 216:Source/queue.c **** #endif
 217:Source/queue.c **** 
 218:Source/queue.c **** /*-----------------------------------------------------------*/
 219:Source/queue.c **** 
 220:Source/queue.c **** /*
 221:Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 222:Source/queue.c ****  * accessing the queue event lists.
 223:Source/queue.c ****  */
 224:Source/queue.c **** #define prvLockQueue( pxQueue )								\
 225:Source/queue.c **** 	taskENTER_CRITICAL();									\
 226:Source/queue.c **** 	{														\
 227:Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 228:Source/queue.c **** 		{													\
 229:Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 230:Source/queue.c **** 		}													\
 231:Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 232:Source/queue.c **** 		{													\
 233:Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 234:Source/queue.c **** 		}													\
 235:Source/queue.c **** 	}														\
 236:Source/queue.c **** 	taskEXIT_CRITICAL()
 237:Source/queue.c **** /*-----------------------------------------------------------*/
 238:Source/queue.c **** 
 239:Source/queue.c **** portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
 240:Source/queue.c **** {
  29              		.loc 1 240 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 16
  32              		@ frame_needed = 1, uses_anonymous_args = 0
  33 0000 80B5     		push	{r7, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 84B0     		sub	sp, sp, #16
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 24
  41 0004 00AF     		add	r7, sp, #0
  42              	.LCFI2:
  43              		.cfi_def_cfa_register 7
  44 0006 7860     		str	r0, [r7, #4]
  45 0008 3960     		str	r1, [r7, #0]
 241:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
  46              		.loc 1 241 0
  47 000a 7B68     		ldr	r3, [r7, #4]
  48 000c FB60     		str	r3, [r7, #12]
 242:Source/queue.c **** 
 243:Source/queue.c **** 	configASSERT( pxQueue );
  49              		.loc 1 243 0
  50 000e FB68     		ldr	r3, [r7, #12]
  51 0010 002B     		cmp	r3, #0
  52 0012 02D1     		bne	.L2
  53              		.loc 1 243 0 is_stmt 0 discriminator 1
  54 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
  55              	.L3:
  56              		.loc 1 243 0 discriminator 2
  57 0018 FEE7     		b	.L3
  58              	.L2:
 244:Source/queue.c **** 
 245:Source/queue.c **** 	taskENTER_CRITICAL();
  59              		.loc 1 245 0 is_stmt 1
  60 001a FFF7FEFF 		bl	vPortEnterCritical
 246:Source/queue.c **** 	{
 247:Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  61              		.loc 1 247 0
  62 001e FB68     		ldr	r3, [r7, #12]
  63 0020 1A68     		ldr	r2, [r3, #0]
  64 0022 FB68     		ldr	r3, [r7, #12]
  65 0024 DB6B     		ldr	r3, [r3, #60]
  66 0026 F968     		ldr	r1, [r7, #12]
  67 0028 096C     		ldr	r1, [r1, #64]
  68 002a 01FB03F3 		mul	r3, r1, r3
  69 002e D218     		adds	r2, r2, r3
  70 0030 FB68     		ldr	r3, [r7, #12]
  71 0032 5A60     		str	r2, [r3, #4]
 248:Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  72              		.loc 1 248 0
  73 0034 FB68     		ldr	r3, [r7, #12]
  74 0036 4FF00002 		mov	r2, #0
  75 003a 9A63     		str	r2, [r3, #56]
 249:Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  76              		.loc 1 249 0
  77 003c FB68     		ldr	r3, [r7, #12]
  78 003e 1A68     		ldr	r2, [r3, #0]
  79 0040 FB68     		ldr	r3, [r7, #12]
  80 0042 9A60     		str	r2, [r3, #8]
 250:Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U )
  81              		.loc 1 250 0
  82 0044 FB68     		ldr	r3, [r7, #12]
  83 0046 1A68     		ldr	r2, [r3, #0]
  84 0048 FB68     		ldr	r3, [r7, #12]
  85 004a DB6B     		ldr	r3, [r3, #60]
  86 004c 03F1FF33 		add	r3, r3, #-1
  87 0050 F968     		ldr	r1, [r7, #12]
  88 0052 096C     		ldr	r1, [r1, #64]
  89 0054 01FB03F3 		mul	r3, r1, r3
  90 0058 D218     		adds	r2, r2, r3
  91 005a FB68     		ldr	r3, [r7, #12]
  92 005c DA60     		str	r2, [r3, #12]
 251:Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
  93              		.loc 1 251 0
  94 005e FB68     		ldr	r3, [r7, #12]
  95 0060 4FF0FF32 		mov	r2, #-1
  96 0064 5A64     		str	r2, [r3, #68]
 252:Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
  97              		.loc 1 252 0
  98 0066 FB68     		ldr	r3, [r7, #12]
  99 0068 4FF0FF32 		mov	r2, #-1
 100 006c 9A64     		str	r2, [r3, #72]
 253:Source/queue.c **** 
 254:Source/queue.c **** 		if( xNewQueue == pdFALSE )
 101              		.loc 1 254 0
 102 006e 3B68     		ldr	r3, [r7, #0]
 103 0070 002B     		cmp	r3, #0
 104 0072 0FD1     		bne	.L4
 255:Source/queue.c **** 		{
 256:Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 257:Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 258:Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to	write to
 259:Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 260:Source/queue.c **** 			it will be possible to write to it. */
 261:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 105              		.loc 1 261 0
 106 0074 FB68     		ldr	r3, [r7, #12]
 107 0076 1B69     		ldr	r3, [r3, #16]
 108 0078 002B     		cmp	r3, #0
 109 007a 17D0     		beq	.L5
 262:Source/queue.c **** 			{
 263:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 110              		.loc 1 263 0
 111 007c FB68     		ldr	r3, [r7, #12]
 112 007e 03F11003 		add	r3, r3, #16
 113 0082 1846     		mov	r0, r3
 114 0084 FFF7FEFF 		bl	xTaskRemoveFromEventList
 115 0088 0346     		mov	r3, r0
 116 008a 012B     		cmp	r3, #1
 117 008c 0ED1     		bne	.L5
 264:Source/queue.c **** 				{
 265:Source/queue.c **** 					portYIELD_WITHIN_API();
 118              		.loc 1 265 0
 119 008e FFF7FEFF 		bl	vPortYield
 120 0092 0BE0     		b	.L5
 121              	.L4:
 266:Source/queue.c **** 				}
 267:Source/queue.c **** 			}
 268:Source/queue.c **** 		}
 269:Source/queue.c **** 		else
 270:Source/queue.c **** 		{
 271:Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 272:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 122              		.loc 1 272 0
 123 0094 FB68     		ldr	r3, [r7, #12]
 124 0096 03F11003 		add	r3, r3, #16
 125 009a 1846     		mov	r0, r3
 126 009c FFF7FEFF 		bl	vListInitialise
 273:Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 127              		.loc 1 273 0
 128 00a0 FB68     		ldr	r3, [r7, #12]
 129 00a2 03F12403 		add	r3, r3, #36
 130 00a6 1846     		mov	r0, r3
 131 00a8 FFF7FEFF 		bl	vListInitialise
 132              	.L5:
 274:Source/queue.c **** 		}
 275:Source/queue.c **** 	}
 276:Source/queue.c **** 	taskEXIT_CRITICAL();
 133              		.loc 1 276 0
 134 00ac FFF7FEFF 		bl	vPortExitCritical
 277:Source/queue.c **** 
 278:Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 279:Source/queue.c **** 	versions. */
 280:Source/queue.c **** 	return pdPASS;
 135              		.loc 1 280 0
 136 00b0 4FF00103 		mov	r3, #1
 281:Source/queue.c **** }
 137              		.loc 1 281 0
 138 00b4 1846     		mov	r0, r3
 139 00b6 07F11007 		add	r7, r7, #16
 140 00ba BD46     		mov	sp, r7
 141 00bc 80BD     		pop	{r7, pc}
 142              		.cfi_endproc
 143              	.LFE110:
 145 00be 00BF     		.section	.text.xQueueGenericCreate,"ax",%progbits
 146              		.align	2
 147              		.global	xQueueGenericCreate
 148              		.thumb
 149              		.thumb_func
 151              	xQueueGenericCreate:
 152              	.LFB111:
 282:Source/queue.c **** /*-----------------------------------------------------------*/
 283:Source/queue.c **** 
 284:Source/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 285:Source/queue.c **** {
 153              		.loc 1 285 0
 154              		.cfi_startproc
 155              		@ args = 0, pretend = 0, frame = 32
 156              		@ frame_needed = 1, uses_anonymous_args = 0
 157 0000 80B5     		push	{r7, lr}
 158              	.LCFI3:
 159              		.cfi_def_cfa_offset 8
 160              		.cfi_offset 7, -8
 161              		.cfi_offset 14, -4
 162 0002 88B0     		sub	sp, sp, #32
 163              	.LCFI4:
 164              		.cfi_def_cfa_offset 40
 165 0004 00AF     		add	r7, sp, #0
 166              	.LCFI5:
 167              		.cfi_def_cfa_register 7
 168 0006 F860     		str	r0, [r7, #12]
 169 0008 B960     		str	r1, [r7, #8]
 170 000a 1346     		mov	r3, r2
 171 000c FB71     		strb	r3, [r7, #7]
 286:Source/queue.c **** xQUEUE *pxNewQueue;
 287:Source/queue.c **** size_t xQueueSizeInBytes;
 288:Source/queue.c **** xQueueHandle xReturn = NULL;
 172              		.loc 1 288 0
 173 000e 4FF00003 		mov	r3, #0
 174 0012 FB61     		str	r3, [r7, #28]
 289:Source/queue.c **** 
 290:Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 291:Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 292:Source/queue.c **** 	( void ) ucQueueType;
 293:Source/queue.c **** 
 294:Source/queue.c **** 	/* Allocate the new queue structure. */
 295:Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 175              		.loc 1 295 0
 176 0014 FB68     		ldr	r3, [r7, #12]
 177 0016 002B     		cmp	r3, #0
 178 0018 2DD0     		beq	.L8
 296:Source/queue.c **** 	{
 297:Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 179              		.loc 1 297 0
 180 001a 4FF05000 		mov	r0, #80
 181 001e FFF7FEFF 		bl	pvPortMalloc
 182 0022 B861     		str	r0, [r7, #24]
 298:Source/queue.c **** 		if( pxNewQueue != NULL )
 183              		.loc 1 298 0
 184 0024 BB69     		ldr	r3, [r7, #24]
 185 0026 002B     		cmp	r3, #0
 186 0028 25D0     		beq	.L8
 299:Source/queue.c **** 		{
 300:Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 301:Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 302:Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA
 187              		.loc 1 302 0
 188 002a FB68     		ldr	r3, [r7, #12]
 189 002c BA68     		ldr	r2, [r7, #8]
 190 002e 02FB03F3 		mul	r3, r2, r3
 191 0032 03F10103 		add	r3, r3, #1
 192 0036 7B61     		str	r3, [r7, #20]
 303:Source/queue.c **** 
 304:Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 193              		.loc 1 304 0
 194 0038 7869     		ldr	r0, [r7, #20]
 195 003a FFF7FEFF 		bl	pvPortMalloc
 196 003e 0246     		mov	r2, r0
 197 0040 BB69     		ldr	r3, [r7, #24]
 198 0042 1A60     		str	r2, [r3, #0]
 305:Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 199              		.loc 1 305 0
 200 0044 BB69     		ldr	r3, [r7, #24]
 201 0046 1B68     		ldr	r3, [r3, #0]
 202 0048 002B     		cmp	r3, #0
 203 004a 11D0     		beq	.L9
 306:Source/queue.c **** 			{
 307:Source/queue.c **** 				/* Initialise the queue members as described above where the
 308:Source/queue.c **** 				queue type is defined. */
 309:Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 204              		.loc 1 309 0
 205 004c BB69     		ldr	r3, [r7, #24]
 206 004e FA68     		ldr	r2, [r7, #12]
 207 0050 DA63     		str	r2, [r3, #60]
 310:Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 208              		.loc 1 310 0
 209 0052 BB69     		ldr	r3, [r7, #24]
 210 0054 BA68     		ldr	r2, [r7, #8]
 211 0056 1A64     		str	r2, [r3, #64]
 311:Source/queue.c **** 				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 212              		.loc 1 311 0
 213 0058 B869     		ldr	r0, [r7, #24]
 214 005a 4FF00101 		mov	r1, #1
 215 005e FFF7FEFF 		bl	xQueueGenericReset
 312:Source/queue.c **** 
 313:Source/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 314:Source/queue.c **** 				{
 315:Source/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 216              		.loc 1 315 0
 217 0062 BB69     		ldr	r3, [r7, #24]
 218 0064 FA79     		ldrb	r2, [r7, #7]
 219 0066 83F84D20 		strb	r2, [r3, #77]
 316:Source/queue.c **** 				}
 317:Source/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 318:Source/queue.c **** 
 319:Source/queue.c **** 				#if( configUSE_QUEUE_SETS == 1 )
 320:Source/queue.c **** 				{
 321:Source/queue.c **** 					pxNewQueue->pxQueueSetContainer = NULL;
 322:Source/queue.c **** 				}
 323:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 324:Source/queue.c **** 
 325:Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 326:Source/queue.c **** 				xReturn = pxNewQueue;
 220              		.loc 1 326 0
 221 006a BB69     		ldr	r3, [r7, #24]
 222 006c FB61     		str	r3, [r7, #28]
 223 006e 02E0     		b	.L8
 224              	.L9:
 327:Source/queue.c **** 			}
 328:Source/queue.c **** 			else
 329:Source/queue.c **** 			{
 330:Source/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 331:Source/queue.c **** 				vPortFree( pxNewQueue );
 225              		.loc 1 331 0
 226 0070 B869     		ldr	r0, [r7, #24]
 227 0072 FFF7FEFF 		bl	vPortFree
 228              	.L8:
 332:Source/queue.c **** 			}
 333:Source/queue.c **** 		}
 334:Source/queue.c **** 	}
 335:Source/queue.c **** 
 336:Source/queue.c **** 	configASSERT( xReturn );
 229              		.loc 1 336 0
 230 0076 FB69     		ldr	r3, [r7, #28]
 231 0078 002B     		cmp	r3, #0
 232 007a 02D1     		bne	.L10
 233              		.loc 1 336 0 is_stmt 0 discriminator 1
 234 007c FFF7FEFF 		bl	ulPortSetInterruptMask
 235              	.L11:
 236              		.loc 1 336 0 discriminator 2
 237 0080 FEE7     		b	.L11
 238              	.L10:
 337:Source/queue.c **** 
 338:Source/queue.c **** 	return xReturn;
 239              		.loc 1 338 0 is_stmt 1
 240 0082 FB69     		ldr	r3, [r7, #28]
 339:Source/queue.c **** }
 241              		.loc 1 339 0
 242 0084 1846     		mov	r0, r3
 243 0086 07F12007 		add	r7, r7, #32
 244 008a BD46     		mov	sp, r7
 245 008c 80BD     		pop	{r7, pc}
 246              		.cfi_endproc
 247              	.LFE111:
 249 008e 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 250              		.align	2
 251              		.global	xQueueCreateMutex
 252              		.thumb
 253              		.thumb_func
 255              	xQueueCreateMutex:
 256              	.LFB112:
 340:Source/queue.c **** /*-----------------------------------------------------------*/
 341:Source/queue.c **** 
 342:Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 343:Source/queue.c **** 
 344:Source/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 345:Source/queue.c **** 	{
 257              		.loc 1 345 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 16
 260              		@ frame_needed = 1, uses_anonymous_args = 0
 261 0000 80B5     		push	{r7, lr}
 262              	.LCFI6:
 263              		.cfi_def_cfa_offset 8
 264              		.cfi_offset 7, -8
 265              		.cfi_offset 14, -4
 266 0002 84B0     		sub	sp, sp, #16
 267              	.LCFI7:
 268              		.cfi_def_cfa_offset 24
 269 0004 00AF     		add	r7, sp, #0
 270              	.LCFI8:
 271              		.cfi_def_cfa_register 7
 272 0006 0346     		mov	r3, r0
 273 0008 FB71     		strb	r3, [r7, #7]
 346:Source/queue.c **** 	xQUEUE *pxNewQueue;
 347:Source/queue.c **** 
 348:Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 349:Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 350:Source/queue.c **** 		( void ) ucQueueType;
 351:Source/queue.c **** 
 352:Source/queue.c **** 		/* Allocate the new queue structure. */
 353:Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 274              		.loc 1 353 0
 275 000a 4FF05000 		mov	r0, #80
 276 000e FFF7FEFF 		bl	pvPortMalloc
 277 0012 F860     		str	r0, [r7, #12]
 354:Source/queue.c **** 		if( pxNewQueue != NULL )
 278              		.loc 1 354 0
 279 0014 FB68     		ldr	r3, [r7, #12]
 280 0016 002B     		cmp	r3, #0
 281 0018 3CD0     		beq	.L14
 355:Source/queue.c **** 		{
 356:Source/queue.c **** 			/* Information required for priority inheritance. */
 357:Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 282              		.loc 1 357 0
 283 001a FB68     		ldr	r3, [r7, #12]
 284 001c 4FF00002 		mov	r2, #0
 285 0020 5A60     		str	r2, [r3, #4]
 358:Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 286              		.loc 1 358 0
 287 0022 FB68     		ldr	r3, [r7, #12]
 288 0024 4FF00002 		mov	r2, #0
 289 0028 1A60     		str	r2, [r3, #0]
 359:Source/queue.c **** 
 360:Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 361:Source/queue.c **** 			of the queue. */
 362:Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 290              		.loc 1 362 0
 291 002a FB68     		ldr	r3, [r7, #12]
 292 002c 4FF00002 		mov	r2, #0
 293 0030 9A60     		str	r2, [r3, #8]
 363:Source/queue.c **** 			pxNewQueue->u.pcReadFrom = NULL;
 294              		.loc 1 363 0
 295 0032 FB68     		ldr	r3, [r7, #12]
 296 0034 4FF00002 		mov	r2, #0
 297 0038 DA60     		str	r2, [r3, #12]
 364:Source/queue.c **** 
 365:Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 366:Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 367:Source/queue.c **** 			of the mutex. */
 368:Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 298              		.loc 1 368 0
 299 003a FB68     		ldr	r3, [r7, #12]
 300 003c 4FF00002 		mov	r2, #0
 301 0040 9A63     		str	r2, [r3, #56]
 369:Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 302              		.loc 1 369 0
 303 0042 FB68     		ldr	r3, [r7, #12]
 304 0044 4FF00102 		mov	r2, #1
 305 0048 DA63     		str	r2, [r3, #60]
 370:Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 306              		.loc 1 370 0
 307 004a FB68     		ldr	r3, [r7, #12]
 308 004c 4FF00002 		mov	r2, #0
 309 0050 1A64     		str	r2, [r3, #64]
 371:Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 310              		.loc 1 371 0
 311 0052 FB68     		ldr	r3, [r7, #12]
 312 0054 4FF0FF32 		mov	r2, #-1
 313 0058 5A64     		str	r2, [r3, #68]
 372:Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 314              		.loc 1 372 0
 315 005a FB68     		ldr	r3, [r7, #12]
 316 005c 4FF0FF32 		mov	r2, #-1
 317 0060 9A64     		str	r2, [r3, #72]
 373:Source/queue.c **** 
 374:Source/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 375:Source/queue.c **** 			{
 376:Source/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 318              		.loc 1 376 0
 319 0062 FB68     		ldr	r3, [r7, #12]
 320 0064 FA79     		ldrb	r2, [r7, #7]
 321 0066 83F84D20 		strb	r2, [r3, #77]
 377:Source/queue.c **** 			}
 378:Source/queue.c **** 			#endif
 379:Source/queue.c **** 
 380:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
 381:Source/queue.c **** 			{
 382:Source/queue.c **** 				pxNewQueue->pxQueueSetContainer = NULL;
 383:Source/queue.c **** 			}
 384:Source/queue.c **** 			#endif
 385:Source/queue.c **** 
 386:Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 387:Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 322              		.loc 1 387 0
 323 006a FB68     		ldr	r3, [r7, #12]
 324 006c 03F11003 		add	r3, r3, #16
 325 0070 1846     		mov	r0, r3
 326 0072 FFF7FEFF 		bl	vListInitialise
 388:Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 327              		.loc 1 388 0
 328 0076 FB68     		ldr	r3, [r7, #12]
 329 0078 03F12403 		add	r3, r3, #36
 330 007c 1846     		mov	r0, r3
 331 007e FFF7FEFF 		bl	vListInitialise
 389:Source/queue.c **** 
 390:Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 391:Source/queue.c **** 
 392:Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 393:Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 332              		.loc 1 393 0
 333 0082 F868     		ldr	r0, [r7, #12]
 334 0084 4FF00001 		mov	r1, #0
 335 0088 4FF00002 		mov	r2, #0
 336 008c 4FF00003 		mov	r3, #0
 337 0090 FFF7FEFF 		bl	xQueueGenericSend
 338              	.L14:
 394:Source/queue.c **** 		}
 395:Source/queue.c **** 		else
 396:Source/queue.c **** 		{
 397:Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 398:Source/queue.c **** 		}
 399:Source/queue.c **** 
 400:Source/queue.c **** 		configASSERT( pxNewQueue );
 339              		.loc 1 400 0
 340 0094 FB68     		ldr	r3, [r7, #12]
 341 0096 002B     		cmp	r3, #0
 342 0098 02D1     		bne	.L15
 343              		.loc 1 400 0 is_stmt 0 discriminator 1
 344 009a FFF7FEFF 		bl	ulPortSetInterruptMask
 345              	.L16:
 346              		.loc 1 400 0 discriminator 2
 347 009e FEE7     		b	.L16
 348              	.L15:
 401:Source/queue.c **** 		return pxNewQueue;
 349              		.loc 1 401 0 is_stmt 1
 350 00a0 FB68     		ldr	r3, [r7, #12]
 402:Source/queue.c **** 	}
 351              		.loc 1 402 0
 352 00a2 1846     		mov	r0, r3
 353 00a4 07F11007 		add	r7, r7, #16
 354 00a8 BD46     		mov	sp, r7
 355 00aa 80BD     		pop	{r7, pc}
 356              		.cfi_endproc
 357              	.LFE112:
 359              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 360              		.align	2
 361              		.global	xQueueGiveMutexRecursive
 362              		.thumb
 363              		.thumb_func
 365              	xQueueGiveMutexRecursive:
 366              	.LFB113:
 403:Source/queue.c **** 
 404:Source/queue.c **** #endif /* configUSE_MUTEXES */
 405:Source/queue.c **** /*-----------------------------------------------------------*/
 406:Source/queue.c **** 
 407:Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 408:Source/queue.c **** 
 409:Source/queue.c **** 	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
 410:Source/queue.c **** 	{
 411:Source/queue.c **** 	void *pxReturn;
 412:Source/queue.c **** 
 413:Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 414:Source/queue.c **** 		be called directly.  Note:  This is is a good way of determining if the
 415:Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 416:Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 417:Source/queue.c **** 		following critical section exiting and the function returning. */
 418:Source/queue.c **** 		taskENTER_CRITICAL();
 419:Source/queue.c **** 		{
 420:Source/queue.c **** 			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 421:Source/queue.c **** 			{
 422:Source/queue.c **** 				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
 423:Source/queue.c **** 			}
 424:Source/queue.c **** 			else
 425:Source/queue.c **** 			{
 426:Source/queue.c **** 				pxReturn = NULL;
 427:Source/queue.c **** 			}
 428:Source/queue.c **** 		}
 429:Source/queue.c **** 		taskEXIT_CRITICAL();
 430:Source/queue.c **** 
 431:Source/queue.c **** 		return pxReturn;
 432:Source/queue.c **** 	}
 433:Source/queue.c **** 
 434:Source/queue.c **** #endif
 435:Source/queue.c **** /*-----------------------------------------------------------*/
 436:Source/queue.c **** 
 437:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 438:Source/queue.c **** 
 439:Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
 440:Source/queue.c **** 	{
 367              		.loc 1 440 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 16
 370              		@ frame_needed = 1, uses_anonymous_args = 0
 371 0000 90B5     		push	{r4, r7, lr}
 372              	.LCFI9:
 373              		.cfi_def_cfa_offset 12
 374              		.cfi_offset 4, -12
 375              		.cfi_offset 7, -8
 376              		.cfi_offset 14, -4
 377 0002 85B0     		sub	sp, sp, #20
 378              	.LCFI10:
 379              		.cfi_def_cfa_offset 32
 380 0004 00AF     		add	r7, sp, #0
 381              	.LCFI11:
 382              		.cfi_def_cfa_register 7
 383 0006 7860     		str	r0, [r7, #4]
 441:Source/queue.c **** 	portBASE_TYPE xReturn;
 442:Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 384              		.loc 1 442 0
 385 0008 7B68     		ldr	r3, [r7, #4]
 386 000a BB60     		str	r3, [r7, #8]
 443:Source/queue.c **** 
 444:Source/queue.c **** 		configASSERT( pxMutex );
 387              		.loc 1 444 0
 388 000c BB68     		ldr	r3, [r7, #8]
 389 000e 002B     		cmp	r3, #0
 390 0010 02D1     		bne	.L19
 391              		.loc 1 444 0 is_stmt 0 discriminator 1
 392 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 393              	.L20:
 394              		.loc 1 444 0 discriminator 2
 395 0016 FEE7     		b	.L20
 396              	.L19:
 445:Source/queue.c **** 
 446:Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 447:Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 448:Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 449:Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 450:Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 451:Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 452:Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 397              		.loc 1 452 0 is_stmt 1
 398 0018 BB68     		ldr	r3, [r7, #8]
 399 001a 5C68     		ldr	r4, [r3, #4]
 400 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 401 0020 0346     		mov	r3, r0
 402 0022 9C42     		cmp	r4, r3
 403 0024 16D1     		bne	.L21
 453:Source/queue.c **** 		{
 454:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 455:Source/queue.c **** 
 456:Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 457:Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 458:Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 459:Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 460:Source/queue.c **** 			uxRecursiveCallCount member. */
 461:Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 404              		.loc 1 461 0
 405 0026 BB68     		ldr	r3, [r7, #8]
 406 0028 DB68     		ldr	r3, [r3, #12]
 407 002a 03F1FF32 		add	r2, r3, #-1
 408 002e BB68     		ldr	r3, [r7, #8]
 409 0030 DA60     		str	r2, [r3, #12]
 462:Source/queue.c **** 
 463:Source/queue.c **** 			/* Have we unwound the call count? */
 464:Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( unsigned portBASE_TYPE ) 0 )
 410              		.loc 1 464 0
 411 0032 BB68     		ldr	r3, [r7, #8]
 412 0034 DB68     		ldr	r3, [r3, #12]
 413 0036 002B     		cmp	r3, #0
 414 0038 08D1     		bne	.L22
 465:Source/queue.c **** 			{
 466:Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 467:Source/queue.c **** 				task that might be waiting to access the mutex. */
 468:Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 415              		.loc 1 468 0
 416 003a B868     		ldr	r0, [r7, #8]
 417 003c 4FF00001 		mov	r1, #0
 418 0040 4FF00002 		mov	r2, #0
 419 0044 4FF00003 		mov	r3, #0
 420 0048 FFF7FEFF 		bl	xQueueGenericSend
 421              	.L22:
 469:Source/queue.c **** 			}
 470:Source/queue.c **** 
 471:Source/queue.c **** 			xReturn = pdPASS;
 422              		.loc 1 471 0
 423 004c 4FF00103 		mov	r3, #1
 424 0050 FB60     		str	r3, [r7, #12]
 425 0052 02E0     		b	.L23
 426              	.L21:
 472:Source/queue.c **** 		}
 473:Source/queue.c **** 		else
 474:Source/queue.c **** 		{
 475:Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 476:Source/queue.c **** 			xReturn = pdFAIL;
 427              		.loc 1 476 0
 428 0054 4FF00003 		mov	r3, #0
 429 0058 FB60     		str	r3, [r7, #12]
 430              	.L23:
 477:Source/queue.c **** 
 478:Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 479:Source/queue.c **** 		}
 480:Source/queue.c **** 
 481:Source/queue.c **** 		return xReturn;
 431              		.loc 1 481 0
 432 005a FB68     		ldr	r3, [r7, #12]
 482:Source/queue.c **** 	}
 433              		.loc 1 482 0
 434 005c 1846     		mov	r0, r3
 435 005e 07F11407 		add	r7, r7, #20
 436 0062 BD46     		mov	sp, r7
 437 0064 90BD     		pop	{r4, r7, pc}
 438              		.cfi_endproc
 439              	.LFE113:
 441 0066 00BF     		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 442              		.align	2
 443              		.global	xQueueTakeMutexRecursive
 444              		.thumb
 445              		.thumb_func
 447              	xQueueTakeMutexRecursive:
 448              	.LFB114:
 483:Source/queue.c **** 
 484:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 485:Source/queue.c **** /*-----------------------------------------------------------*/
 486:Source/queue.c **** 
 487:Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 488:Source/queue.c **** 
 489:Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
 490:Source/queue.c **** 	{
 449              		.loc 1 490 0
 450              		.cfi_startproc
 451              		@ args = 0, pretend = 0, frame = 16
 452              		@ frame_needed = 1, uses_anonymous_args = 0
 453 0000 90B5     		push	{r4, r7, lr}
 454              	.LCFI12:
 455              		.cfi_def_cfa_offset 12
 456              		.cfi_offset 4, -12
 457              		.cfi_offset 7, -8
 458              		.cfi_offset 14, -4
 459 0002 85B0     		sub	sp, sp, #20
 460              	.LCFI13:
 461              		.cfi_def_cfa_offset 32
 462 0004 00AF     		add	r7, sp, #0
 463              	.LCFI14:
 464              		.cfi_def_cfa_register 7
 465 0006 7860     		str	r0, [r7, #4]
 466 0008 3960     		str	r1, [r7, #0]
 491:Source/queue.c **** 	portBASE_TYPE xReturn;
 492:Source/queue.c **** 	xQUEUE * const pxMutex = ( xQUEUE * ) xMutex;
 467              		.loc 1 492 0
 468 000a 7B68     		ldr	r3, [r7, #4]
 469 000c BB60     		str	r3, [r7, #8]
 493:Source/queue.c **** 
 494:Source/queue.c **** 		configASSERT( pxMutex );
 470              		.loc 1 494 0
 471 000e BB68     		ldr	r3, [r7, #8]
 472 0010 002B     		cmp	r3, #0
 473 0012 02D1     		bne	.L26
 474              		.loc 1 494 0 is_stmt 0 discriminator 1
 475 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 476              	.L27:
 477              		.loc 1 494 0 discriminator 2
 478 0018 FEE7     		b	.L27
 479              	.L26:
 495:Source/queue.c **** 
 496:Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 497:Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 498:Source/queue.c **** 
 499:Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 500:Source/queue.c **** 
 501:Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 480              		.loc 1 501 0 is_stmt 1
 481 001a BB68     		ldr	r3, [r7, #8]
 482 001c 5C68     		ldr	r4, [r3, #4]
 483 001e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 484 0022 0346     		mov	r3, r0
 485 0024 9C42     		cmp	r4, r3
 486 0026 09D1     		bne	.L28
 502:Source/queue.c **** 		{
 503:Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 487              		.loc 1 503 0
 488 0028 BB68     		ldr	r3, [r7, #8]
 489 002a DB68     		ldr	r3, [r3, #12]
 490 002c 03F10102 		add	r2, r3, #1
 491 0030 BB68     		ldr	r3, [r7, #8]
 492 0032 DA60     		str	r2, [r3, #12]
 504:Source/queue.c **** 			xReturn = pdPASS;
 493              		.loc 1 504 0
 494 0034 4FF00103 		mov	r3, #1
 495 0038 FB60     		str	r3, [r7, #12]
 496 003a 11E0     		b	.L29
 497              	.L28:
 505:Source/queue.c **** 		}
 506:Source/queue.c **** 		else
 507:Source/queue.c **** 		{
 508:Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 498              		.loc 1 508 0
 499 003c B868     		ldr	r0, [r7, #8]
 500 003e 4FF00001 		mov	r1, #0
 501 0042 3A68     		ldr	r2, [r7, #0]
 502 0044 4FF00003 		mov	r3, #0
 503 0048 FFF7FEFF 		bl	xQueueGenericReceive
 504 004c F860     		str	r0, [r7, #12]
 509:Source/queue.c **** 
 510:Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 511:Source/queue.c **** 			we may have blocked to reach here. */
 512:Source/queue.c **** 			if( xReturn == pdPASS )
 505              		.loc 1 512 0
 506 004e FB68     		ldr	r3, [r7, #12]
 507 0050 012B     		cmp	r3, #1
 508 0052 05D1     		bne	.L29
 513:Source/queue.c **** 			{
 514:Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 509              		.loc 1 514 0
 510 0054 BB68     		ldr	r3, [r7, #8]
 511 0056 DB68     		ldr	r3, [r3, #12]
 512 0058 03F10102 		add	r2, r3, #1
 513 005c BB68     		ldr	r3, [r7, #8]
 514 005e DA60     		str	r2, [r3, #12]
 515              	.L29:
 515:Source/queue.c **** 			}
 516:Source/queue.c **** 			else
 517:Source/queue.c **** 			{
 518:Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 519:Source/queue.c **** 			}
 520:Source/queue.c **** 		}
 521:Source/queue.c **** 
 522:Source/queue.c **** 		return xReturn;
 516              		.loc 1 522 0
 517 0060 FB68     		ldr	r3, [r7, #12]
 523:Source/queue.c **** 	}
 518              		.loc 1 523 0
 519 0062 1846     		mov	r0, r3
 520 0064 07F11407 		add	r7, r7, #20
 521 0068 BD46     		mov	sp, r7
 522 006a 90BD     		pop	{r4, r7, pc}
 523              		.cfi_endproc
 524              	.LFE114:
 526              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 527              		.align	2
 528              		.global	xQueueCreateCountingSemaphore
 529              		.thumb
 530              		.thumb_func
 532              	xQueueCreateCountingSemaphore:
 533              	.LFB115:
 524:Source/queue.c **** 
 525:Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 526:Source/queue.c **** /*-----------------------------------------------------------*/
 527:Source/queue.c **** 
 528:Source/queue.c **** #if ( configUSE_COUNTING_SEMAPHORES == 1 )
 529:Source/queue.c **** 
 530:Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 531:Source/queue.c **** 	{
 534              		.loc 1 531 0
 535              		.cfi_startproc
 536              		@ args = 0, pretend = 0, frame = 16
 537              		@ frame_needed = 1, uses_anonymous_args = 0
 538 0000 80B5     		push	{r7, lr}
 539              	.LCFI15:
 540              		.cfi_def_cfa_offset 8
 541              		.cfi_offset 7, -8
 542              		.cfi_offset 14, -4
 543 0002 84B0     		sub	sp, sp, #16
 544              	.LCFI16:
 545              		.cfi_def_cfa_offset 24
 546 0004 00AF     		add	r7, sp, #0
 547              	.LCFI17:
 548              		.cfi_def_cfa_register 7
 549 0006 7860     		str	r0, [r7, #4]
 550 0008 3960     		str	r1, [r7, #0]
 532:Source/queue.c **** 	xQueueHandle xHandle;
 533:Source/queue.c **** 
 534:Source/queue.c **** 		xHandle = xQueueGenericCreate( uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_CO
 551              		.loc 1 534 0
 552 000a 7868     		ldr	r0, [r7, #4]
 553 000c 4FF00001 		mov	r1, #0
 554 0010 4FF00202 		mov	r2, #2
 555 0014 FFF7FEFF 		bl	xQueueGenericCreate
 556 0018 F860     		str	r0, [r7, #12]
 535:Source/queue.c **** 
 536:Source/queue.c **** 		if( xHandle != NULL )
 557              		.loc 1 536 0
 558 001a FB68     		ldr	r3, [r7, #12]
 559 001c 002B     		cmp	r3, #0
 560 001e 02D0     		beq	.L32
 537:Source/queue.c **** 		{
 538:Source/queue.c **** 			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 561              		.loc 1 538 0
 562 0020 FB68     		ldr	r3, [r7, #12]
 563 0022 3A68     		ldr	r2, [r7, #0]
 564 0024 9A63     		str	r2, [r3, #56]
 565              	.L32:
 539:Source/queue.c **** 
 540:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 541:Source/queue.c **** 		}
 542:Source/queue.c **** 		else
 543:Source/queue.c **** 		{
 544:Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 545:Source/queue.c **** 		}
 546:Source/queue.c **** 
 547:Source/queue.c **** 		configASSERT( xHandle );
 566              		.loc 1 547 0
 567 0026 FB68     		ldr	r3, [r7, #12]
 568 0028 002B     		cmp	r3, #0
 569 002a 02D1     		bne	.L33
 570              		.loc 1 547 0 is_stmt 0 discriminator 1
 571 002c FFF7FEFF 		bl	ulPortSetInterruptMask
 572              	.L34:
 573              		.loc 1 547 0 discriminator 2
 574 0030 FEE7     		b	.L34
 575              	.L33:
 548:Source/queue.c **** 		return xHandle;
 576              		.loc 1 548 0 is_stmt 1
 577 0032 FB68     		ldr	r3, [r7, #12]
 549:Source/queue.c **** 	}
 578              		.loc 1 549 0
 579 0034 1846     		mov	r0, r3
 580 0036 07F11007 		add	r7, r7, #16
 581 003a BD46     		mov	sp, r7
 582 003c 80BD     		pop	{r7, pc}
 583              		.cfi_endproc
 584              	.LFE115:
 586 003e 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 587              		.align	2
 588              		.global	xQueueGenericSend
 589              		.thumb
 590              		.thumb_func
 592              	xQueueGenericSend:
 593              	.LFB116:
 550:Source/queue.c **** 
 551:Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 552:Source/queue.c **** /*-----------------------------------------------------------*/
 553:Source/queue.c **** 
 554:Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 555:Source/queue.c **** {
 594              		.loc 1 555 0
 595              		.cfi_startproc
 596              		@ args = 0, pretend = 0, frame = 32
 597              		@ frame_needed = 1, uses_anonymous_args = 0
 598 0000 80B5     		push	{r7, lr}
 599              	.LCFI18:
 600              		.cfi_def_cfa_offset 8
 601              		.cfi_offset 7, -8
 602              		.cfi_offset 14, -4
 603 0002 88B0     		sub	sp, sp, #32
 604              	.LCFI19:
 605              		.cfi_def_cfa_offset 40
 606 0004 00AF     		add	r7, sp, #0
 607              	.LCFI20:
 608              		.cfi_def_cfa_register 7
 609 0006 F860     		str	r0, [r7, #12]
 610 0008 B960     		str	r1, [r7, #8]
 611 000a 7A60     		str	r2, [r7, #4]
 612 000c 3B60     		str	r3, [r7, #0]
 556:Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 613              		.loc 1 556 0
 614 000e 4FF00003 		mov	r3, #0
 615 0012 FB61     		str	r3, [r7, #28]
 557:Source/queue.c **** xTimeOutType xTimeOut;
 558:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 616              		.loc 1 558 0
 617 0014 FB68     		ldr	r3, [r7, #12]
 618 0016 BB61     		str	r3, [r7, #24]
 559:Source/queue.c **** 
 560:Source/queue.c **** 	configASSERT( pxQueue );
 619              		.loc 1 560 0
 620 0018 BB69     		ldr	r3, [r7, #24]
 621 001a 002B     		cmp	r3, #0
 622 001c 02D1     		bne	.L37
 623              		.loc 1 560 0 is_stmt 0 discriminator 1
 624 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 625              	.L38:
 626              		.loc 1 560 0 discriminator 2
 627 0022 FEE7     		b	.L38
 628              	.L37:
 561:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 629              		.loc 1 561 0 is_stmt 1
 630 0024 BB68     		ldr	r3, [r7, #8]
 631 0026 002B     		cmp	r3, #0
 632 0028 03D1     		bne	.L39
 633              		.loc 1 561 0 is_stmt 0 discriminator 2
 634 002a BB69     		ldr	r3, [r7, #24]
 635 002c 1B6C     		ldr	r3, [r3, #64]
 636 002e 002B     		cmp	r3, #0
 637 0030 02D1     		bne	.L40
 638              	.L39:
 639              		.loc 1 561 0 discriminator 1
 640 0032 4FF00103 		mov	r3, #1
 641 0036 01E0     		b	.L41
 642              	.L40:
 643              		.loc 1 561 0 discriminator 3
 644 0038 4FF00003 		mov	r3, #0
 645              	.L41:
 646              		.loc 1 561 0 discriminator 4
 647 003c 002B     		cmp	r3, #0
 648 003e 02D1     		bne	.L42
 649              		.loc 1 561 0 discriminator 5
 650 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 651              	.L43:
 652              		.loc 1 561 0 discriminator 6
 653 0044 FEE7     		b	.L43
 654              	.L42:
 562:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 655              		.loc 1 562 0 is_stmt 1
 656 0046 3B68     		ldr	r3, [r7, #0]
 657 0048 022B     		cmp	r3, #2
 658 004a 03D1     		bne	.L44
 659              		.loc 1 562 0 is_stmt 0 discriminator 2
 660 004c BB69     		ldr	r3, [r7, #24]
 661 004e DB6B     		ldr	r3, [r3, #60]
 662 0050 012B     		cmp	r3, #1
 663 0052 02D1     		bne	.L45
 664              	.L44:
 665              		.loc 1 562 0 discriminator 1
 666 0054 4FF00103 		mov	r3, #1
 667 0058 01E0     		b	.L46
 668              	.L45:
 669              		.loc 1 562 0 discriminator 3
 670 005a 4FF00003 		mov	r3, #0
 671              	.L46:
 672              		.loc 1 562 0 discriminator 4
 673 005e 002B     		cmp	r3, #0
 674 0060 03D1     		bne	.L47
 675              		.loc 1 562 0 discriminator 5
 676 0062 FFF7FEFF 		bl	ulPortSetInterruptMask
 677              	.L48:
 678              		.loc 1 562 0 discriminator 6
 679 0066 FEE7     		b	.L48
 680              	.L61:
 563:Source/queue.c **** 
 564:Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 565:Source/queue.c **** 	statements within the function itself.  This is done in the interest
 566:Source/queue.c **** 	of execution time efficiency. */
 567:Source/queue.c **** 	for( ;; )
 568:Source/queue.c **** 	{
 569:Source/queue.c **** 		taskENTER_CRITICAL();
 570:Source/queue.c **** 		{
 571:Source/queue.c **** 			/* Is there room on the queue now?  The running task must be
 572:Source/queue.c **** 			the highest priority task wanting to access the queue.  If
 573:Source/queue.c **** 			the head item in the queue is to be overwritten then it does
 574:Source/queue.c **** 			not matter if the queue is full. */
 575:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 576:Source/queue.c **** 			{
 577:Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 578:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 579:Source/queue.c **** 
 580:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 581:Source/queue.c **** 				{
 582:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 583:Source/queue.c **** 					{
 584:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 585:Source/queue.c **** 						{
 586:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 587:Source/queue.c **** 							to the queue set caused a higher priority task to
 588:Source/queue.c **** 							unblock. A context switch is required. */
 589:Source/queue.c **** 							portYIELD_WITHIN_API();
 590:Source/queue.c **** 						}
 591:Source/queue.c **** 					}
 592:Source/queue.c **** 					else
 593:Source/queue.c **** 					{
 594:Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 595:Source/queue.c **** 						queue then unblock it now. */
 596:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 597:Source/queue.c **** 						{
 598:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 599:Source/queue.c **** 							{
 600:Source/queue.c **** 								/* The unblocked task has a priority higher than
 601:Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 602:Source/queue.c **** 								do this from within the critical section - the
 603:Source/queue.c **** 								kernel takes care of that. */
 604:Source/queue.c **** 								portYIELD_WITHIN_API();
 605:Source/queue.c **** 							}
 606:Source/queue.c **** 						}
 607:Source/queue.c **** 					}
 608:Source/queue.c **** 				}
 609:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 610:Source/queue.c **** 				{
 611:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 612:Source/queue.c **** 					queue then unblock it now. */
 613:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 614:Source/queue.c **** 					{
 615:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 616:Source/queue.c **** 						{
 617:Source/queue.c **** 							/* The unblocked task has a priority higher than
 618:Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 619:Source/queue.c **** 							this from within the critical section - the kernel
 620:Source/queue.c **** 							takes care of that. */
 621:Source/queue.c **** 							portYIELD_WITHIN_API();
 622:Source/queue.c **** 						}
 623:Source/queue.c **** 					}
 624:Source/queue.c **** 				}
 625:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 626:Source/queue.c **** 
 627:Source/queue.c **** 				taskEXIT_CRITICAL();
 628:Source/queue.c **** 
 629:Source/queue.c **** 				/* Return to the original privilege level before exiting the
 630:Source/queue.c **** 				function. */
 631:Source/queue.c **** 				return pdPASS;
 632:Source/queue.c **** 			}
 633:Source/queue.c **** 			else
 634:Source/queue.c **** 			{
 635:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 636:Source/queue.c **** 				{
 637:Source/queue.c **** 					/* The queue was full and no block time is specified (or
 638:Source/queue.c **** 					the block time has expired) so leave now. */
 639:Source/queue.c **** 					taskEXIT_CRITICAL();
 640:Source/queue.c **** 
 641:Source/queue.c **** 					/* Return to the original privilege level before exiting
 642:Source/queue.c **** 					the function. */
 643:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 644:Source/queue.c **** 					return errQUEUE_FULL;
 645:Source/queue.c **** 				}
 646:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 647:Source/queue.c **** 				{
 648:Source/queue.c **** 					/* The queue was full and a block time was specified so
 649:Source/queue.c **** 					configure the timeout structure. */
 650:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 651:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 652:Source/queue.c **** 				}
 653:Source/queue.c **** 				else
 654:Source/queue.c **** 				{
 655:Source/queue.c **** 					/* Entry time was already set. */
 656:Source/queue.c **** 				}
 657:Source/queue.c **** 			}
 658:Source/queue.c **** 		}
 659:Source/queue.c **** 		taskEXIT_CRITICAL();
 660:Source/queue.c **** 
 661:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 662:Source/queue.c **** 		now the critical section has been exited. */
 663:Source/queue.c **** 
 664:Source/queue.c **** 		vTaskSuspendAll();
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 666:Source/queue.c **** 
 667:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 668:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 669:Source/queue.c **** 		{
 670:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 671:Source/queue.c **** 			{
 672:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 673:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 674:Source/queue.c **** 
 675:Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 676:Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 677:Source/queue.c **** 				remove this task from the event	list again - but as the
 678:Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 679:Source/queue.c **** 				ready last instead of the actual ready list. */
 680:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 681:Source/queue.c **** 
 682:Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 683:Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 684:Source/queue.c **** 				task is already in a ready list before it yields - in which
 685:Source/queue.c **** 				case the yield will not cause a context switch unless there
 686:Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 687:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 688:Source/queue.c **** 				{
 689:Source/queue.c **** 					portYIELD_WITHIN_API();
 690:Source/queue.c **** 				}
 691:Source/queue.c **** 			}
 692:Source/queue.c **** 			else
 693:Source/queue.c **** 			{
 694:Source/queue.c **** 				/* Try again. */
 695:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 696:Source/queue.c **** 				( void ) xTaskResumeAll();
 697:Source/queue.c **** 			}
 698:Source/queue.c **** 		}
 699:Source/queue.c **** 		else
 700:Source/queue.c **** 		{
 701:Source/queue.c **** 			/* The timeout has expired. */
 702:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 703:Source/queue.c **** 			( void ) xTaskResumeAll();
 704:Source/queue.c **** 
 705:Source/queue.c **** 			/* Return to the original privilege level before exiting the
 706:Source/queue.c **** 			function. */
 707:Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 708:Source/queue.c **** 			return errQUEUE_FULL;
 709:Source/queue.c **** 		}
 710:Source/queue.c **** 	}
 681              		.loc 1 710 0 is_stmt 1
 682 0068 00BF     		nop
 683              	.L47:
 569:Source/queue.c **** 		taskENTER_CRITICAL();
 684              		.loc 1 569 0
 685 006a FFF7FEFF 		bl	vPortEnterCritical
 575:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 686              		.loc 1 575 0
 687 006e BB69     		ldr	r3, [r7, #24]
 688 0070 9A6B     		ldr	r2, [r3, #56]
 689 0072 BB69     		ldr	r3, [r7, #24]
 690 0074 DB6B     		ldr	r3, [r3, #60]
 691 0076 9A42     		cmp	r2, r3
 692 0078 02D3     		bcc	.L49
 575:Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 693              		.loc 1 575 0 is_stmt 0 discriminator 1
 694 007a 3B68     		ldr	r3, [r7, #0]
 695 007c 022B     		cmp	r3, #2
 696 007e 18D1     		bne	.L50
 697              	.L49:
 578:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 698              		.loc 1 578 0 is_stmt 1
 699 0080 B869     		ldr	r0, [r7, #24]
 700 0082 B968     		ldr	r1, [r7, #8]
 701 0084 3A68     		ldr	r2, [r7, #0]
 702 0086 FFF7FEFF 		bl	prvCopyDataToQueue
 613:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 703              		.loc 1 613 0
 704 008a BB69     		ldr	r3, [r7, #24]
 705 008c 5B6A     		ldr	r3, [r3, #36]
 706 008e 002B     		cmp	r3, #0
 707 0090 0AD0     		beq	.L51
 615:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 708              		.loc 1 615 0
 709 0092 BB69     		ldr	r3, [r7, #24]
 710 0094 03F12403 		add	r3, r3, #36
 711 0098 1846     		mov	r0, r3
 712 009a FFF7FEFF 		bl	xTaskRemoveFromEventList
 713 009e 0346     		mov	r3, r0
 714 00a0 012B     		cmp	r3, #1
 715 00a2 01D1     		bne	.L51
 621:Source/queue.c **** 							portYIELD_WITHIN_API();
 716              		.loc 1 621 0
 717 00a4 FFF7FEFF 		bl	vPortYield
 718              	.L51:
 627:Source/queue.c **** 				taskEXIT_CRITICAL();
 719              		.loc 1 627 0
 720 00a8 FFF7FEFF 		bl	vPortExitCritical
 631:Source/queue.c **** 				return pdPASS;
 721              		.loc 1 631 0
 722 00ac 4FF00103 		mov	r3, #1
 723 00b0 5DE0     		b	.L60
 724              	.L50:
 635:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 725              		.loc 1 635 0
 726 00b2 7B68     		ldr	r3, [r7, #4]
 727 00b4 002B     		cmp	r3, #0
 728 00b6 04D1     		bne	.L53
 639:Source/queue.c **** 					taskEXIT_CRITICAL();
 729              		.loc 1 639 0
 730 00b8 FFF7FEFF 		bl	vPortExitCritical
 644:Source/queue.c **** 					return errQUEUE_FULL;
 731              		.loc 1 644 0
 732 00bc 4FF00003 		mov	r3, #0
 733 00c0 55E0     		b	.L60
 734              	.L53:
 646:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 735              		.loc 1 646 0
 736 00c2 FB69     		ldr	r3, [r7, #28]
 737 00c4 002B     		cmp	r3, #0
 738 00c6 07D1     		bne	.L54
 650:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 739              		.loc 1 650 0
 740 00c8 07F11003 		add	r3, r7, #16
 741 00cc 1846     		mov	r0, r3
 742 00ce FFF7FEFF 		bl	vTaskSetTimeOutState
 651:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 743              		.loc 1 651 0
 744 00d2 4FF00103 		mov	r3, #1
 745 00d6 FB61     		str	r3, [r7, #28]
 746              	.L54:
 659:Source/queue.c **** 		taskEXIT_CRITICAL();
 747              		.loc 1 659 0
 748 00d8 FFF7FEFF 		bl	vPortExitCritical
 664:Source/queue.c **** 		vTaskSuspendAll();
 749              		.loc 1 664 0
 750 00dc FFF7FEFF 		bl	vTaskSuspendAll
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 751              		.loc 1 665 0
 752 00e0 FFF7FEFF 		bl	vPortEnterCritical
 753 00e4 BB69     		ldr	r3, [r7, #24]
 754 00e6 5B6C     		ldr	r3, [r3, #68]
 755 00e8 B3F1FF3F 		cmp	r3, #-1
 756 00ec 03D1     		bne	.L55
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 757              		.loc 1 665 0 is_stmt 0 discriminator 1
 758 00ee BB69     		ldr	r3, [r7, #24]
 759 00f0 4FF00002 		mov	r2, #0
 760 00f4 5A64     		str	r2, [r3, #68]
 761              	.L55:
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 762              		.loc 1 665 0 discriminator 2
 763 00f6 BB69     		ldr	r3, [r7, #24]
 764 00f8 9B6C     		ldr	r3, [r3, #72]
 765 00fa B3F1FF3F 		cmp	r3, #-1
 766 00fe 03D1     		bne	.L56
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 767              		.loc 1 665 0 discriminator 3
 768 0100 BB69     		ldr	r3, [r7, #24]
 769 0102 4FF00002 		mov	r2, #0
 770 0106 9A64     		str	r2, [r3, #72]
 771              	.L56:
 665:Source/queue.c **** 		prvLockQueue( pxQueue );
 772              		.loc 1 665 0 discriminator 4
 773 0108 FFF7FEFF 		bl	vPortExitCritical
 668:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 774              		.loc 1 668 0 is_stmt 1 discriminator 4
 775 010c 07F11002 		add	r2, r7, #16
 776 0110 07F10403 		add	r3, r7, #4
 777 0114 1046     		mov	r0, r2
 778 0116 1946     		mov	r1, r3
 779 0118 FFF7FEFF 		bl	xTaskCheckForTimeOut
 780 011c 0346     		mov	r3, r0
 781 011e 002B     		cmp	r3, #0
 782 0120 1ED1     		bne	.L57
 670:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 783              		.loc 1 670 0
 784 0122 B869     		ldr	r0, [r7, #24]
 785 0124 FFF7FEFF 		bl	prvIsQueueFull
 786 0128 0346     		mov	r3, r0
 787 012a 002B     		cmp	r3, #0
 788 012c 12D0     		beq	.L58
 673:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 789              		.loc 1 673 0
 790 012e BB69     		ldr	r3, [r7, #24]
 791 0130 03F11002 		add	r2, r3, #16
 792 0134 7B68     		ldr	r3, [r7, #4]
 793 0136 1046     		mov	r0, r2
 794 0138 1946     		mov	r1, r3
 795 013a FFF7FEFF 		bl	vTaskPlaceOnEventList
 680:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 796              		.loc 1 680 0
 797 013e B869     		ldr	r0, [r7, #24]
 798 0140 FFF7FEFF 		bl	prvUnlockQueue
 687:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 799              		.loc 1 687 0
 800 0144 FFF7FEFF 		bl	xTaskResumeAll
 801 0148 0346     		mov	r3, r0
 802 014a 002B     		cmp	r3, #0
 803 014c 8CD1     		bne	.L61
 689:Source/queue.c **** 					portYIELD_WITHIN_API();
 804              		.loc 1 689 0
 805 014e FFF7FEFF 		bl	vPortYield
 806              		.loc 1 710 0
 807 0152 89E7     		b	.L61
 808              	.L58:
 695:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 809              		.loc 1 695 0
 810 0154 B869     		ldr	r0, [r7, #24]
 811 0156 FFF7FEFF 		bl	prvUnlockQueue
 696:Source/queue.c **** 				( void ) xTaskResumeAll();
 812              		.loc 1 696 0
 813 015a FFF7FEFF 		bl	xTaskResumeAll
 814              		.loc 1 710 0
 815 015e 83E7     		b	.L61
 816              	.L57:
 702:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 817              		.loc 1 702 0
 818 0160 B869     		ldr	r0, [r7, #24]
 819 0162 FFF7FEFF 		bl	prvUnlockQueue
 703:Source/queue.c **** 			( void ) xTaskResumeAll();
 820              		.loc 1 703 0
 821 0166 FFF7FEFF 		bl	xTaskResumeAll
 708:Source/queue.c **** 			return errQUEUE_FULL;
 822              		.loc 1 708 0
 823 016a 4FF00003 		mov	r3, #0
 824              	.L60:
 711:Source/queue.c **** }
 825              		.loc 1 711 0
 826 016e 1846     		mov	r0, r3
 827 0170 07F12007 		add	r7, r7, #32
 828 0174 BD46     		mov	sp, r7
 829 0176 80BD     		pop	{r7, pc}
 830              		.cfi_endproc
 831              	.LFE116:
 833              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 834              		.align	2
 835              		.global	xQueueGenericSendFromISR
 836              		.thumb
 837              		.thumb_func
 839              	xQueueGenericSendFromISR:
 840              	.LFB117:
 712:Source/queue.c **** /*-----------------------------------------------------------*/
 713:Source/queue.c **** 
 714:Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 715:Source/queue.c **** 
 716:Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, 
 717:Source/queue.c **** 	{
 718:Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 719:Source/queue.c **** 	xTimeOutType xTimeOut;
 720:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 721:Source/queue.c **** 
 722:Source/queue.c **** 		configASSERT( pxQueue );
 723:Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 724:Source/queue.c **** 
 725:Source/queue.c **** 		for( ;; )
 726:Source/queue.c **** 		{
 727:Source/queue.c **** 			taskENTER_CRITICAL();
 728:Source/queue.c **** 			{
 729:Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 730:Source/queue.c **** 				the highest priority task wanting to access the queue. */
 731:Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 732:Source/queue.c **** 				{
 733:Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 734:Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 735:Source/queue.c **** 
 736:Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 737:Source/queue.c **** 					queue then unblock it now. */
 738:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 739:Source/queue.c **** 					{
 740:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 741:Source/queue.c **** 						{
 742:Source/queue.c **** 							/* The unblocked task has a priority higher than
 743:Source/queue.c **** 							our own so yield immediately. */
 744:Source/queue.c **** 							portYIELD_WITHIN_API();
 745:Source/queue.c **** 						}
 746:Source/queue.c **** 					}
 747:Source/queue.c **** 
 748:Source/queue.c **** 					taskEXIT_CRITICAL();
 749:Source/queue.c **** 					return pdPASS;
 750:Source/queue.c **** 				}
 751:Source/queue.c **** 				else
 752:Source/queue.c **** 				{
 753:Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 754:Source/queue.c **** 					{
 755:Source/queue.c **** 						taskEXIT_CRITICAL();
 756:Source/queue.c **** 						return errQUEUE_FULL;
 757:Source/queue.c **** 					}
 758:Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 759:Source/queue.c **** 					{
 760:Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 761:Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 762:Source/queue.c **** 					}
 763:Source/queue.c **** 				}
 764:Source/queue.c **** 			}
 765:Source/queue.c **** 			taskEXIT_CRITICAL();
 766:Source/queue.c **** 
 767:Source/queue.c **** 			taskENTER_CRITICAL();
 768:Source/queue.c **** 			{
 769:Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 770:Source/queue.c **** 				{
 771:Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 772:Source/queue.c **** 					{
 773:Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 774:Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 775:Source/queue.c **** 						portYIELD_WITHIN_API();
 776:Source/queue.c **** 					}
 777:Source/queue.c **** 				}
 778:Source/queue.c **** 				else
 779:Source/queue.c **** 				{
 780:Source/queue.c **** 					taskEXIT_CRITICAL();
 781:Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 782:Source/queue.c **** 					return errQUEUE_FULL;
 783:Source/queue.c **** 				}
 784:Source/queue.c **** 			}
 785:Source/queue.c **** 			taskEXIT_CRITICAL();
 786:Source/queue.c **** 		}
 787:Source/queue.c **** 	}
 788:Source/queue.c **** 
 789:Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 790:Source/queue.c **** /*-----------------------------------------------------------*/
 791:Source/queue.c **** 
 792:Source/queue.c **** #if ( configUSE_ALTERNATIVE_API == 1 )
 793:Source/queue.c **** 
 794:Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTick
 795:Source/queue.c **** 	{
 796:Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 797:Source/queue.c **** 	xTimeOutType xTimeOut;
 798:Source/queue.c **** 	signed char *pcOriginalReadPosition;
 799:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 800:Source/queue.c **** 
 801:Source/queue.c **** 		configASSERT( pxQueue );
 802:Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 803:Source/queue.c **** 
 804:Source/queue.c **** 		for( ;; )
 805:Source/queue.c **** 		{
 806:Source/queue.c **** 			taskENTER_CRITICAL();
 807:Source/queue.c **** 			{
 808:Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 809:Source/queue.c **** 				{
 810:Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 811:Source/queue.c **** 					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 812:Source/queue.c **** 
 813:Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 814:Source/queue.c **** 
 815:Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 816:Source/queue.c **** 					{
 817:Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 818:Source/queue.c **** 
 819:Source/queue.c **** 						/* Data is actually being removed (not just peeked). */
 820:Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 821:Source/queue.c **** 
 822:Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 823:Source/queue.c **** 						{
 824:Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 825:Source/queue.c **** 							{
 826:Source/queue.c **** 								/* Record the information required to implement
 827:Source/queue.c **** 								priority inheritance should it become necessary. */
 828:Source/queue.c **** 								pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle();
 829:Source/queue.c **** 							}
 830:Source/queue.c **** 						}
 831:Source/queue.c **** 						#endif
 832:Source/queue.c **** 
 833:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 834:Source/queue.c **** 						{
 835:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 836:Source/queue.c **** 							{
 837:Source/queue.c **** 								portYIELD_WITHIN_API();
 838:Source/queue.c **** 							}
 839:Source/queue.c **** 						}
 840:Source/queue.c **** 					}
 841:Source/queue.c **** 					else
 842:Source/queue.c **** 					{
 843:Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 844:Source/queue.c **** 
 845:Source/queue.c **** 						/* We are not removing the data, so reset our read
 846:Source/queue.c **** 						pointer. */
 847:Source/queue.c **** 						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 848:Source/queue.c **** 
 849:Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 850:Source/queue.c **** 						any other tasks waiting for the data. */
 851:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 852:Source/queue.c **** 						{
 853:Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 854:Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 855:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 856:Source/queue.c **** 							{
 857:Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 858:Source/queue.c **** 								portYIELD_WITHIN_API();
 859:Source/queue.c **** 							}
 860:Source/queue.c **** 						}
 861:Source/queue.c **** 
 862:Source/queue.c **** 					}
 863:Source/queue.c **** 
 864:Source/queue.c **** 					taskEXIT_CRITICAL();
 865:Source/queue.c **** 					return pdPASS;
 866:Source/queue.c **** 				}
 867:Source/queue.c **** 				else
 868:Source/queue.c **** 				{
 869:Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 870:Source/queue.c **** 					{
 871:Source/queue.c **** 						taskEXIT_CRITICAL();
 872:Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 873:Source/queue.c **** 						return errQUEUE_EMPTY;
 874:Source/queue.c **** 					}
 875:Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 876:Source/queue.c **** 					{
 877:Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 878:Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 879:Source/queue.c **** 					}
 880:Source/queue.c **** 				}
 881:Source/queue.c **** 			}
 882:Source/queue.c **** 			taskEXIT_CRITICAL();
 883:Source/queue.c **** 
 884:Source/queue.c **** 			taskENTER_CRITICAL();
 885:Source/queue.c **** 			{
 886:Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 887:Source/queue.c **** 				{
 888:Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 889:Source/queue.c **** 					{
 890:Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 891:Source/queue.c **** 
 892:Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 893:Source/queue.c **** 						{
 894:Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 895:Source/queue.c **** 							{
 896:Source/queue.c **** 								portENTER_CRITICAL();
 897:Source/queue.c **** 								{
 898:Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 899:Source/queue.c **** 								}
 900:Source/queue.c **** 								portEXIT_CRITICAL();
 901:Source/queue.c **** 							}
 902:Source/queue.c **** 						}
 903:Source/queue.c **** 						#endif
 904:Source/queue.c **** 
 905:Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 906:Source/queue.c **** 						portYIELD_WITHIN_API();
 907:Source/queue.c **** 					}
 908:Source/queue.c **** 				}
 909:Source/queue.c **** 				else
 910:Source/queue.c **** 				{
 911:Source/queue.c **** 					taskEXIT_CRITICAL();
 912:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 913:Source/queue.c **** 					return errQUEUE_EMPTY;
 914:Source/queue.c **** 				}
 915:Source/queue.c **** 			}
 916:Source/queue.c **** 			taskEXIT_CRITICAL();
 917:Source/queue.c **** 		}
 918:Source/queue.c **** 	}
 919:Source/queue.c **** 
 920:Source/queue.c **** 
 921:Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 922:Source/queue.c **** /*-----------------------------------------------------------*/
 923:Source/queue.c **** 
 924:Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueu
 925:Source/queue.c **** {
 841              		.loc 1 925 0
 842              		.cfi_startproc
 843              		@ args = 0, pretend = 0, frame = 32
 844              		@ frame_needed = 1, uses_anonymous_args = 0
 845 0000 80B5     		push	{r7, lr}
 846              	.LCFI21:
 847              		.cfi_def_cfa_offset 8
 848              		.cfi_offset 7, -8
 849              		.cfi_offset 14, -4
 850 0002 88B0     		sub	sp, sp, #32
 851              	.LCFI22:
 852              		.cfi_def_cfa_offset 40
 853 0004 00AF     		add	r7, sp, #0
 854              	.LCFI23:
 855              		.cfi_def_cfa_register 7
 856 0006 F860     		str	r0, [r7, #12]
 857 0008 B960     		str	r1, [r7, #8]
 858 000a 7A60     		str	r2, [r7, #4]
 859 000c 3B60     		str	r3, [r7, #0]
 926:Source/queue.c **** signed portBASE_TYPE xReturn;
 927:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 928:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 860              		.loc 1 928 0
 861 000e FB68     		ldr	r3, [r7, #12]
 862 0010 BB61     		str	r3, [r7, #24]
 929:Source/queue.c **** 
 930:Source/queue.c **** 	configASSERT( pxQueue );
 863              		.loc 1 930 0
 864 0012 BB69     		ldr	r3, [r7, #24]
 865 0014 002B     		cmp	r3, #0
 866 0016 02D1     		bne	.L63
 867              		.loc 1 930 0 is_stmt 0 discriminator 1
 868 0018 FFF7FEFF 		bl	ulPortSetInterruptMask
 869              	.L64:
 870              		.loc 1 930 0 discriminator 2
 871 001c FEE7     		b	.L64
 872              	.L63:
 931:Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 873              		.loc 1 931 0 is_stmt 1
 874 001e BB68     		ldr	r3, [r7, #8]
 875 0020 002B     		cmp	r3, #0
 876 0022 03D1     		bne	.L65
 877              		.loc 1 931 0 is_stmt 0 discriminator 2
 878 0024 BB69     		ldr	r3, [r7, #24]
 879 0026 1B6C     		ldr	r3, [r3, #64]
 880 0028 002B     		cmp	r3, #0
 881 002a 02D1     		bne	.L66
 882              	.L65:
 883              		.loc 1 931 0 discriminator 1
 884 002c 4FF00103 		mov	r3, #1
 885 0030 01E0     		b	.L67
 886              	.L66:
 887              		.loc 1 931 0 discriminator 3
 888 0032 4FF00003 		mov	r3, #0
 889              	.L67:
 890              		.loc 1 931 0 discriminator 4
 891 0036 002B     		cmp	r3, #0
 892 0038 02D1     		bne	.L68
 893              		.loc 1 931 0 discriminator 5
 894 003a FFF7FEFF 		bl	ulPortSetInterruptMask
 895              	.L69:
 896              		.loc 1 931 0 discriminator 6
 897 003e FEE7     		b	.L69
 898              	.L68:
 932:Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 899              		.loc 1 932 0 is_stmt 1
 900 0040 3B68     		ldr	r3, [r7, #0]
 901 0042 022B     		cmp	r3, #2
 902 0044 03D1     		bne	.L70
 903              		.loc 1 932 0 is_stmt 0 discriminator 2
 904 0046 BB69     		ldr	r3, [r7, #24]
 905 0048 DB6B     		ldr	r3, [r3, #60]
 906 004a 012B     		cmp	r3, #1
 907 004c 02D1     		bne	.L71
 908              	.L70:
 909              		.loc 1 932 0 discriminator 1
 910 004e 4FF00103 		mov	r3, #1
 911 0052 01E0     		b	.L72
 912              	.L71:
 913              		.loc 1 932 0 discriminator 3
 914 0054 4FF00003 		mov	r3, #0
 915              	.L72:
 916              		.loc 1 932 0 discriminator 4
 917 0058 002B     		cmp	r3, #0
 918 005a 02D1     		bne	.L73
 919              		.loc 1 932 0 discriminator 5
 920 005c FFF7FEFF 		bl	ulPortSetInterruptMask
 921              	.L74:
 922              		.loc 1 932 0 discriminator 6
 923 0060 FEE7     		b	.L74
 924              	.L73:
 933:Source/queue.c **** 
 934:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 935:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 936:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
 937:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 938:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 939:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 940:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 941:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 942:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 943:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 944:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 945:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 946:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 947:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 948:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 925              		.loc 1 948 0 is_stmt 1
 926 0062 FFF7FEFF 		bl	vPortValidateInterruptPriority
 949:Source/queue.c **** 
 950:Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 951:Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 952:Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 953:Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 954:Source/queue.c **** 	by this	post). */
 955:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 927              		.loc 1 955 0
 928 0066 FFF7FEFF 		bl	ulPortSetInterruptMask
 929 006a 7861     		str	r0, [r7, #20]
 956:Source/queue.c **** 	{
 957:Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 930              		.loc 1 957 0
 931 006c BB69     		ldr	r3, [r7, #24]
 932 006e 9A6B     		ldr	r2, [r3, #56]
 933 0070 BB69     		ldr	r3, [r7, #24]
 934 0072 DB6B     		ldr	r3, [r3, #60]
 935 0074 9A42     		cmp	r2, r3
 936 0076 02D3     		bcc	.L75
 937              		.loc 1 957 0 is_stmt 0 discriminator 1
 938 0078 3B68     		ldr	r3, [r7, #0]
 939 007a 022B     		cmp	r3, #2
 940 007c 28D1     		bne	.L76
 941              	.L75:
 958:Source/queue.c **** 		{
 959:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 960:Source/queue.c **** 
 961:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 942              		.loc 1 961 0 is_stmt 1
 943 007e B869     		ldr	r0, [r7, #24]
 944 0080 B968     		ldr	r1, [r7, #8]
 945 0082 3A68     		ldr	r2, [r7, #0]
 946 0084 FFF7FEFF 		bl	prvCopyDataToQueue
 962:Source/queue.c **** 
 963:Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 964:Source/queue.c **** 			be done when the queue is unlocked later. */
 965:Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 947              		.loc 1 965 0
 948 0088 BB69     		ldr	r3, [r7, #24]
 949 008a 9B6C     		ldr	r3, [r3, #72]
 950 008c B3F1FF3F 		cmp	r3, #-1
 951 0090 14D1     		bne	.L77
 966:Source/queue.c **** 			{
 967:Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 968:Source/queue.c **** 				{
 969:Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 970:Source/queue.c **** 					{
 971:Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
 972:Source/queue.c **** 						{
 973:Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 974:Source/queue.c **** 							to the queue set caused a higher priority task to
 975:Source/queue.c **** 							unblock.  A context switch is required. */
 976:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 977:Source/queue.c **** 							{
 978:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 979:Source/queue.c **** 							}
 980:Source/queue.c **** 						}
 981:Source/queue.c **** 					}
 982:Source/queue.c **** 					else
 983:Source/queue.c **** 					{
 984:Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 985:Source/queue.c **** 						{
 986:Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 987:Source/queue.c **** 							{
 988:Source/queue.c **** 								/* The task waiting has a higher priority so record that a
 989:Source/queue.c **** 								context	switch is required. */
 990:Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
 991:Source/queue.c **** 								{
 992:Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
 993:Source/queue.c **** 								}
 994:Source/queue.c **** 							}
 995:Source/queue.c **** 						}
 996:Source/queue.c **** 					}
 997:Source/queue.c **** 				}
 998:Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 999:Source/queue.c **** 				{
1000:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 952              		.loc 1 1000 0
 953 0092 BB69     		ldr	r3, [r7, #24]
 954 0094 5B6A     		ldr	r3, [r3, #36]
 955 0096 002B     		cmp	r3, #0
 956 0098 16D0     		beq	.L78
1001:Source/queue.c **** 					{
1002:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 957              		.loc 1 1002 0
 958 009a BB69     		ldr	r3, [r7, #24]
 959 009c 03F12403 		add	r3, r3, #36
 960 00a0 1846     		mov	r0, r3
 961 00a2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 962 00a6 0346     		mov	r3, r0
 963 00a8 002B     		cmp	r3, #0
 964 00aa 0DD0     		beq	.L78
1003:Source/queue.c **** 						{
1004:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1005:Source/queue.c **** 							context	switch is required. */
1006:Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 965              		.loc 1 1006 0
 966 00ac 7B68     		ldr	r3, [r7, #4]
 967 00ae 002B     		cmp	r3, #0
 968 00b0 0AD0     		beq	.L78
1007:Source/queue.c **** 							{
1008:Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 969              		.loc 1 1008 0
 970 00b2 7B68     		ldr	r3, [r7, #4]
 971 00b4 4FF00102 		mov	r2, #1
 972 00b8 1A60     		str	r2, [r3, #0]
 973 00ba 05E0     		b	.L78
 974              	.L77:
1009:Source/queue.c **** 							}
1010:Source/queue.c **** 						}
1011:Source/queue.c **** 					}
1012:Source/queue.c **** 				}
1013:Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1014:Source/queue.c **** 			}
1015:Source/queue.c **** 			else
1016:Source/queue.c **** 			{
1017:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1018:Source/queue.c **** 				knows that data was posted while it was locked. */
1019:Source/queue.c **** 				++( pxQueue->xTxLock );
 975              		.loc 1 1019 0
 976 00bc BB69     		ldr	r3, [r7, #24]
 977 00be 9B6C     		ldr	r3, [r3, #72]
 978 00c0 03F10102 		add	r2, r3, #1
 979 00c4 BB69     		ldr	r3, [r7, #24]
 980 00c6 9A64     		str	r2, [r3, #72]
 981              	.L78:
1020:Source/queue.c **** 			}
1021:Source/queue.c **** 
1022:Source/queue.c **** 			xReturn = pdPASS;
 982              		.loc 1 1022 0
 983 00c8 4FF00103 		mov	r3, #1
 984 00cc FB61     		str	r3, [r7, #28]
 985 00ce 02E0     		b	.L79
 986              	.L76:
1023:Source/queue.c **** 		}
1024:Source/queue.c **** 		else
1025:Source/queue.c **** 		{
1026:Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1027:Source/queue.c **** 			xReturn = errQUEUE_FULL;
 987              		.loc 1 1027 0
 988 00d0 4FF00003 		mov	r3, #0
 989 00d4 FB61     		str	r3, [r7, #28]
 990              	.L79:
1028:Source/queue.c **** 		}
1029:Source/queue.c **** 	}
1030:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 991              		.loc 1 1030 0
 992 00d6 7869     		ldr	r0, [r7, #20]
 993 00d8 FFF7FEFF 		bl	vPortClearInterruptMask
1031:Source/queue.c **** 
1032:Source/queue.c **** 	return xReturn;
 994              		.loc 1 1032 0
 995 00dc FB69     		ldr	r3, [r7, #28]
1033:Source/queue.c **** }
 996              		.loc 1 1033 0
 997 00de 1846     		mov	r0, r3
 998 00e0 07F12007 		add	r7, r7, #32
 999 00e4 BD46     		mov	sp, r7
 1000 00e6 80BD     		pop	{r7, pc}
 1001              		.cfi_endproc
 1002              	.LFE117:
 1004              		.section	.text.xQueueGenericReceive,"ax",%progbits
 1005              		.align	2
 1006              		.global	xQueueGenericReceive
 1007              		.thumb
 1008              		.thumb_func
 1010              	xQueueGenericReceive:
 1011              	.LFB118:
1034:Source/queue.c **** /*-----------------------------------------------------------*/
1035:Source/queue.c **** 
1036:Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTi
1037:Source/queue.c **** {
 1012              		.loc 1 1037 0
 1013              		.cfi_startproc
 1014              		@ args = 0, pretend = 0, frame = 40
 1015              		@ frame_needed = 1, uses_anonymous_args = 0
 1016 0000 80B5     		push	{r7, lr}
 1017              	.LCFI24:
 1018              		.cfi_def_cfa_offset 8
 1019              		.cfi_offset 7, -8
 1020              		.cfi_offset 14, -4
 1021 0002 8AB0     		sub	sp, sp, #40
 1022              	.LCFI25:
 1023              		.cfi_def_cfa_offset 48
 1024 0004 00AF     		add	r7, sp, #0
 1025              	.LCFI26:
 1026              		.cfi_def_cfa_register 7
 1027 0006 F860     		str	r0, [r7, #12]
 1028 0008 B960     		str	r1, [r7, #8]
 1029 000a 7A60     		str	r2, [r7, #4]
 1030 000c 3B60     		str	r3, [r7, #0]
1038:Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 1031              		.loc 1 1038 0
 1032 000e 4FF00003 		mov	r3, #0
 1033 0012 7B62     		str	r3, [r7, #36]
1039:Source/queue.c **** xTimeOutType xTimeOut;
1040:Source/queue.c **** signed char *pcOriginalReadPosition;
1041:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1034              		.loc 1 1041 0
 1035 0014 FB68     		ldr	r3, [r7, #12]
 1036 0016 3B62     		str	r3, [r7, #32]
1042:Source/queue.c **** 
1043:Source/queue.c **** 	configASSERT( pxQueue );
 1037              		.loc 1 1043 0
 1038 0018 3B6A     		ldr	r3, [r7, #32]
 1039 001a 002B     		cmp	r3, #0
 1040 001c 02D1     		bne	.L82
 1041              		.loc 1 1043 0 is_stmt 0 discriminator 1
 1042 001e FFF7FEFF 		bl	ulPortSetInterruptMask
 1043              	.L83:
 1044              		.loc 1 1043 0 discriminator 2
 1045 0022 FEE7     		b	.L83
 1046              	.L82:
1044:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1047              		.loc 1 1044 0 is_stmt 1
 1048 0024 BB68     		ldr	r3, [r7, #8]
 1049 0026 002B     		cmp	r3, #0
 1050 0028 03D1     		bne	.L84
 1051              		.loc 1 1044 0 is_stmt 0 discriminator 2
 1052 002a 3B6A     		ldr	r3, [r7, #32]
 1053 002c 1B6C     		ldr	r3, [r3, #64]
 1054 002e 002B     		cmp	r3, #0
 1055 0030 02D1     		bne	.L85
 1056              	.L84:
 1057              		.loc 1 1044 0 discriminator 1
 1058 0032 4FF00103 		mov	r3, #1
 1059 0036 01E0     		b	.L86
 1060              	.L85:
 1061              		.loc 1 1044 0 discriminator 3
 1062 0038 4FF00003 		mov	r3, #0
 1063              	.L86:
 1064              		.loc 1 1044 0 discriminator 4
 1065 003c 002B     		cmp	r3, #0
 1066 003e 03D1     		bne	.L87
 1067              		.loc 1 1044 0 discriminator 5
 1068 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 1069              	.L88:
 1070              		.loc 1 1044 0 discriminator 6
 1071 0044 FEE7     		b	.L88
 1072              	.L103:
1045:Source/queue.c **** 
1046:Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1047:Source/queue.c **** 	statements within the function itself.  This is done in the interest
1048:Source/queue.c **** 	of execution time efficiency. */
1049:Source/queue.c **** 
1050:Source/queue.c **** 	for( ;; )
1051:Source/queue.c **** 	{
1052:Source/queue.c **** 		taskENTER_CRITICAL();
1053:Source/queue.c **** 		{
1054:Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
1055:Source/queue.c **** 			the highest priority task wanting to access the queue. */
1056:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1057:Source/queue.c **** 			{
1058:Source/queue.c **** 				/* Remember the read position in case the queue is only being
1059:Source/queue.c **** 				peeked. */
1060:Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
1061:Source/queue.c **** 
1062:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
1063:Source/queue.c **** 
1064:Source/queue.c **** 				if( xJustPeeking == pdFALSE )
1065:Source/queue.c **** 				{
1066:Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1067:Source/queue.c **** 
1068:Source/queue.c **** 					/* Actually removing data, not just peeking. */
1069:Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
1070:Source/queue.c **** 
1071:Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1072:Source/queue.c **** 					{
1073:Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1074:Source/queue.c **** 						{
1075:Source/queue.c **** 							/* Record the information required to implement
1076:Source/queue.c **** 							priority inheritance should it become necessary. */
1077:Source/queue.c **** 							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is
1078:Source/queue.c **** 						}
1079:Source/queue.c **** 					}
1080:Source/queue.c **** 					#endif
1081:Source/queue.c **** 
1082:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1083:Source/queue.c **** 					{
1084:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
1085:Source/queue.c **** 						{
1086:Source/queue.c **** 							portYIELD_WITHIN_API();
1087:Source/queue.c **** 						}
1088:Source/queue.c **** 					}
1089:Source/queue.c **** 				}
1090:Source/queue.c **** 				else
1091:Source/queue.c **** 				{
1092:Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1093:Source/queue.c **** 
1094:Source/queue.c **** 					/* The data is not being removed, so reset the read
1095:Source/queue.c **** 					pointer. */
1096:Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
1097:Source/queue.c **** 
1098:Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1099:Source/queue.c **** 					any other tasks waiting for the data. */
1100:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1101:Source/queue.c **** 					{
1102:Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
1103:Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
1104:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1105:Source/queue.c **** 						{
1106:Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1107:Source/queue.c **** 							portYIELD_WITHIN_API();
1108:Source/queue.c **** 						}
1109:Source/queue.c **** 					}
1110:Source/queue.c **** 				}
1111:Source/queue.c **** 
1112:Source/queue.c **** 				taskEXIT_CRITICAL();
1113:Source/queue.c **** 				return pdPASS;
1114:Source/queue.c **** 			}
1115:Source/queue.c **** 			else
1116:Source/queue.c **** 			{
1117:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
1118:Source/queue.c **** 				{
1119:Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1120:Source/queue.c **** 					the block time has expired) so leave now. */
1121:Source/queue.c **** 					taskEXIT_CRITICAL();
1122:Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1123:Source/queue.c **** 					return errQUEUE_EMPTY;
1124:Source/queue.c **** 				}
1125:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
1126:Source/queue.c **** 				{
1127:Source/queue.c **** 					/* The queue was empty and a block time was specified so
1128:Source/queue.c **** 					configure the timeout structure. */
1129:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
1130:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
1131:Source/queue.c **** 				}
1132:Source/queue.c **** 				else
1133:Source/queue.c **** 				{
1134:Source/queue.c **** 					/* Entry time was already set. */
1135:Source/queue.c **** 				}
1136:Source/queue.c **** 			}
1137:Source/queue.c **** 		}
1138:Source/queue.c **** 		taskEXIT_CRITICAL();
1139:Source/queue.c **** 
1140:Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1141:Source/queue.c **** 		now the critical section has been exited. */
1142:Source/queue.c **** 
1143:Source/queue.c **** 		vTaskSuspendAll();
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
1145:Source/queue.c **** 
1146:Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1147:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1148:Source/queue.c **** 		{
1149:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1150:Source/queue.c **** 			{
1151:Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1152:Source/queue.c **** 
1153:Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1154:Source/queue.c **** 				{
1155:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1156:Source/queue.c **** 					{
1157:Source/queue.c **** 						portENTER_CRITICAL();
1158:Source/queue.c **** 						{
1159:Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
1160:Source/queue.c **** 						}
1161:Source/queue.c **** 						portEXIT_CRITICAL();
1162:Source/queue.c **** 					}
1163:Source/queue.c **** 				}
1164:Source/queue.c **** 				#endif
1165:Source/queue.c **** 
1166:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1167:Source/queue.c **** 				prvUnlockQueue( pxQueue );
1168:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1169:Source/queue.c **** 				{
1170:Source/queue.c **** 					portYIELD_WITHIN_API();
1171:Source/queue.c **** 				}
1172:Source/queue.c **** 			}
1173:Source/queue.c **** 			else
1174:Source/queue.c **** 			{
1175:Source/queue.c **** 				/* Try again. */
1176:Source/queue.c **** 				prvUnlockQueue( pxQueue );
1177:Source/queue.c **** 				( void ) xTaskResumeAll();
1178:Source/queue.c **** 			}
1179:Source/queue.c **** 		}
1180:Source/queue.c **** 		else
1181:Source/queue.c **** 		{
1182:Source/queue.c **** 			prvUnlockQueue( pxQueue );
1183:Source/queue.c **** 			( void ) xTaskResumeAll();
1184:Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1185:Source/queue.c **** 			return errQUEUE_EMPTY;
1186:Source/queue.c **** 		}
1187:Source/queue.c **** 	}
 1073              		.loc 1 1187 0 is_stmt 1
 1074 0046 00BF     		nop
 1075              	.L87:
1052:Source/queue.c **** 		taskENTER_CRITICAL();
 1076              		.loc 1 1052 0
 1077 0048 FFF7FEFF 		bl	vPortEnterCritical
1056:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1078              		.loc 1 1056 0
 1079 004c 3B6A     		ldr	r3, [r7, #32]
 1080 004e 9B6B     		ldr	r3, [r3, #56]
 1081 0050 002B     		cmp	r3, #0
 1082 0052 3FD0     		beq	.L89
1060:Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1083              		.loc 1 1060 0
 1084 0054 3B6A     		ldr	r3, [r7, #32]
 1085 0056 DB68     		ldr	r3, [r3, #12]
 1086 0058 FB61     		str	r3, [r7, #28]
1062:Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1087              		.loc 1 1062 0
 1088 005a 386A     		ldr	r0, [r7, #32]
 1089 005c B968     		ldr	r1, [r7, #8]
 1090 005e FFF7FEFF 		bl	prvCopyDataFromQueue
1064:Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1091              		.loc 1 1064 0
 1092 0062 3B68     		ldr	r3, [r7, #0]
 1093 0064 002B     		cmp	r3, #0
 1094 0066 1ED1     		bne	.L90
1069:Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1095              		.loc 1 1069 0
 1096 0068 3B6A     		ldr	r3, [r7, #32]
 1097 006a 9B6B     		ldr	r3, [r3, #56]
 1098 006c 03F1FF32 		add	r2, r3, #-1
 1099 0070 3B6A     		ldr	r3, [r7, #32]
 1100 0072 9A63     		str	r2, [r3, #56]
1073:Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1101              		.loc 1 1073 0
 1102 0074 3B6A     		ldr	r3, [r7, #32]
 1103 0076 1B68     		ldr	r3, [r3, #0]
 1104 0078 002B     		cmp	r3, #0
 1105 007a 04D1     		bne	.L91
1077:Source/queue.c **** 							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is
 1106              		.loc 1 1077 0
 1107 007c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1108 0080 0246     		mov	r2, r0
 1109 0082 3B6A     		ldr	r3, [r7, #32]
 1110 0084 5A60     		str	r2, [r3, #4]
 1111              	.L91:
1082:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1112              		.loc 1 1082 0
 1113 0086 3B6A     		ldr	r3, [r7, #32]
 1114 0088 1B69     		ldr	r3, [r3, #16]
 1115 008a 002B     		cmp	r3, #0
 1116 008c 1DD0     		beq	.L92
1084:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1117              		.loc 1 1084 0
 1118 008e 3B6A     		ldr	r3, [r7, #32]
 1119 0090 03F11003 		add	r3, r3, #16
 1120 0094 1846     		mov	r0, r3
 1121 0096 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1122 009a 0346     		mov	r3, r0
 1123 009c 012B     		cmp	r3, #1
 1124 009e 14D1     		bne	.L92
1086:Source/queue.c **** 							portYIELD_WITHIN_API();
 1125              		.loc 1 1086 0
 1126 00a0 FFF7FEFF 		bl	vPortYield
 1127 00a4 11E0     		b	.L92
 1128              	.L90:
1096:Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1129              		.loc 1 1096 0
 1130 00a6 3B6A     		ldr	r3, [r7, #32]
 1131 00a8 FA69     		ldr	r2, [r7, #28]
 1132 00aa DA60     		str	r2, [r3, #12]
1100:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1133              		.loc 1 1100 0
 1134 00ac 3B6A     		ldr	r3, [r7, #32]
 1135 00ae 5B6A     		ldr	r3, [r3, #36]
 1136 00b0 002B     		cmp	r3, #0
 1137 00b2 0AD0     		beq	.L92
1104:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1138              		.loc 1 1104 0
 1139 00b4 3B6A     		ldr	r3, [r7, #32]
 1140 00b6 03F12403 		add	r3, r3, #36
 1141 00ba 1846     		mov	r0, r3
 1142 00bc FFF7FEFF 		bl	xTaskRemoveFromEventList
 1143 00c0 0346     		mov	r3, r0
 1144 00c2 002B     		cmp	r3, #0
 1145 00c4 01D0     		beq	.L92
1107:Source/queue.c **** 							portYIELD_WITHIN_API();
 1146              		.loc 1 1107 0
 1147 00c6 FFF7FEFF 		bl	vPortYield
 1148              	.L92:
1112:Source/queue.c **** 				taskEXIT_CRITICAL();
 1149              		.loc 1 1112 0
 1150 00ca FFF7FEFF 		bl	vPortExitCritical
1113:Source/queue.c **** 				return pdPASS;
 1151              		.loc 1 1113 0
 1152 00ce 4FF00103 		mov	r3, #1
 1153 00d2 6BE0     		b	.L102
 1154              	.L89:
1117:Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1155              		.loc 1 1117 0
 1156 00d4 7B68     		ldr	r3, [r7, #4]
 1157 00d6 002B     		cmp	r3, #0
 1158 00d8 04D1     		bne	.L94
1121:Source/queue.c **** 					taskEXIT_CRITICAL();
 1159              		.loc 1 1121 0
 1160 00da FFF7FEFF 		bl	vPortExitCritical
1123:Source/queue.c **** 					return errQUEUE_EMPTY;
 1161              		.loc 1 1123 0
 1162 00de 4FF00003 		mov	r3, #0
 1163 00e2 63E0     		b	.L102
 1164              	.L94:
1125:Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1165              		.loc 1 1125 0
 1166 00e4 7B6A     		ldr	r3, [r7, #36]
 1167 00e6 002B     		cmp	r3, #0
 1168 00e8 07D1     		bne	.L95
1129:Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1169              		.loc 1 1129 0
 1170 00ea 07F11403 		add	r3, r7, #20
 1171 00ee 1846     		mov	r0, r3
 1172 00f0 FFF7FEFF 		bl	vTaskSetTimeOutState
1130:Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1173              		.loc 1 1130 0
 1174 00f4 4FF00103 		mov	r3, #1
 1175 00f8 7B62     		str	r3, [r7, #36]
 1176              	.L95:
1138:Source/queue.c **** 		taskEXIT_CRITICAL();
 1177              		.loc 1 1138 0
 1178 00fa FFF7FEFF 		bl	vPortExitCritical
1143:Source/queue.c **** 		vTaskSuspendAll();
 1179              		.loc 1 1143 0
 1180 00fe FFF7FEFF 		bl	vTaskSuspendAll
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1181              		.loc 1 1144 0
 1182 0102 FFF7FEFF 		bl	vPortEnterCritical
 1183 0106 3B6A     		ldr	r3, [r7, #32]
 1184 0108 5B6C     		ldr	r3, [r3, #68]
 1185 010a B3F1FF3F 		cmp	r3, #-1
 1186 010e 03D1     		bne	.L96
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1187              		.loc 1 1144 0 is_stmt 0 discriminator 1
 1188 0110 3B6A     		ldr	r3, [r7, #32]
 1189 0112 4FF00002 		mov	r2, #0
 1190 0116 5A64     		str	r2, [r3, #68]
 1191              	.L96:
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1192              		.loc 1 1144 0 discriminator 2
 1193 0118 3B6A     		ldr	r3, [r7, #32]
 1194 011a 9B6C     		ldr	r3, [r3, #72]
 1195 011c B3F1FF3F 		cmp	r3, #-1
 1196 0120 03D1     		bne	.L97
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1197              		.loc 1 1144 0 discriminator 3
 1198 0122 3B6A     		ldr	r3, [r7, #32]
 1199 0124 4FF00002 		mov	r2, #0
 1200 0128 9A64     		str	r2, [r3, #72]
 1201              	.L97:
1144:Source/queue.c **** 		prvLockQueue( pxQueue );
 1202              		.loc 1 1144 0 discriminator 4
 1203 012a FFF7FEFF 		bl	vPortExitCritical
1147:Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1204              		.loc 1 1147 0 is_stmt 1 discriminator 4
 1205 012e 07F11402 		add	r2, r7, #20
 1206 0132 07F10403 		add	r3, r7, #4
 1207 0136 1046     		mov	r0, r2
 1208 0138 1946     		mov	r1, r3
 1209 013a FFF7FEFF 		bl	xTaskCheckForTimeOut
 1210 013e 0346     		mov	r3, r0
 1211 0140 002B     		cmp	r3, #0
 1212 0142 2CD1     		bne	.L98
1149:Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1213              		.loc 1 1149 0
 1214 0144 386A     		ldr	r0, [r7, #32]
 1215 0146 FFF7FEFF 		bl	prvIsQueueEmpty
 1216 014a 0346     		mov	r3, r0
 1217 014c 002B     		cmp	r3, #0
 1218 014e 20D0     		beq	.L99
1155:Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1219              		.loc 1 1155 0
 1220 0150 3B6A     		ldr	r3, [r7, #32]
 1221 0152 1B68     		ldr	r3, [r3, #0]
 1222 0154 002B     		cmp	r3, #0
 1223 0156 08D1     		bne	.L100
1157:Source/queue.c **** 						portENTER_CRITICAL();
 1224              		.loc 1 1157 0
 1225 0158 FFF7FEFF 		bl	vPortEnterCritical
1159:Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1226              		.loc 1 1159 0
 1227 015c 3B6A     		ldr	r3, [r7, #32]
 1228 015e 5B68     		ldr	r3, [r3, #4]
 1229 0160 1846     		mov	r0, r3
 1230 0162 FFF7FEFF 		bl	vTaskPriorityInherit
1161:Source/queue.c **** 						portEXIT_CRITICAL();
 1231              		.loc 1 1161 0
 1232 0166 FFF7FEFF 		bl	vPortExitCritical
 1233              	.L100:
1166:Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1234              		.loc 1 1166 0
 1235 016a 3B6A     		ldr	r3, [r7, #32]
 1236 016c 03F12402 		add	r2, r3, #36
 1237 0170 7B68     		ldr	r3, [r7, #4]
 1238 0172 1046     		mov	r0, r2
 1239 0174 1946     		mov	r1, r3
 1240 0176 FFF7FEFF 		bl	vTaskPlaceOnEventList
1167:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1241              		.loc 1 1167 0
 1242 017a 386A     		ldr	r0, [r7, #32]
 1243 017c FFF7FEFF 		bl	prvUnlockQueue
1168:Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1244              		.loc 1 1168 0
 1245 0180 FFF7FEFF 		bl	xTaskResumeAll
 1246 0184 0346     		mov	r3, r0
 1247 0186 002B     		cmp	r3, #0
 1248 0188 7FF45DAF 		bne	.L103
1170:Source/queue.c **** 					portYIELD_WITHIN_API();
 1249              		.loc 1 1170 0
 1250 018c FFF7FEFF 		bl	vPortYield
 1251              		.loc 1 1187 0
 1252 0190 59E7     		b	.L103
 1253              	.L99:
1176:Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1254              		.loc 1 1176 0
 1255 0192 386A     		ldr	r0, [r7, #32]
 1256 0194 FFF7FEFF 		bl	prvUnlockQueue
1177:Source/queue.c **** 				( void ) xTaskResumeAll();
 1257              		.loc 1 1177 0
 1258 0198 FFF7FEFF 		bl	xTaskResumeAll
 1259              		.loc 1 1187 0
 1260 019c 53E7     		b	.L103
 1261              	.L98:
1182:Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1262              		.loc 1 1182 0
 1263 019e 386A     		ldr	r0, [r7, #32]
 1264 01a0 FFF7FEFF 		bl	prvUnlockQueue
1183:Source/queue.c **** 			( void ) xTaskResumeAll();
 1265              		.loc 1 1183 0
 1266 01a4 FFF7FEFF 		bl	xTaskResumeAll
1185:Source/queue.c **** 			return errQUEUE_EMPTY;
 1267              		.loc 1 1185 0
 1268 01a8 4FF00003 		mov	r3, #0
 1269              	.L102:
1188:Source/queue.c **** }
 1270              		.loc 1 1188 0
 1271 01ac 1846     		mov	r0, r3
 1272 01ae 07F12807 		add	r7, r7, #40
 1273 01b2 BD46     		mov	sp, r7
 1274 01b4 80BD     		pop	{r7, pc}
 1275              		.cfi_endproc
 1276              	.LFE118:
 1278 01b6 00BF     		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1279              		.align	2
 1280              		.global	xQueueReceiveFromISR
 1281              		.thumb
 1282              		.thumb_func
 1284              	xQueueReceiveFromISR:
 1285              	.LFB119:
1189:Source/queue.c **** /*-----------------------------------------------------------*/
1190:Source/queue.c **** 
1191:Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed
1192:Source/queue.c **** {
 1286              		.loc 1 1192 0
 1287              		.cfi_startproc
 1288              		@ args = 0, pretend = 0, frame = 32
 1289              		@ frame_needed = 1, uses_anonymous_args = 0
 1290 0000 80B5     		push	{r7, lr}
 1291              	.LCFI27:
 1292              		.cfi_def_cfa_offset 8
 1293              		.cfi_offset 7, -8
 1294              		.cfi_offset 14, -4
 1295 0002 88B0     		sub	sp, sp, #32
 1296              	.LCFI28:
 1297              		.cfi_def_cfa_offset 40
 1298 0004 00AF     		add	r7, sp, #0
 1299              	.LCFI29:
 1300              		.cfi_def_cfa_register 7
 1301 0006 F860     		str	r0, [r7, #12]
 1302 0008 B960     		str	r1, [r7, #8]
 1303 000a 7A60     		str	r2, [r7, #4]
1193:Source/queue.c **** signed portBASE_TYPE xReturn;
1194:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1195:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1304              		.loc 1 1195 0
 1305 000c FB68     		ldr	r3, [r7, #12]
 1306 000e BB61     		str	r3, [r7, #24]
1196:Source/queue.c **** 
1197:Source/queue.c **** 	configASSERT( pxQueue );
 1307              		.loc 1 1197 0
 1308 0010 BB69     		ldr	r3, [r7, #24]
 1309 0012 002B     		cmp	r3, #0
 1310 0014 02D1     		bne	.L105
 1311              		.loc 1 1197 0 is_stmt 0 discriminator 1
 1312 0016 FFF7FEFF 		bl	ulPortSetInterruptMask
 1313              	.L106:
 1314              		.loc 1 1197 0 discriminator 2
 1315 001a FEE7     		b	.L106
 1316              	.L105:
1198:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1317              		.loc 1 1198 0 is_stmt 1
 1318 001c BB68     		ldr	r3, [r7, #8]
 1319 001e 002B     		cmp	r3, #0
 1320 0020 03D1     		bne	.L107
 1321              		.loc 1 1198 0 is_stmt 0 discriminator 2
 1322 0022 BB69     		ldr	r3, [r7, #24]
 1323 0024 1B6C     		ldr	r3, [r3, #64]
 1324 0026 002B     		cmp	r3, #0
 1325 0028 02D1     		bne	.L108
 1326              	.L107:
 1327              		.loc 1 1198 0 discriminator 1
 1328 002a 4FF00103 		mov	r3, #1
 1329 002e 01E0     		b	.L109
 1330              	.L108:
 1331              		.loc 1 1198 0 discriminator 3
 1332 0030 4FF00003 		mov	r3, #0
 1333              	.L109:
 1334              		.loc 1 1198 0 discriminator 4
 1335 0034 002B     		cmp	r3, #0
 1336 0036 02D1     		bne	.L110
 1337              		.loc 1 1198 0 discriminator 5
 1338 0038 FFF7FEFF 		bl	ulPortSetInterruptMask
 1339              	.L111:
 1340              		.loc 1 1198 0 discriminator 6
 1341 003c FEE7     		b	.L111
 1342              	.L110:
1199:Source/queue.c **** 
1200:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1201:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1202:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1203:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1204:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1205:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1206:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1207:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1208:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1209:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1210:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1211:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1212:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1213:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1214:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1343              		.loc 1 1214 0 is_stmt 1
 1344 003e FFF7FEFF 		bl	vPortValidateInterruptPriority
1215:Source/queue.c **** 
1216:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1345              		.loc 1 1216 0
 1346 0042 FFF7FEFF 		bl	ulPortSetInterruptMask
 1347 0046 7861     		str	r0, [r7, #20]
1217:Source/queue.c **** 	{
1218:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1219:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1348              		.loc 1 1219 0
 1349 0048 BB69     		ldr	r3, [r7, #24]
 1350 004a 9B6B     		ldr	r3, [r3, #56]
 1351 004c 002B     		cmp	r3, #0
 1352 004e 2DD0     		beq	.L112
1220:Source/queue.c **** 		{
1221:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1222:Source/queue.c **** 
1223:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1353              		.loc 1 1223 0
 1354 0050 B869     		ldr	r0, [r7, #24]
 1355 0052 B968     		ldr	r1, [r7, #8]
 1356 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
1224:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1357              		.loc 1 1224 0
 1358 0058 BB69     		ldr	r3, [r7, #24]
 1359 005a 9B6B     		ldr	r3, [r3, #56]
 1360 005c 03F1FF32 		add	r2, r3, #-1
 1361 0060 BB69     		ldr	r3, [r7, #24]
 1362 0062 9A63     		str	r2, [r3, #56]
1225:Source/queue.c **** 
1226:Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1227:Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1228:Source/queue.c **** 			will know that an ISR has removed data while the queue was
1229:Source/queue.c **** 			locked. */
1230:Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1363              		.loc 1 1230 0
 1364 0064 BB69     		ldr	r3, [r7, #24]
 1365 0066 5B6C     		ldr	r3, [r3, #68]
 1366 0068 B3F1FF3F 		cmp	r3, #-1
 1367 006c 14D1     		bne	.L113
1231:Source/queue.c **** 			{
1232:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1368              		.loc 1 1232 0
 1369 006e BB69     		ldr	r3, [r7, #24]
 1370 0070 1B69     		ldr	r3, [r3, #16]
 1371 0072 002B     		cmp	r3, #0
 1372 0074 16D0     		beq	.L114
1233:Source/queue.c **** 				{
1234:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1373              		.loc 1 1234 0
 1374 0076 BB69     		ldr	r3, [r7, #24]
 1375 0078 03F11003 		add	r3, r3, #16
 1376 007c 1846     		mov	r0, r3
 1377 007e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1378 0082 0346     		mov	r3, r0
 1379 0084 002B     		cmp	r3, #0
 1380 0086 0DD0     		beq	.L114
1235:Source/queue.c **** 					{
1236:Source/queue.c **** 						/* The task waiting has a higher priority than us so
1237:Source/queue.c **** 						force a context switch. */
1238:Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1381              		.loc 1 1238 0
 1382 0088 7B68     		ldr	r3, [r7, #4]
 1383 008a 002B     		cmp	r3, #0
 1384 008c 0AD0     		beq	.L114
1239:Source/queue.c **** 						{
1240:Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1385              		.loc 1 1240 0
 1386 008e 7B68     		ldr	r3, [r7, #4]
 1387 0090 4FF00102 		mov	r2, #1
 1388 0094 1A60     		str	r2, [r3, #0]
 1389 0096 05E0     		b	.L114
 1390              	.L113:
1241:Source/queue.c **** 						}
1242:Source/queue.c **** 					}
1243:Source/queue.c **** 				}
1244:Source/queue.c **** 			}
1245:Source/queue.c **** 			else
1246:Source/queue.c **** 			{
1247:Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1248:Source/queue.c **** 				knows that data was removed while it was locked. */
1249:Source/queue.c **** 				++( pxQueue->xRxLock );
 1391              		.loc 1 1249 0
 1392 0098 BB69     		ldr	r3, [r7, #24]
 1393 009a 5B6C     		ldr	r3, [r3, #68]
 1394 009c 03F10102 		add	r2, r3, #1
 1395 00a0 BB69     		ldr	r3, [r7, #24]
 1396 00a2 5A64     		str	r2, [r3, #68]
 1397              	.L114:
1250:Source/queue.c **** 			}
1251:Source/queue.c **** 
1252:Source/queue.c **** 			xReturn = pdPASS;
 1398              		.loc 1 1252 0
 1399 00a4 4FF00103 		mov	r3, #1
 1400 00a8 FB61     		str	r3, [r7, #28]
 1401 00aa 02E0     		b	.L115
 1402              	.L112:
1253:Source/queue.c **** 		}
1254:Source/queue.c **** 		else
1255:Source/queue.c **** 		{
1256:Source/queue.c **** 			xReturn = pdFAIL;
 1403              		.loc 1 1256 0
 1404 00ac 4FF00003 		mov	r3, #0
 1405 00b0 FB61     		str	r3, [r7, #28]
 1406              	.L115:
1257:Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1258:Source/queue.c **** 		}
1259:Source/queue.c **** 	}
1260:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1407              		.loc 1 1260 0
 1408 00b2 7869     		ldr	r0, [r7, #20]
 1409 00b4 FFF7FEFF 		bl	vPortClearInterruptMask
1261:Source/queue.c **** 
1262:Source/queue.c **** 	return xReturn;
 1410              		.loc 1 1262 0
 1411 00b8 FB69     		ldr	r3, [r7, #28]
1263:Source/queue.c **** }
 1412              		.loc 1 1263 0
 1413 00ba 1846     		mov	r0, r3
 1414 00bc 07F12007 		add	r7, r7, #32
 1415 00c0 BD46     		mov	sp, r7
 1416 00c2 80BD     		pop	{r7, pc}
 1417              		.cfi_endproc
 1418              	.LFE119:
 1420              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1421              		.align	2
 1422              		.global	xQueuePeekFromISR
 1423              		.thumb
 1424              		.thumb_func
 1426              	xQueuePeekFromISR:
 1427              	.LFB120:
1264:Source/queue.c **** /*-----------------------------------------------------------*/
1265:Source/queue.c **** 
1266:Source/queue.c **** signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
1267:Source/queue.c **** {
 1428              		.loc 1 1267 0
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 24
 1431              		@ frame_needed = 1, uses_anonymous_args = 0
 1432 0000 80B5     		push	{r7, lr}
 1433              	.LCFI30:
 1434              		.cfi_def_cfa_offset 8
 1435              		.cfi_offset 7, -8
 1436              		.cfi_offset 14, -4
 1437 0002 86B0     		sub	sp, sp, #24
 1438              	.LCFI31:
 1439              		.cfi_def_cfa_offset 32
 1440 0004 00AF     		add	r7, sp, #0
 1441              	.LCFI32:
 1442              		.cfi_def_cfa_register 7
 1443 0006 7860     		str	r0, [r7, #4]
 1444 0008 3960     		str	r1, [r7, #0]
1268:Source/queue.c **** signed portBASE_TYPE xReturn;
1269:Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1270:Source/queue.c **** signed char *pcOriginalReadPosition;
1271:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1445              		.loc 1 1271 0
 1446 000a 7B68     		ldr	r3, [r7, #4]
 1447 000c 3B61     		str	r3, [r7, #16]
1272:Source/queue.c **** 
1273:Source/queue.c **** 	configASSERT( pxQueue );
 1448              		.loc 1 1273 0
 1449 000e 3B69     		ldr	r3, [r7, #16]
 1450 0010 002B     		cmp	r3, #0
 1451 0012 02D1     		bne	.L118
 1452              		.loc 1 1273 0 is_stmt 0 discriminator 1
 1453 0014 FFF7FEFF 		bl	ulPortSetInterruptMask
 1454              	.L119:
 1455              		.loc 1 1273 0 discriminator 2
 1456 0018 FEE7     		b	.L119
 1457              	.L118:
1274:Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1458              		.loc 1 1274 0 is_stmt 1
 1459 001a 3B68     		ldr	r3, [r7, #0]
 1460 001c 002B     		cmp	r3, #0
 1461 001e 03D1     		bne	.L120
 1462              		.loc 1 1274 0 is_stmt 0 discriminator 2
 1463 0020 3B69     		ldr	r3, [r7, #16]
 1464 0022 1B6C     		ldr	r3, [r3, #64]
 1465 0024 002B     		cmp	r3, #0
 1466 0026 02D1     		bne	.L121
 1467              	.L120:
 1468              		.loc 1 1274 0 discriminator 1
 1469 0028 4FF00103 		mov	r3, #1
 1470 002c 01E0     		b	.L122
 1471              	.L121:
 1472              		.loc 1 1274 0 discriminator 3
 1473 002e 4FF00003 		mov	r3, #0
 1474              	.L122:
 1475              		.loc 1 1274 0 discriminator 4
 1476 0032 002B     		cmp	r3, #0
 1477 0034 02D1     		bne	.L123
 1478              		.loc 1 1274 0 discriminator 5
 1479 0036 FFF7FEFF 		bl	ulPortSetInterruptMask
 1480              	.L124:
 1481              		.loc 1 1274 0 discriminator 6
 1482 003a FEE7     		b	.L124
 1483              	.L123:
1275:Source/queue.c **** 
1276:Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1277:Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1278:Source/queue.c **** 	above the maximum system call priority are keep permanently enabled, even
1279:Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1280:Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1281:Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1282:Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1283:Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1284:Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1285:Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1286:Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1287:Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1288:Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1289:Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1290:Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1484              		.loc 1 1290 0 is_stmt 1
 1485 003c FFF7FEFF 		bl	vPortValidateInterruptPriority
1291:Source/queue.c **** 
1292:Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1486              		.loc 1 1292 0
 1487 0040 FFF7FEFF 		bl	ulPortSetInterruptMask
 1488 0044 F860     		str	r0, [r7, #12]
1293:Source/queue.c **** 	{
1294:Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1295:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1489              		.loc 1 1295 0
 1490 0046 3B69     		ldr	r3, [r7, #16]
 1491 0048 9B6B     		ldr	r3, [r3, #56]
 1492 004a 002B     		cmp	r3, #0
 1493 004c 0DD0     		beq	.L125
1296:Source/queue.c **** 		{
1297:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1298:Source/queue.c **** 
1299:Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1300:Source/queue.c **** 			actually being removed from the queue. */
1301:Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1494              		.loc 1 1301 0
 1495 004e 3B69     		ldr	r3, [r7, #16]
 1496 0050 DB68     		ldr	r3, [r3, #12]
 1497 0052 BB60     		str	r3, [r7, #8]
1302:Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1498              		.loc 1 1302 0
 1499 0054 3869     		ldr	r0, [r7, #16]
 1500 0056 3968     		ldr	r1, [r7, #0]
 1501 0058 FFF7FEFF 		bl	prvCopyDataFromQueue
1303:Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1502              		.loc 1 1303 0
 1503 005c 3B69     		ldr	r3, [r7, #16]
 1504 005e BA68     		ldr	r2, [r7, #8]
 1505 0060 DA60     		str	r2, [r3, #12]
1304:Source/queue.c **** 
1305:Source/queue.c **** 			xReturn = pdPASS;
 1506              		.loc 1 1305 0
 1507 0062 4FF00103 		mov	r3, #1
 1508 0066 7B61     		str	r3, [r7, #20]
 1509 0068 02E0     		b	.L126
 1510              	.L125:
1306:Source/queue.c **** 		}
1307:Source/queue.c **** 		else
1308:Source/queue.c **** 		{
1309:Source/queue.c **** 			xReturn = pdFAIL;
 1511              		.loc 1 1309 0
 1512 006a 4FF00003 		mov	r3, #0
 1513 006e 7B61     		str	r3, [r7, #20]
 1514              	.L126:
1310:Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1311:Source/queue.c **** 		}
1312:Source/queue.c **** 	}
1313:Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1515              		.loc 1 1313 0
 1516 0070 F868     		ldr	r0, [r7, #12]
 1517 0072 FFF7FEFF 		bl	vPortClearInterruptMask
1314:Source/queue.c **** 
1315:Source/queue.c **** 	return xReturn;
 1518              		.loc 1 1315 0
 1519 0076 7B69     		ldr	r3, [r7, #20]
1316:Source/queue.c **** }
 1520              		.loc 1 1316 0
 1521 0078 1846     		mov	r0, r3
 1522 007a 07F11807 		add	r7, r7, #24
 1523 007e BD46     		mov	sp, r7
 1524 0080 80BD     		pop	{r7, pc}
 1525              		.cfi_endproc
 1526              	.LFE120:
 1528 0082 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1529              		.align	2
 1530              		.global	uxQueueMessagesWaiting
 1531              		.thumb
 1532              		.thumb_func
 1534              	uxQueueMessagesWaiting:
 1535              	.LFB121:
1317:Source/queue.c **** /*-----------------------------------------------------------*/
1318:Source/queue.c **** 
1319:Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
1320:Source/queue.c **** {
 1536              		.loc 1 1320 0
 1537              		.cfi_startproc
 1538              		@ args = 0, pretend = 0, frame = 16
 1539              		@ frame_needed = 1, uses_anonymous_args = 0
 1540 0000 80B5     		push	{r7, lr}
 1541              	.LCFI33:
 1542              		.cfi_def_cfa_offset 8
 1543              		.cfi_offset 7, -8
 1544              		.cfi_offset 14, -4
 1545 0002 84B0     		sub	sp, sp, #16
 1546              	.LCFI34:
 1547              		.cfi_def_cfa_offset 24
 1548 0004 00AF     		add	r7, sp, #0
 1549              	.LCFI35:
 1550              		.cfi_def_cfa_register 7
 1551 0006 7860     		str	r0, [r7, #4]
1321:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1322:Source/queue.c **** 
1323:Source/queue.c **** 	configASSERT( xQueue );
 1552              		.loc 1 1323 0
 1553 0008 7B68     		ldr	r3, [r7, #4]
 1554 000a 002B     		cmp	r3, #0
 1555 000c 02D1     		bne	.L129
 1556              		.loc 1 1323 0 is_stmt 0 discriminator 1
 1557 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1558              	.L130:
 1559              		.loc 1 1323 0 discriminator 2
 1560 0012 FEE7     		b	.L130
 1561              	.L129:
1324:Source/queue.c **** 
1325:Source/queue.c **** 	taskENTER_CRITICAL();
 1562              		.loc 1 1325 0 is_stmt 1
 1563 0014 FFF7FEFF 		bl	vPortEnterCritical
1326:Source/queue.c **** 		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1564              		.loc 1 1326 0
 1565 0018 7B68     		ldr	r3, [r7, #4]
 1566 001a 9B6B     		ldr	r3, [r3, #56]
 1567 001c FB60     		str	r3, [r7, #12]
1327:Source/queue.c **** 	taskEXIT_CRITICAL();
 1568              		.loc 1 1327 0
 1569 001e FFF7FEFF 		bl	vPortExitCritical
1328:Source/queue.c **** 
1329:Source/queue.c **** 	return uxReturn;
 1570              		.loc 1 1329 0
 1571 0022 FB68     		ldr	r3, [r7, #12]
1330:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1572              		.loc 1 1330 0
 1573 0024 1846     		mov	r0, r3
 1574 0026 07F11007 		add	r7, r7, #16
 1575 002a BD46     		mov	sp, r7
 1576 002c 80BD     		pop	{r7, pc}
 1577              		.cfi_endproc
 1578              	.LFE121:
 1580 002e 00BF     		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1581              		.align	2
 1582              		.global	uxQueueSpacesAvailable
 1583              		.thumb
 1584              		.thumb_func
 1586              	uxQueueSpacesAvailable:
 1587              	.LFB122:
1331:Source/queue.c **** /*-----------------------------------------------------------*/
1332:Source/queue.c **** 
1333:Source/queue.c **** unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
1334:Source/queue.c **** {
 1588              		.loc 1 1334 0
 1589              		.cfi_startproc
 1590              		@ args = 0, pretend = 0, frame = 16
 1591              		@ frame_needed = 1, uses_anonymous_args = 0
 1592 0000 80B5     		push	{r7, lr}
 1593              	.LCFI36:
 1594              		.cfi_def_cfa_offset 8
 1595              		.cfi_offset 7, -8
 1596              		.cfi_offset 14, -4
 1597 0002 84B0     		sub	sp, sp, #16
 1598              	.LCFI37:
 1599              		.cfi_def_cfa_offset 24
 1600 0004 00AF     		add	r7, sp, #0
 1601              	.LCFI38:
 1602              		.cfi_def_cfa_register 7
 1603 0006 7860     		str	r0, [r7, #4]
1335:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1336:Source/queue.c **** xQUEUE *pxQueue;
1337:Source/queue.c **** 
1338:Source/queue.c **** 	pxQueue = ( xQUEUE * ) xQueue;
 1604              		.loc 1 1338 0
 1605 0008 7B68     		ldr	r3, [r7, #4]
 1606 000a FB60     		str	r3, [r7, #12]
1339:Source/queue.c **** 	configASSERT( pxQueue );
 1607              		.loc 1 1339 0
 1608 000c FB68     		ldr	r3, [r7, #12]
 1609 000e 002B     		cmp	r3, #0
 1610 0010 02D1     		bne	.L133
 1611              		.loc 1 1339 0 is_stmt 0 discriminator 1
 1612 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1613              	.L134:
 1614              		.loc 1 1339 0 discriminator 2
 1615 0016 FEE7     		b	.L134
 1616              	.L133:
1340:Source/queue.c **** 
1341:Source/queue.c **** 	taskENTER_CRITICAL();
 1617              		.loc 1 1341 0 is_stmt 1
 1618 0018 FFF7FEFF 		bl	vPortEnterCritical
1342:Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1619              		.loc 1 1342 0
 1620 001c FB68     		ldr	r3, [r7, #12]
 1621 001e DA6B     		ldr	r2, [r3, #60]
 1622 0020 FB68     		ldr	r3, [r7, #12]
 1623 0022 9B6B     		ldr	r3, [r3, #56]
 1624 0024 D31A     		subs	r3, r2, r3
 1625 0026 BB60     		str	r3, [r7, #8]
1343:Source/queue.c **** 	taskEXIT_CRITICAL();
 1626              		.loc 1 1343 0
 1627 0028 FFF7FEFF 		bl	vPortExitCritical
1344:Source/queue.c **** 
1345:Source/queue.c **** 	return uxReturn;
 1628              		.loc 1 1345 0
 1629 002c BB68     		ldr	r3, [r7, #8]
1346:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1630              		.loc 1 1346 0
 1631 002e 1846     		mov	r0, r3
 1632 0030 07F11007 		add	r7, r7, #16
 1633 0034 BD46     		mov	sp, r7
 1634 0036 80BD     		pop	{r7, pc}
 1635              		.cfi_endproc
 1636              	.LFE122:
 1638              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1639              		.align	2
 1640              		.global	uxQueueMessagesWaitingFromISR
 1641              		.thumb
 1642              		.thumb_func
 1644              	uxQueueMessagesWaitingFromISR:
 1645              	.LFB123:
1347:Source/queue.c **** /*-----------------------------------------------------------*/
1348:Source/queue.c **** 
1349:Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
1350:Source/queue.c **** {
 1646              		.loc 1 1350 0
 1647              		.cfi_startproc
 1648              		@ args = 0, pretend = 0, frame = 16
 1649              		@ frame_needed = 1, uses_anonymous_args = 0
 1650 0000 80B5     		push	{r7, lr}
 1651              	.LCFI39:
 1652              		.cfi_def_cfa_offset 8
 1653              		.cfi_offset 7, -8
 1654              		.cfi_offset 14, -4
 1655 0002 84B0     		sub	sp, sp, #16
 1656              	.LCFI40:
 1657              		.cfi_def_cfa_offset 24
 1658 0004 00AF     		add	r7, sp, #0
 1659              	.LCFI41:
 1660              		.cfi_def_cfa_register 7
 1661 0006 7860     		str	r0, [r7, #4]
1351:Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1352:Source/queue.c **** 
1353:Source/queue.c **** 	configASSERT( xQueue );
 1662              		.loc 1 1353 0
 1663 0008 7B68     		ldr	r3, [r7, #4]
 1664 000a 002B     		cmp	r3, #0
 1665 000c 02D1     		bne	.L137
 1666              		.loc 1 1353 0 is_stmt 0 discriminator 1
 1667 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 1668              	.L138:
 1669              		.loc 1 1353 0 discriminator 2
 1670 0012 FEE7     		b	.L138
 1671              	.L137:
1354:Source/queue.c **** 
1355:Source/queue.c **** 	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 1672              		.loc 1 1355 0 is_stmt 1
 1673 0014 7B68     		ldr	r3, [r7, #4]
 1674 0016 9B6B     		ldr	r3, [r3, #56]
 1675 0018 FB60     		str	r3, [r7, #12]
1356:Source/queue.c **** 
1357:Source/queue.c **** 	return uxReturn;
 1676              		.loc 1 1357 0
 1677 001a FB68     		ldr	r3, [r7, #12]
1358:Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1678              		.loc 1 1358 0
 1679 001c 1846     		mov	r0, r3
 1680 001e 07F11007 		add	r7, r7, #16
 1681 0022 BD46     		mov	sp, r7
 1682 0024 80BD     		pop	{r7, pc}
 1683              		.cfi_endproc
 1684              	.LFE123:
 1686 0026 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 1687              		.align	2
 1688              		.global	vQueueDelete
 1689              		.thumb
 1690              		.thumb_func
 1692              	vQueueDelete:
 1693              	.LFB124:
1359:Source/queue.c **** /*-----------------------------------------------------------*/
1360:Source/queue.c **** 
1361:Source/queue.c **** void vQueueDelete( xQueueHandle xQueue )
1362:Source/queue.c **** {
 1694              		.loc 1 1362 0
 1695              		.cfi_startproc
 1696              		@ args = 0, pretend = 0, frame = 16
 1697              		@ frame_needed = 1, uses_anonymous_args = 0
 1698 0000 80B5     		push	{r7, lr}
 1699              	.LCFI42:
 1700              		.cfi_def_cfa_offset 8
 1701              		.cfi_offset 7, -8
 1702              		.cfi_offset 14, -4
 1703 0002 84B0     		sub	sp, sp, #16
 1704              	.LCFI43:
 1705              		.cfi_def_cfa_offset 24
 1706 0004 00AF     		add	r7, sp, #0
 1707              	.LCFI44:
 1708              		.cfi_def_cfa_register 7
 1709 0006 7860     		str	r0, [r7, #4]
1363:Source/queue.c **** xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 1710              		.loc 1 1363 0
 1711 0008 7B68     		ldr	r3, [r7, #4]
 1712 000a FB60     		str	r3, [r7, #12]
1364:Source/queue.c **** 
1365:Source/queue.c **** 	configASSERT( pxQueue );
 1713              		.loc 1 1365 0
 1714 000c FB68     		ldr	r3, [r7, #12]
 1715 000e 002B     		cmp	r3, #0
 1716 0010 02D1     		bne	.L141
 1717              		.loc 1 1365 0 is_stmt 0 discriminator 1
 1718 0012 FFF7FEFF 		bl	ulPortSetInterruptMask
 1719              	.L142:
 1720              		.loc 1 1365 0 discriminator 2
 1721 0016 FEE7     		b	.L142
 1722              	.L141:
1366:Source/queue.c **** 
1367:Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1368:Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1369:Source/queue.c **** 	{
1370:Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1723              		.loc 1 1370 0 is_stmt 1
 1724 0018 F868     		ldr	r0, [r7, #12]
 1725 001a FFF7FEFF 		bl	vQueueUnregisterQueue
1371:Source/queue.c **** 	}
1372:Source/queue.c **** 	#endif
1373:Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 1726              		.loc 1 1373 0
 1727 001e FB68     		ldr	r3, [r7, #12]
 1728 0020 1B68     		ldr	r3, [r3, #0]
 1729 0022 1846     		mov	r0, r3
 1730 0024 FFF7FEFF 		bl	vPortFree
1374:Source/queue.c **** 	vPortFree( pxQueue );
 1731              		.loc 1 1374 0
 1732 0028 F868     		ldr	r0, [r7, #12]
 1733 002a FFF7FEFF 		bl	vPortFree
1375:Source/queue.c **** }
 1734              		.loc 1 1375 0
 1735 002e 07F11007 		add	r7, r7, #16
 1736 0032 BD46     		mov	sp, r7
 1737 0034 80BD     		pop	{r7, pc}
 1738              		.cfi_endproc
 1739              	.LFE124:
 1741 0036 00BF     		.section	.text.ucQueueGetQueueNumber,"ax",%progbits
 1742              		.align	2
 1743              		.global	ucQueueGetQueueNumber
 1744              		.thumb
 1745              		.thumb_func
 1747              	ucQueueGetQueueNumber:
 1748              	.LFB125:
1376:Source/queue.c **** /*-----------------------------------------------------------*/
1377:Source/queue.c **** 
1378:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1379:Source/queue.c **** 
1380:Source/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
1381:Source/queue.c **** 	{
 1749              		.loc 1 1381 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 8
 1752              		@ frame_needed = 1, uses_anonymous_args = 0
 1753              		@ link register save eliminated.
 1754 0000 80B4     		push	{r7}
 1755              	.LCFI45:
 1756              		.cfi_def_cfa_offset 4
 1757              		.cfi_offset 7, -4
 1758 0002 83B0     		sub	sp, sp, #12
 1759              	.LCFI46:
 1760              		.cfi_def_cfa_offset 16
 1761 0004 00AF     		add	r7, sp, #0
 1762              	.LCFI47:
 1763              		.cfi_def_cfa_register 7
 1764 0006 7860     		str	r0, [r7, #4]
1382:Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
 1765              		.loc 1 1382 0
 1766 0008 7B68     		ldr	r3, [r7, #4]
 1767 000a 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1383:Source/queue.c **** 	}
 1768              		.loc 1 1383 0
 1769 000e 1846     		mov	r0, r3
 1770 0010 07F10C07 		add	r7, r7, #12
 1771 0014 BD46     		mov	sp, r7
 1772 0016 80BC     		pop	{r7}
 1773 0018 7047     		bx	lr
 1774              		.cfi_endproc
 1775              	.LFE125:
 1777 001a 00BF     		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 1778              		.align	2
 1779              		.global	vQueueSetQueueNumber
 1780              		.thumb
 1781              		.thumb_func
 1783              	vQueueSetQueueNumber:
 1784              	.LFB126:
1384:Source/queue.c **** 
1385:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1386:Source/queue.c **** /*-----------------------------------------------------------*/
1387:Source/queue.c **** 
1388:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1389:Source/queue.c **** 
1390:Source/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
1391:Source/queue.c **** 	{
 1785              		.loc 1 1391 0
 1786              		.cfi_startproc
 1787              		@ args = 0, pretend = 0, frame = 8
 1788              		@ frame_needed = 1, uses_anonymous_args = 0
 1789              		@ link register save eliminated.
 1790 0000 80B4     		push	{r7}
 1791              	.LCFI48:
 1792              		.cfi_def_cfa_offset 4
 1793              		.cfi_offset 7, -4
 1794 0002 83B0     		sub	sp, sp, #12
 1795              	.LCFI49:
 1796              		.cfi_def_cfa_offset 16
 1797 0004 00AF     		add	r7, sp, #0
 1798              	.LCFI50:
 1799              		.cfi_def_cfa_register 7
 1800 0006 7860     		str	r0, [r7, #4]
 1801 0008 0B46     		mov	r3, r1
 1802 000a FB70     		strb	r3, [r7, #3]
1392:Source/queue.c **** 		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
 1803              		.loc 1 1392 0
 1804 000c 7B68     		ldr	r3, [r7, #4]
 1805 000e FA78     		ldrb	r2, [r7, #3]
 1806 0010 83F84C20 		strb	r2, [r3, #76]
1393:Source/queue.c **** 	}
 1807              		.loc 1 1393 0
 1808 0014 07F10C07 		add	r7, r7, #12
 1809 0018 BD46     		mov	sp, r7
 1810 001a 80BC     		pop	{r7}
 1811 001c 7047     		bx	lr
 1812              		.cfi_endproc
 1813              	.LFE126:
 1815 001e 00BF     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 1816              		.align	2
 1817              		.global	ucQueueGetQueueType
 1818              		.thumb
 1819              		.thumb_func
 1821              	ucQueueGetQueueType:
 1822              	.LFB127:
1394:Source/queue.c **** 
1395:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1396:Source/queue.c **** /*-----------------------------------------------------------*/
1397:Source/queue.c **** 
1398:Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1399:Source/queue.c **** 
1400:Source/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
1401:Source/queue.c **** 	{
 1823              		.loc 1 1401 0
 1824              		.cfi_startproc
 1825              		@ args = 0, pretend = 0, frame = 8
 1826              		@ frame_needed = 1, uses_anonymous_args = 0
 1827              		@ link register save eliminated.
 1828 0000 80B4     		push	{r7}
 1829              	.LCFI51:
 1830              		.cfi_def_cfa_offset 4
 1831              		.cfi_offset 7, -4
 1832 0002 83B0     		sub	sp, sp, #12
 1833              	.LCFI52:
 1834              		.cfi_def_cfa_offset 16
 1835 0004 00AF     		add	r7, sp, #0
 1836              	.LCFI53:
 1837              		.cfi_def_cfa_register 7
 1838 0006 7860     		str	r0, [r7, #4]
1402:Source/queue.c **** 		return ( ( xQUEUE * ) xQueue )->ucQueueType;
 1839              		.loc 1 1402 0
 1840 0008 7B68     		ldr	r3, [r7, #4]
 1841 000a 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1403:Source/queue.c **** 	}
 1842              		.loc 1 1403 0
 1843 000e 1846     		mov	r0, r3
 1844 0010 07F10C07 		add	r7, r7, #12
 1845 0014 BD46     		mov	sp, r7
 1846 0016 80BC     		pop	{r7}
 1847 0018 7047     		bx	lr
 1848              		.cfi_endproc
 1849              	.LFE127:
 1851 001a 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1852              		.align	2
 1853              		.thumb
 1854              		.thumb_func
 1856              	prvCopyDataToQueue:
 1857              	.LFB128:
1404:Source/queue.c **** 
1405:Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1406:Source/queue.c **** /*-----------------------------------------------------------*/
1407:Source/queue.c **** 
1408:Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1409:Source/queue.c **** {
 1858              		.loc 1 1409 0
 1859              		.cfi_startproc
 1860              		@ args = 0, pretend = 0, frame = 16
 1861              		@ frame_needed = 1, uses_anonymous_args = 0
 1862 0000 80B5     		push	{r7, lr}
 1863              	.LCFI54:
 1864              		.cfi_def_cfa_offset 8
 1865              		.cfi_offset 7, -8
 1866              		.cfi_offset 14, -4
 1867 0002 84B0     		sub	sp, sp, #16
 1868              	.LCFI55:
 1869              		.cfi_def_cfa_offset 24
 1870 0004 00AF     		add	r7, sp, #0
 1871              	.LCFI56:
 1872              		.cfi_def_cfa_register 7
 1873 0006 F860     		str	r0, [r7, #12]
 1874 0008 B960     		str	r1, [r7, #8]
 1875 000a 7A60     		str	r2, [r7, #4]
1410:Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1876              		.loc 1 1410 0
 1877 000c FB68     		ldr	r3, [r7, #12]
 1878 000e 1B6C     		ldr	r3, [r3, #64]
 1879 0010 002B     		cmp	r3, #0
 1880 0012 0DD1     		bne	.L149
1411:Source/queue.c **** 	{
1412:Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1413:Source/queue.c **** 		{
1414:Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1881              		.loc 1 1414 0
 1882 0014 FB68     		ldr	r3, [r7, #12]
 1883 0016 1B68     		ldr	r3, [r3, #0]
 1884 0018 002B     		cmp	r3, #0
 1885 001a 55D1     		bne	.L150
1415:Source/queue.c **** 			{
1416:Source/queue.c **** 				/* The mutex is no longer being held. */
1417:Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1886              		.loc 1 1417 0
 1887 001c FB68     		ldr	r3, [r7, #12]
 1888 001e 5B68     		ldr	r3, [r3, #4]
 1889 0020 1846     		mov	r0, r3
 1890 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1418:Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1891              		.loc 1 1418 0
 1892 0026 FB68     		ldr	r3, [r7, #12]
 1893 0028 4FF00002 		mov	r2, #0
 1894 002c 5A60     		str	r2, [r3, #4]
 1895 002e 4BE0     		b	.L150
 1896              	.L149:
1419:Source/queue.c **** 			}
1420:Source/queue.c **** 		}
1421:Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1422:Source/queue.c **** 	}
1423:Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1897              		.loc 1 1423 0
 1898 0030 7B68     		ldr	r3, [r7, #4]
 1899 0032 002B     		cmp	r3, #0
 1900 0034 1AD1     		bne	.L151
1424:Source/queue.c **** 	{
1425:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1901              		.loc 1 1425 0
 1902 0036 FB68     		ldr	r3, [r7, #12]
 1903 0038 9A68     		ldr	r2, [r3, #8]
 1904 003a FB68     		ldr	r3, [r7, #12]
 1905 003c 1B6C     		ldr	r3, [r3, #64]
 1906 003e 1046     		mov	r0, r2
 1907 0040 B968     		ldr	r1, [r7, #8]
 1908 0042 1A46     		mov	r2, r3
 1909 0044 FFF7FEFF 		bl	memcpy
1426:Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1910              		.loc 1 1426 0
 1911 0048 FB68     		ldr	r3, [r7, #12]
 1912 004a 9A68     		ldr	r2, [r3, #8]
 1913 004c FB68     		ldr	r3, [r7, #12]
 1914 004e 1B6C     		ldr	r3, [r3, #64]
 1915 0050 D218     		adds	r2, r2, r3
 1916 0052 FB68     		ldr	r3, [r7, #12]
 1917 0054 9A60     		str	r2, [r3, #8]
1427:Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1918              		.loc 1 1427 0
 1919 0056 FB68     		ldr	r3, [r7, #12]
 1920 0058 9A68     		ldr	r2, [r3, #8]
 1921 005a FB68     		ldr	r3, [r7, #12]
 1922 005c 5B68     		ldr	r3, [r3, #4]
 1923 005e 9A42     		cmp	r2, r3
 1924 0060 32D3     		bcc	.L150
1428:Source/queue.c **** 		{
1429:Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1925              		.loc 1 1429 0
 1926 0062 FB68     		ldr	r3, [r7, #12]
 1927 0064 1A68     		ldr	r2, [r3, #0]
 1928 0066 FB68     		ldr	r3, [r7, #12]
 1929 0068 9A60     		str	r2, [r3, #8]
 1930 006a 2DE0     		b	.L150
 1931              	.L151:
1430:Source/queue.c **** 		}
1431:Source/queue.c **** 	}
1432:Source/queue.c **** 	else
1433:Source/queue.c **** 	{
1434:Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 1932              		.loc 1 1434 0
 1933 006c FB68     		ldr	r3, [r7, #12]
 1934 006e DA68     		ldr	r2, [r3, #12]
 1935 0070 FB68     		ldr	r3, [r7, #12]
 1936 0072 1B6C     		ldr	r3, [r3, #64]
 1937 0074 1046     		mov	r0, r2
 1938 0076 B968     		ldr	r1, [r7, #8]
 1939 0078 1A46     		mov	r2, r3
 1940 007a FFF7FEFF 		bl	memcpy
1435:Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1941              		.loc 1 1435 0
 1942 007e FB68     		ldr	r3, [r7, #12]
 1943 0080 DA68     		ldr	r2, [r3, #12]
 1944 0082 FB68     		ldr	r3, [r7, #12]
 1945 0084 1B6C     		ldr	r3, [r3, #64]
 1946 0086 C3F10003 		rsb	r3, r3, #0
 1947 008a D218     		adds	r2, r2, r3
 1948 008c FB68     		ldr	r3, [r7, #12]
 1949 008e DA60     		str	r2, [r3, #12]
1436:Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1950              		.loc 1 1436 0
 1951 0090 FB68     		ldr	r3, [r7, #12]
 1952 0092 DA68     		ldr	r2, [r3, #12]
 1953 0094 FB68     		ldr	r3, [r7, #12]
 1954 0096 1B68     		ldr	r3, [r3, #0]
 1955 0098 9A42     		cmp	r2, r3
 1956 009a 08D2     		bcs	.L152
1437:Source/queue.c **** 		{
1438:Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1957              		.loc 1 1438 0
 1958 009c FB68     		ldr	r3, [r7, #12]
 1959 009e 5A68     		ldr	r2, [r3, #4]
 1960 00a0 FB68     		ldr	r3, [r7, #12]
 1961 00a2 1B6C     		ldr	r3, [r3, #64]
 1962 00a4 C3F10003 		rsb	r3, r3, #0
 1963 00a8 D218     		adds	r2, r2, r3
 1964 00aa FB68     		ldr	r3, [r7, #12]
 1965 00ac DA60     		str	r2, [r3, #12]
 1966              	.L152:
1439:Source/queue.c **** 		}
1440:Source/queue.c **** 
1441:Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 1967              		.loc 1 1441 0
 1968 00ae 7B68     		ldr	r3, [r7, #4]
 1969 00b0 022B     		cmp	r3, #2
 1970 00b2 09D1     		bne	.L150
1442:Source/queue.c **** 		{
1443:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1971              		.loc 1 1443 0
 1972 00b4 FB68     		ldr	r3, [r7, #12]
 1973 00b6 9B6B     		ldr	r3, [r3, #56]
 1974 00b8 002B     		cmp	r3, #0
 1975 00ba 05D0     		beq	.L150
1444:Source/queue.c **** 			{
1445:Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1446:Source/queue.c **** 				one from the recorded number of items in the queue so when
1447:Source/queue.c **** 				one is added again below the number of recorded items remains
1448:Source/queue.c **** 				correct. */
1449:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
 1976              		.loc 1 1449 0
 1977 00bc FB68     		ldr	r3, [r7, #12]
 1978 00be 9B6B     		ldr	r3, [r3, #56]
 1979 00c0 03F1FF32 		add	r2, r3, #-1
 1980 00c4 FB68     		ldr	r3, [r7, #12]
 1981 00c6 9A63     		str	r2, [r3, #56]
 1982              	.L150:
1450:Source/queue.c **** 			}
1451:Source/queue.c **** 		}
1452:Source/queue.c **** 	}
1453:Source/queue.c **** 
1454:Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1983              		.loc 1 1454 0
 1984 00c8 FB68     		ldr	r3, [r7, #12]
 1985 00ca 9B6B     		ldr	r3, [r3, #56]
 1986 00cc 03F10102 		add	r2, r3, #1
 1987 00d0 FB68     		ldr	r3, [r7, #12]
 1988 00d2 9A63     		str	r2, [r3, #56]
1455:Source/queue.c **** }
 1989              		.loc 1 1455 0
 1990 00d4 07F11007 		add	r7, r7, #16
 1991 00d8 BD46     		mov	sp, r7
 1992 00da 80BD     		pop	{r7, pc}
 1993              		.cfi_endproc
 1994              	.LFE128:
 1996              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1997              		.align	2
 1998              		.thumb
 1999              		.thumb_func
 2001              	prvCopyDataFromQueue:
 2002              	.LFB129:
1456:Source/queue.c **** /*-----------------------------------------------------------*/
1457:Source/queue.c **** 
1458:Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
1459:Source/queue.c **** {
 2003              		.loc 1 1459 0
 2004              		.cfi_startproc
 2005              		@ args = 0, pretend = 0, frame = 8
 2006              		@ frame_needed = 1, uses_anonymous_args = 0
 2007 0000 80B5     		push	{r7, lr}
 2008              	.LCFI57:
 2009              		.cfi_def_cfa_offset 8
 2010              		.cfi_offset 7, -8
 2011              		.cfi_offset 14, -4
 2012 0002 82B0     		sub	sp, sp, #8
 2013              	.LCFI58:
 2014              		.cfi_def_cfa_offset 16
 2015 0004 00AF     		add	r7, sp, #0
 2016              	.LCFI59:
 2017              		.cfi_def_cfa_register 7
 2018 0006 7860     		str	r0, [r7, #4]
 2019 0008 3960     		str	r1, [r7, #0]
1460:Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 2020              		.loc 1 1460 0
 2021 000a 7B68     		ldr	r3, [r7, #4]
 2022 000c 1B68     		ldr	r3, [r3, #0]
 2023 000e 002B     		cmp	r3, #0
 2024 0010 19D0     		beq	.L153
1461:Source/queue.c **** 	{
1462:Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2025              		.loc 1 1462 0
 2026 0012 7B68     		ldr	r3, [r7, #4]
 2027 0014 DA68     		ldr	r2, [r3, #12]
 2028 0016 7B68     		ldr	r3, [r7, #4]
 2029 0018 1B6C     		ldr	r3, [r3, #64]
 2030 001a D218     		adds	r2, r2, r3
 2031 001c 7B68     		ldr	r3, [r7, #4]
 2032 001e DA60     		str	r2, [r3, #12]
1463:Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2033              		.loc 1 1463 0
 2034 0020 7B68     		ldr	r3, [r7, #4]
 2035 0022 DA68     		ldr	r2, [r3, #12]
 2036 0024 7B68     		ldr	r3, [r7, #4]
 2037 0026 5B68     		ldr	r3, [r3, #4]
 2038 0028 9A42     		cmp	r2, r3
 2039 002a 03D3     		bcc	.L155
1464:Source/queue.c **** 		{
1465:Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2040              		.loc 1 1465 0
 2041 002c 7B68     		ldr	r3, [r7, #4]
 2042 002e 1A68     		ldr	r2, [r3, #0]
 2043 0030 7B68     		ldr	r3, [r7, #4]
 2044 0032 DA60     		str	r2, [r3, #12]
 2045              	.L155:
1466:Source/queue.c **** 		}
1467:Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2046              		.loc 1 1467 0
 2047 0034 7B68     		ldr	r3, [r7, #4]
 2048 0036 DA68     		ldr	r2, [r3, #12]
 2049 0038 7B68     		ldr	r3, [r7, #4]
 2050 003a 1B6C     		ldr	r3, [r3, #64]
 2051 003c 3868     		ldr	r0, [r7, #0]
 2052 003e 1146     		mov	r1, r2
 2053 0040 1A46     		mov	r2, r3
 2054 0042 FFF7FEFF 		bl	memcpy
 2055              	.L153:
1468:Source/queue.c **** 	}
1469:Source/queue.c **** }
 2056              		.loc 1 1469 0
 2057 0046 07F10807 		add	r7, r7, #8
 2058 004a BD46     		mov	sp, r7
 2059 004c 80BD     		pop	{r7, pc}
 2060              		.cfi_endproc
 2061              	.LFE129:
 2063 004e 00BF     		.section	.text.prvUnlockQueue,"ax",%progbits
 2064              		.align	2
 2065              		.thumb
 2066              		.thumb_func
 2068              	prvUnlockQueue:
 2069              	.LFB130:
1470:Source/queue.c **** /*-----------------------------------------------------------*/
1471:Source/queue.c **** 
1472:Source/queue.c **** static void prvUnlockQueue( xQUEUE *pxQueue )
1473:Source/queue.c **** {
 2070              		.loc 1 1473 0
 2071              		.cfi_startproc
 2072              		@ args = 0, pretend = 0, frame = 8
 2073              		@ frame_needed = 1, uses_anonymous_args = 0
 2074 0000 80B5     		push	{r7, lr}
 2075              	.LCFI60:
 2076              		.cfi_def_cfa_offset 8
 2077              		.cfi_offset 7, -8
 2078              		.cfi_offset 14, -4
 2079 0002 82B0     		sub	sp, sp, #8
 2080              	.LCFI61:
 2081              		.cfi_def_cfa_offset 16
 2082 0004 00AF     		add	r7, sp, #0
 2083              	.LCFI62:
 2084              		.cfi_def_cfa_register 7
 2085 0006 7860     		str	r0, [r7, #4]
1474:Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1475:Source/queue.c **** 
1476:Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1477:Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1478:Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1479:Source/queue.c **** 	updated. */
1480:Source/queue.c **** 	taskENTER_CRITICAL();
 2086              		.loc 1 1480 0
 2087 0008 FFF7FEFF 		bl	vPortEnterCritical
1481:Source/queue.c **** 	{
1482:Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1483:Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2088              		.loc 1 1483 0
 2089 000c 14E0     		b	.L157
 2090              	.L161:
1484:Source/queue.c **** 		{
1485:Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1486:Source/queue.c **** 			blocked waiting for data to become available? */
1487:Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1488:Source/queue.c **** 			{
1489:Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1490:Source/queue.c **** 				{
1491:Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1492:Source/queue.c **** 					{
1493:Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1494:Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1495:Source/queue.c **** 						A context switch is required. */
1496:Source/queue.c **** 						vTaskMissedYield();
1497:Source/queue.c **** 					}
1498:Source/queue.c **** 				}
1499:Source/queue.c **** 				else
1500:Source/queue.c **** 				{
1501:Source/queue.c **** 					/* Tasks that are removed from the event list will get added to
1502:Source/queue.c **** 					the pending ready list as the scheduler is still suspended. */
1503:Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1504:Source/queue.c **** 					{
1505:Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1506:Source/queue.c **** 						{
1507:Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1508:Source/queue.c **** 							context	switch is required. */
1509:Source/queue.c **** 							vTaskMissedYield();
1510:Source/queue.c **** 						}
1511:Source/queue.c **** 					}
1512:Source/queue.c **** 					else
1513:Source/queue.c **** 					{
1514:Source/queue.c **** 						break;
1515:Source/queue.c **** 					}
1516:Source/queue.c **** 				}
1517:Source/queue.c **** 			}
1518:Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1519:Source/queue.c **** 			{
1520:Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1521:Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1522:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2091              		.loc 1 1522 0
 2092 000e 7B68     		ldr	r3, [r7, #4]
 2093 0010 5B6A     		ldr	r3, [r3, #36]
 2094 0012 002B     		cmp	r3, #0
 2095 0014 15D0     		beq	.L167
1523:Source/queue.c **** 				{
1524:Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2096              		.loc 1 1524 0
 2097 0016 7B68     		ldr	r3, [r7, #4]
 2098 0018 03F12403 		add	r3, r3, #36
 2099 001c 1846     		mov	r0, r3
 2100 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2101 0022 0346     		mov	r3, r0
 2102 0024 002B     		cmp	r3, #0
 2103 0026 01D0     		beq	.L159
1525:Source/queue.c **** 					{
1526:Source/queue.c **** 						/* The task waiting has a higher priority so record that a
1527:Source/queue.c **** 						context	switch is required. */
1528:Source/queue.c **** 						vTaskMissedYield();
 2104              		.loc 1 1528 0
 2105 0028 FFF7FEFF 		bl	vTaskMissedYield
 2106              	.L159:
1529:Source/queue.c **** 					}
1530:Source/queue.c **** 				}
1531:Source/queue.c **** 				else
1532:Source/queue.c **** 				{
1533:Source/queue.c **** 					break;
1534:Source/queue.c **** 				}
1535:Source/queue.c **** 			}
1536:Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1537:Source/queue.c **** 
1538:Source/queue.c **** 			--( pxQueue->xTxLock );
 2107              		.loc 1 1538 0
 2108 002c 7B68     		ldr	r3, [r7, #4]
 2109 002e 9B6C     		ldr	r3, [r3, #72]
 2110 0030 03F1FF32 		add	r2, r3, #-1
 2111 0034 7B68     		ldr	r3, [r7, #4]
 2112 0036 9A64     		str	r2, [r3, #72]
 2113              	.L157:
1483:Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 2114              		.loc 1 1483 0 discriminator 1
 2115 0038 7B68     		ldr	r3, [r7, #4]
 2116 003a 9B6C     		ldr	r3, [r3, #72]
 2117 003c 002B     		cmp	r3, #0
 2118 003e E6DC     		bgt	.L161
 2119 0040 00E0     		b	.L160
 2120              	.L167:
1533:Source/queue.c **** 					break;
 2121              		.loc 1 1533 0
 2122 0042 00BF     		nop
 2123              	.L160:
1539:Source/queue.c **** 		}
1540:Source/queue.c **** 
1541:Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 2124              		.loc 1 1541 0
 2125 0044 7B68     		ldr	r3, [r7, #4]
 2126 0046 4FF0FF32 		mov	r2, #-1
 2127 004a 9A64     		str	r2, [r3, #72]
1542:Source/queue.c **** 	}
1543:Source/queue.c **** 	taskEXIT_CRITICAL();
 2128              		.loc 1 1543 0
 2129 004c FFF7FEFF 		bl	vPortExitCritical
1544:Source/queue.c **** 
1545:Source/queue.c **** 	/* Do the same for the Rx lock. */
1546:Source/queue.c **** 	taskENTER_CRITICAL();
 2130              		.loc 1 1546 0
 2131 0050 FFF7FEFF 		bl	vPortEnterCritical
1547:Source/queue.c **** 	{
1548:Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2132              		.loc 1 1548 0
 2133 0054 14E0     		b	.L162
 2134              	.L166:
1549:Source/queue.c **** 		{
1550:Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2135              		.loc 1 1550 0
 2136 0056 7B68     		ldr	r3, [r7, #4]
 2137 0058 1B69     		ldr	r3, [r3, #16]
 2138 005a 002B     		cmp	r3, #0
 2139 005c 15D0     		beq	.L168
1551:Source/queue.c **** 			{
1552:Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2140              		.loc 1 1552 0
 2141 005e 7B68     		ldr	r3, [r7, #4]
 2142 0060 03F11003 		add	r3, r3, #16
 2143 0064 1846     		mov	r0, r3
 2144 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2145 006a 0346     		mov	r3, r0
 2146 006c 002B     		cmp	r3, #0
 2147 006e 01D0     		beq	.L164
1553:Source/queue.c **** 				{
1554:Source/queue.c **** 					vTaskMissedYield();
 2148              		.loc 1 1554 0
 2149 0070 FFF7FEFF 		bl	vTaskMissedYield
 2150              	.L164:
1555:Source/queue.c **** 				}
1556:Source/queue.c **** 
1557:Source/queue.c **** 				--( pxQueue->xRxLock );
 2151              		.loc 1 1557 0
 2152 0074 7B68     		ldr	r3, [r7, #4]
 2153 0076 5B6C     		ldr	r3, [r3, #68]
 2154 0078 03F1FF32 		add	r2, r3, #-1
 2155 007c 7B68     		ldr	r3, [r7, #4]
 2156 007e 5A64     		str	r2, [r3, #68]
 2157              	.L162:
1548:Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 2158              		.loc 1 1548 0 discriminator 1
 2159 0080 7B68     		ldr	r3, [r7, #4]
 2160 0082 5B6C     		ldr	r3, [r3, #68]
 2161 0084 002B     		cmp	r3, #0
 2162 0086 E6DC     		bgt	.L166
 2163 0088 00E0     		b	.L165
 2164              	.L168:
1558:Source/queue.c **** 			}
1559:Source/queue.c **** 			else
1560:Source/queue.c **** 			{
1561:Source/queue.c **** 				break;
 2165              		.loc 1 1561 0
 2166 008a 00BF     		nop
 2167              	.L165:
1562:Source/queue.c **** 			}
1563:Source/queue.c **** 		}
1564:Source/queue.c **** 
1565:Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 2168              		.loc 1 1565 0
 2169 008c 7B68     		ldr	r3, [r7, #4]
 2170 008e 4FF0FF32 		mov	r2, #-1
 2171 0092 5A64     		str	r2, [r3, #68]
1566:Source/queue.c **** 	}
1567:Source/queue.c **** 	taskEXIT_CRITICAL();
 2172              		.loc 1 1567 0
 2173 0094 FFF7FEFF 		bl	vPortExitCritical
1568:Source/queue.c **** }
 2174              		.loc 1 1568 0
 2175 0098 07F10807 		add	r7, r7, #8
 2176 009c BD46     		mov	sp, r7
 2177 009e 80BD     		pop	{r7, pc}
 2178              		.cfi_endproc
 2179              	.LFE130:
 2181              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2182              		.align	2
 2183              		.thumb
 2184              		.thumb_func
 2186              	prvIsQueueEmpty:
 2187              	.LFB131:
1569:Source/queue.c **** /*-----------------------------------------------------------*/
1570:Source/queue.c **** 
1571:Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
1572:Source/queue.c **** {
 2188              		.loc 1 1572 0
 2189              		.cfi_startproc
 2190              		@ args = 0, pretend = 0, frame = 16
 2191              		@ frame_needed = 1, uses_anonymous_args = 0
 2192 0000 80B5     		push	{r7, lr}
 2193              	.LCFI63:
 2194              		.cfi_def_cfa_offset 8
 2195              		.cfi_offset 7, -8
 2196              		.cfi_offset 14, -4
 2197 0002 84B0     		sub	sp, sp, #16
 2198              	.LCFI64:
 2199              		.cfi_def_cfa_offset 24
 2200 0004 00AF     		add	r7, sp, #0
 2201              	.LCFI65:
 2202              		.cfi_def_cfa_register 7
 2203 0006 7860     		str	r0, [r7, #4]
1573:Source/queue.c **** signed portBASE_TYPE xReturn;
1574:Source/queue.c **** 
1575:Source/queue.c **** 	taskENTER_CRITICAL();
 2204              		.loc 1 1575 0
 2205 0008 FFF7FEFF 		bl	vPortEnterCritical
1576:Source/queue.c **** 	{
1577:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 2206              		.loc 1 1577 0
 2207 000c 7B68     		ldr	r3, [r7, #4]
 2208 000e 9B6B     		ldr	r3, [r3, #56]
 2209 0010 002B     		cmp	r3, #0
 2210 0012 03D1     		bne	.L170
1578:Source/queue.c **** 		{
1579:Source/queue.c **** 			xReturn = pdTRUE;
 2211              		.loc 1 1579 0
 2212 0014 4FF00103 		mov	r3, #1
 2213 0018 FB60     		str	r3, [r7, #12]
 2214 001a 02E0     		b	.L171
 2215              	.L170:
1580:Source/queue.c **** 		}
1581:Source/queue.c **** 		else
1582:Source/queue.c **** 		{
1583:Source/queue.c **** 			xReturn = pdFALSE;
 2216              		.loc 1 1583 0
 2217 001c 4FF00003 		mov	r3, #0
 2218 0020 FB60     		str	r3, [r7, #12]
 2219              	.L171:
1584:Source/queue.c **** 		}
1585:Source/queue.c **** 	}
1586:Source/queue.c **** 	taskEXIT_CRITICAL();
 2220              		.loc 1 1586 0
 2221 0022 FFF7FEFF 		bl	vPortExitCritical
1587:Source/queue.c **** 
1588:Source/queue.c **** 	return xReturn;
 2222              		.loc 1 1588 0
 2223 0026 FB68     		ldr	r3, [r7, #12]
1589:Source/queue.c **** }
 2224              		.loc 1 1589 0
 2225 0028 1846     		mov	r0, r3
 2226 002a 07F11007 		add	r7, r7, #16
 2227 002e BD46     		mov	sp, r7
 2228 0030 80BD     		pop	{r7, pc}
 2229              		.cfi_endproc
 2230              	.LFE131:
 2232 0032 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2233              		.align	2
 2234              		.global	xQueueIsQueueEmptyFromISR
 2235              		.thumb
 2236              		.thumb_func
 2238              	xQueueIsQueueEmptyFromISR:
 2239              	.LFB132:
1590:Source/queue.c **** /*-----------------------------------------------------------*/
1591:Source/queue.c **** 
1592:Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
1593:Source/queue.c **** {
 2240              		.loc 1 1593 0
 2241              		.cfi_startproc
 2242              		@ args = 0, pretend = 0, frame = 16
 2243              		@ frame_needed = 1, uses_anonymous_args = 0
 2244 0000 80B5     		push	{r7, lr}
 2245              	.LCFI66:
 2246              		.cfi_def_cfa_offset 8
 2247              		.cfi_offset 7, -8
 2248              		.cfi_offset 14, -4
 2249 0002 84B0     		sub	sp, sp, #16
 2250              	.LCFI67:
 2251              		.cfi_def_cfa_offset 24
 2252 0004 00AF     		add	r7, sp, #0
 2253              	.LCFI68:
 2254              		.cfi_def_cfa_register 7
 2255 0006 7860     		str	r0, [r7, #4]
1594:Source/queue.c **** signed portBASE_TYPE xReturn;
1595:Source/queue.c **** 
1596:Source/queue.c **** 	configASSERT( xQueue );
 2256              		.loc 1 1596 0
 2257 0008 7B68     		ldr	r3, [r7, #4]
 2258 000a 002B     		cmp	r3, #0
 2259 000c 02D1     		bne	.L174
 2260              		.loc 1 1596 0 is_stmt 0 discriminator 1
 2261 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2262              	.L175:
 2263              		.loc 1 1596 0 discriminator 2
 2264 0012 FEE7     		b	.L175
 2265              	.L174:
1597:Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 2266              		.loc 1 1597 0 is_stmt 1
 2267 0014 7B68     		ldr	r3, [r7, #4]
 2268 0016 9B6B     		ldr	r3, [r3, #56]
 2269 0018 002B     		cmp	r3, #0
 2270 001a 03D1     		bne	.L176
1598:Source/queue.c **** 	{
1599:Source/queue.c **** 		xReturn = pdTRUE;
 2271              		.loc 1 1599 0
 2272 001c 4FF00103 		mov	r3, #1
 2273 0020 FB60     		str	r3, [r7, #12]
 2274 0022 02E0     		b	.L177
 2275              	.L176:
1600:Source/queue.c **** 	}
1601:Source/queue.c **** 	else
1602:Source/queue.c **** 	{
1603:Source/queue.c **** 		xReturn = pdFALSE;
 2276              		.loc 1 1603 0
 2277 0024 4FF00003 		mov	r3, #0
 2278 0028 FB60     		str	r3, [r7, #12]
 2279              	.L177:
1604:Source/queue.c **** 	}
1605:Source/queue.c **** 
1606:Source/queue.c **** 	return xReturn;
 2280              		.loc 1 1606 0
 2281 002a FB68     		ldr	r3, [r7, #12]
1607:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2282              		.loc 1 1607 0
 2283 002c 1846     		mov	r0, r3
 2284 002e 07F11007 		add	r7, r7, #16
 2285 0032 BD46     		mov	sp, r7
 2286 0034 80BD     		pop	{r7, pc}
 2287              		.cfi_endproc
 2288              	.LFE132:
 2290 0036 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 2291              		.align	2
 2292              		.thumb
 2293              		.thumb_func
 2295              	prvIsQueueFull:
 2296              	.LFB133:
1608:Source/queue.c **** /*-----------------------------------------------------------*/
1609:Source/queue.c **** 
1610:Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
1611:Source/queue.c **** {
 2297              		.loc 1 1611 0
 2298              		.cfi_startproc
 2299              		@ args = 0, pretend = 0, frame = 16
 2300              		@ frame_needed = 1, uses_anonymous_args = 0
 2301 0000 80B5     		push	{r7, lr}
 2302              	.LCFI69:
 2303              		.cfi_def_cfa_offset 8
 2304              		.cfi_offset 7, -8
 2305              		.cfi_offset 14, -4
 2306 0002 84B0     		sub	sp, sp, #16
 2307              	.LCFI70:
 2308              		.cfi_def_cfa_offset 24
 2309 0004 00AF     		add	r7, sp, #0
 2310              	.LCFI71:
 2311              		.cfi_def_cfa_register 7
 2312 0006 7860     		str	r0, [r7, #4]
1612:Source/queue.c **** signed portBASE_TYPE xReturn;
1613:Source/queue.c **** 
1614:Source/queue.c **** 	taskENTER_CRITICAL();
 2313              		.loc 1 1614 0
 2314 0008 FFF7FEFF 		bl	vPortEnterCritical
1615:Source/queue.c **** 	{
1616:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2315              		.loc 1 1616 0
 2316 000c 7B68     		ldr	r3, [r7, #4]
 2317 000e 9A6B     		ldr	r2, [r3, #56]
 2318 0010 7B68     		ldr	r3, [r7, #4]
 2319 0012 DB6B     		ldr	r3, [r3, #60]
 2320 0014 9A42     		cmp	r2, r3
 2321 0016 03D1     		bne	.L180
1617:Source/queue.c **** 		{
1618:Source/queue.c **** 			xReturn = pdTRUE;
 2322              		.loc 1 1618 0
 2323 0018 4FF00103 		mov	r3, #1
 2324 001c FB60     		str	r3, [r7, #12]
 2325 001e 02E0     		b	.L181
 2326              	.L180:
1619:Source/queue.c **** 		}
1620:Source/queue.c **** 		else
1621:Source/queue.c **** 		{
1622:Source/queue.c **** 			xReturn = pdFALSE;
 2327              		.loc 1 1622 0
 2328 0020 4FF00003 		mov	r3, #0
 2329 0024 FB60     		str	r3, [r7, #12]
 2330              	.L181:
1623:Source/queue.c **** 		}
1624:Source/queue.c **** 	}
1625:Source/queue.c **** 	taskEXIT_CRITICAL();
 2331              		.loc 1 1625 0
 2332 0026 FFF7FEFF 		bl	vPortExitCritical
1626:Source/queue.c **** 
1627:Source/queue.c **** 	return xReturn;
 2333              		.loc 1 1627 0
 2334 002a FB68     		ldr	r3, [r7, #12]
1628:Source/queue.c **** }
 2335              		.loc 1 1628 0
 2336 002c 1846     		mov	r0, r3
 2337 002e 07F11007 		add	r7, r7, #16
 2338 0032 BD46     		mov	sp, r7
 2339 0034 80BD     		pop	{r7, pc}
 2340              		.cfi_endproc
 2341              	.LFE133:
 2343 0036 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2344              		.align	2
 2345              		.global	xQueueIsQueueFullFromISR
 2346              		.thumb
 2347              		.thumb_func
 2349              	xQueueIsQueueFullFromISR:
 2350              	.LFB134:
1629:Source/queue.c **** /*-----------------------------------------------------------*/
1630:Source/queue.c **** 
1631:Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
1632:Source/queue.c **** {
 2351              		.loc 1 1632 0
 2352              		.cfi_startproc
 2353              		@ args = 0, pretend = 0, frame = 16
 2354              		@ frame_needed = 1, uses_anonymous_args = 0
 2355 0000 80B5     		push	{r7, lr}
 2356              	.LCFI72:
 2357              		.cfi_def_cfa_offset 8
 2358              		.cfi_offset 7, -8
 2359              		.cfi_offset 14, -4
 2360 0002 84B0     		sub	sp, sp, #16
 2361              	.LCFI73:
 2362              		.cfi_def_cfa_offset 24
 2363 0004 00AF     		add	r7, sp, #0
 2364              	.LCFI74:
 2365              		.cfi_def_cfa_register 7
 2366 0006 7860     		str	r0, [r7, #4]
1633:Source/queue.c **** signed portBASE_TYPE xReturn;
1634:Source/queue.c **** 
1635:Source/queue.c **** 	configASSERT( xQueue );
 2367              		.loc 1 1635 0
 2368 0008 7B68     		ldr	r3, [r7, #4]
 2369 000a 002B     		cmp	r3, #0
 2370 000c 02D1     		bne	.L184
 2371              		.loc 1 1635 0 is_stmt 0 discriminator 1
 2372 000e FFF7FEFF 		bl	ulPortSetInterruptMask
 2373              	.L185:
 2374              		.loc 1 1635 0 discriminator 2
 2375 0012 FEE7     		b	.L185
 2376              	.L184:
1636:Source/queue.c **** 	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 2377              		.loc 1 1636 0 is_stmt 1
 2378 0014 7B68     		ldr	r3, [r7, #4]
 2379 0016 9A6B     		ldr	r2, [r3, #56]
 2380 0018 7B68     		ldr	r3, [r7, #4]
 2381 001a DB6B     		ldr	r3, [r3, #60]
 2382 001c 9A42     		cmp	r2, r3
 2383 001e 03D1     		bne	.L186
1637:Source/queue.c **** 	{
1638:Source/queue.c **** 		xReturn = pdTRUE;
 2384              		.loc 1 1638 0
 2385 0020 4FF00103 		mov	r3, #1
 2386 0024 FB60     		str	r3, [r7, #12]
 2387 0026 02E0     		b	.L187
 2388              	.L186:
1639:Source/queue.c **** 	}
1640:Source/queue.c **** 	else
1641:Source/queue.c **** 	{
1642:Source/queue.c **** 		xReturn = pdFALSE;
 2389              		.loc 1 1642 0
 2390 0028 4FF00003 		mov	r3, #0
 2391 002c FB60     		str	r3, [r7, #12]
 2392              	.L187:
1643:Source/queue.c **** 	}
1644:Source/queue.c **** 
1645:Source/queue.c **** 	return xReturn;
 2393              		.loc 1 1645 0
 2394 002e FB68     		ldr	r3, [r7, #12]
1646:Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2395              		.loc 1 1646 0
 2396 0030 1846     		mov	r0, r3
 2397 0032 07F11007 		add	r7, r7, #16
 2398 0036 BD46     		mov	sp, r7
 2399 0038 80BD     		pop	{r7, pc}
 2400              		.cfi_endproc
 2401              	.LFE134:
 2403 003a 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2404              		.align	2
 2405              		.global	vQueueAddToRegistry
 2406              		.thumb
 2407              		.thumb_func
 2409              	vQueueAddToRegistry:
 2410              	.LFB135:
1647:Source/queue.c **** /*-----------------------------------------------------------*/
1648:Source/queue.c **** 
1649:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1650:Source/queue.c **** 
1651:Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xT
1652:Source/queue.c **** 	{
1653:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1654:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1655:Source/queue.c **** 
1656:Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
1657:Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
1658:Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
1659:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1660:Source/queue.c **** 		{
1661:Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1662:Source/queue.c **** 			{
1663:Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
1664:Source/queue.c **** 				posting? */
1665:Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1666:Source/queue.c **** 				{
1667:Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
1668:Source/queue.c **** 					return indicating that we need to block. */
1669:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1670:Source/queue.c **** 					portENABLE_INTERRUPTS();
1671:Source/queue.c **** 					return errQUEUE_BLOCKED;
1672:Source/queue.c **** 				}
1673:Source/queue.c **** 				else
1674:Source/queue.c **** 				{
1675:Source/queue.c **** 					portENABLE_INTERRUPTS();
1676:Source/queue.c **** 					return errQUEUE_FULL;
1677:Source/queue.c **** 				}
1678:Source/queue.c **** 			}
1679:Source/queue.c **** 		}
1680:Source/queue.c **** 		portENABLE_INTERRUPTS();
1681:Source/queue.c **** 
1682:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1683:Source/queue.c **** 		{
1684:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1685:Source/queue.c **** 			{
1686:Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
1687:Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1688:Source/queue.c **** 				xReturn = pdPASS;
1689:Source/queue.c **** 
1690:Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
1691:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1692:Source/queue.c **** 				{
1693:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1694:Source/queue.c **** 					into the ready list as we are within a critical section.
1695:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1696:Source/queue.c **** 					the event were caused from within an interrupt. */
1697:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1698:Source/queue.c **** 					{
1699:Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
1700:Source/queue.c **** 						that a yield might be appropriate. */
1701:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1702:Source/queue.c **** 					}
1703:Source/queue.c **** 				}
1704:Source/queue.c **** 			}
1705:Source/queue.c **** 			else
1706:Source/queue.c **** 			{
1707:Source/queue.c **** 				xReturn = errQUEUE_FULL;
1708:Source/queue.c **** 			}
1709:Source/queue.c **** 		}
1710:Source/queue.c **** 		portENABLE_INTERRUPTS();
1711:Source/queue.c **** 
1712:Source/queue.c **** 		return xReturn;
1713:Source/queue.c **** 	}
1714:Source/queue.c **** 
1715:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1716:Source/queue.c **** /*-----------------------------------------------------------*/
1717:Source/queue.c **** 
1718:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1719:Source/queue.c **** 
1720:Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWa
1721:Source/queue.c **** 	{
1722:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1723:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1724:Source/queue.c **** 
1725:Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
1726:Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
1727:Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
1728:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1729:Source/queue.c **** 		{
1730:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1731:Source/queue.c **** 			{
1732:Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
1733:Source/queue.c **** 				leave with nothing? */
1734:Source/queue.c **** 				if( xTicksToWait > ( portTickType ) 0 )
1735:Source/queue.c **** 				{
1736:Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
1737:Source/queue.c **** 					indicating that we need to block. */
1738:Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1739:Source/queue.c **** 					portENABLE_INTERRUPTS();
1740:Source/queue.c **** 					return errQUEUE_BLOCKED;
1741:Source/queue.c **** 				}
1742:Source/queue.c **** 				else
1743:Source/queue.c **** 				{
1744:Source/queue.c **** 					portENABLE_INTERRUPTS();
1745:Source/queue.c **** 					return errQUEUE_FULL;
1746:Source/queue.c **** 				}
1747:Source/queue.c **** 			}
1748:Source/queue.c **** 		}
1749:Source/queue.c **** 		portENABLE_INTERRUPTS();
1750:Source/queue.c **** 
1751:Source/queue.c **** 		portDISABLE_INTERRUPTS();
1752:Source/queue.c **** 		{
1753:Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1754:Source/queue.c **** 			{
1755:Source/queue.c **** 				/* Data is available from the queue. */
1756:Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1757:Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1758:Source/queue.c **** 				{
1759:Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
1760:Source/queue.c **** 				}
1761:Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
1762:Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
1763:Source/queue.c **** 
1764:Source/queue.c **** 				xReturn = pdPASS;
1765:Source/queue.c **** 
1766:Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
1767:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1768:Source/queue.c **** 				{
1769:Source/queue.c **** 					/* In this instance the co-routine could be placed directly
1770:Source/queue.c **** 					into the ready list as we are within a critical section.
1771:Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
1772:Source/queue.c **** 					the event were caused from within an interrupt. */
1773:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1774:Source/queue.c **** 					{
1775:Source/queue.c **** 						xReturn = errQUEUE_YIELD;
1776:Source/queue.c **** 					}
1777:Source/queue.c **** 				}
1778:Source/queue.c **** 			}
1779:Source/queue.c **** 			else
1780:Source/queue.c **** 			{
1781:Source/queue.c **** 				xReturn = pdFAIL;
1782:Source/queue.c **** 			}
1783:Source/queue.c **** 		}
1784:Source/queue.c **** 		portENABLE_INTERRUPTS();
1785:Source/queue.c **** 
1786:Source/queue.c **** 		return xReturn;
1787:Source/queue.c **** 	}
1788:Source/queue.c **** 
1789:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1790:Source/queue.c **** /*-----------------------------------------------------------*/
1791:Source/queue.c **** 
1792:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1793:Source/queue.c **** 
1794:Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed p
1795:Source/queue.c **** 	{
1796:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1797:Source/queue.c **** 
1798:Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
1799:Source/queue.c **** 		exit without doing anything. */
1800:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1801:Source/queue.c **** 		{
1802:Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1803:Source/queue.c **** 
1804:Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
1805:Source/queue.c **** 			co-routine has not already been woken. */
1806:Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
1807:Source/queue.c **** 			{
1808:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1809:Source/queue.c **** 				{
1810:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1811:Source/queue.c **** 					{
1812:Source/queue.c **** 						return pdTRUE;
1813:Source/queue.c **** 					}
1814:Source/queue.c **** 				}
1815:Source/queue.c **** 			}
1816:Source/queue.c **** 		}
1817:Source/queue.c **** 
1818:Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
1819:Source/queue.c **** 	}
1820:Source/queue.c **** 
1821:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1822:Source/queue.c **** /*-----------------------------------------------------------*/
1823:Source/queue.c **** 
1824:Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1825:Source/queue.c **** 
1826:Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_
1827:Source/queue.c **** 	{
1828:Source/queue.c **** 	signed portBASE_TYPE xReturn;
1829:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
1830:Source/queue.c **** 
1831:Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
1832:Source/queue.c **** 		not then just leave without doing anything. */
1833:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1834:Source/queue.c **** 		{
1835:Source/queue.c **** 			/* Copy the data from the queue. */
1836:Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1837:Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
1838:Source/queue.c **** 			{
1839:Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
1840:Source/queue.c **** 			}
1841:Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1842:Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
1843:Source/queue.c **** 
1844:Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
1845:Source/queue.c **** 			{
1846:Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1847:Source/queue.c **** 				{
1848:Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1849:Source/queue.c **** 					{
1850:Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
1851:Source/queue.c **** 					}
1852:Source/queue.c **** 				}
1853:Source/queue.c **** 			}
1854:Source/queue.c **** 
1855:Source/queue.c **** 			xReturn = pdPASS;
1856:Source/queue.c **** 		}
1857:Source/queue.c **** 		else
1858:Source/queue.c **** 		{
1859:Source/queue.c **** 			xReturn = pdFAIL;
1860:Source/queue.c **** 		}
1861:Source/queue.c **** 
1862:Source/queue.c **** 		return xReturn;
1863:Source/queue.c **** 	}
1864:Source/queue.c **** 
1865:Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
1866:Source/queue.c **** /*-----------------------------------------------------------*/
1867:Source/queue.c **** 
1868:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1869:Source/queue.c **** 
1870:Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1871:Source/queue.c **** 	{
 2411              		.loc 1 1871 0
 2412              		.cfi_startproc
 2413              		@ args = 0, pretend = 0, frame = 16
 2414              		@ frame_needed = 1, uses_anonymous_args = 0
 2415              		@ link register save eliminated.
 2416 0000 80B4     		push	{r7}
 2417              	.LCFI75:
 2418              		.cfi_def_cfa_offset 4
 2419              		.cfi_offset 7, -4
 2420 0002 85B0     		sub	sp, sp, #20
 2421              	.LCFI76:
 2422              		.cfi_def_cfa_offset 24
 2423 0004 00AF     		add	r7, sp, #0
 2424              	.LCFI77:
 2425              		.cfi_def_cfa_register 7
 2426 0006 7860     		str	r0, [r7, #4]
 2427 0008 3960     		str	r1, [r7, #0]
1872:Source/queue.c **** 	unsigned portBASE_TYPE ux;
1873:Source/queue.c **** 
1874:Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1875:Source/queue.c **** 		a free slot. */
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2428              		.loc 1 1876 0
 2429 000a 4FF00003 		mov	r3, #0
 2430 000e FB60     		str	r3, [r7, #12]
 2431 0010 1FE0     		b	.L190
 2432              	.L193:
1877:Source/queue.c **** 		{
1878:Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2433              		.loc 1 1878 0
 2434 0012 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2435 0016 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2436 001a FA68     		ldr	r2, [r7, #12]
 2437 001c 53F83230 		ldr	r3, [r3, r2, lsl #3]
 2438 0020 002B     		cmp	r3, #0
 2439 0022 12D1     		bne	.L191
1879:Source/queue.c **** 			{
1880:Source/queue.c **** 				/* Store the information on this queue. */
1881:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2440              		.loc 1 1881 0
 2441 0024 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2442 0028 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2443 002c FA68     		ldr	r2, [r7, #12]
 2444 002e 3968     		ldr	r1, [r7, #0]
 2445 0030 43F83210 		str	r1, [r3, r2, lsl #3]
1882:Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2446              		.loc 1 1882 0
 2447 0034 40F20002 		movw	r2, #:lower16:xQueueRegistry
 2448 0038 C0F20002 		movt	r2, #:upper16:xQueueRegistry
 2449 003c FB68     		ldr	r3, [r7, #12]
 2450 003e 4FEAC303 		lsl	r3, r3, #3
 2451 0042 D318     		adds	r3, r2, r3
 2452 0044 7A68     		ldr	r2, [r7, #4]
 2453 0046 5A60     		str	r2, [r3, #4]
1883:Source/queue.c **** 				break;
 2454              		.loc 1 1883 0
 2455 0048 06E0     		b	.L189
 2456              	.L191:
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2457              		.loc 1 1876 0
 2458 004a FB68     		ldr	r3, [r7, #12]
 2459 004c 03F10103 		add	r3, r3, #1
 2460 0050 FB60     		str	r3, [r7, #12]
 2461              	.L190:
1876:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2462              		.loc 1 1876 0 is_stmt 0 discriminator 1
 2463 0052 FB68     		ldr	r3, [r7, #12]
 2464 0054 072B     		cmp	r3, #7
 2465 0056 DCD9     		bls	.L193
 2466              	.L189:
1884:Source/queue.c **** 			}
1885:Source/queue.c **** 		}
1886:Source/queue.c **** 	}
 2467              		.loc 1 1886 0 is_stmt 1
 2468 0058 07F11407 		add	r7, r7, #20
 2469 005c BD46     		mov	sp, r7
 2470 005e 80BC     		pop	{r7}
 2471 0060 7047     		bx	lr
 2472              		.cfi_endproc
 2473              	.LFE135:
 2475 0062 00BF     		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2476              		.align	2
 2477              		.global	vQueueUnregisterQueue
 2478              		.thumb
 2479              		.thumb_func
 2481              	vQueueUnregisterQueue:
 2482              	.LFB136:
1887:Source/queue.c **** 
1888:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1889:Source/queue.c **** /*-----------------------------------------------------------*/
1890:Source/queue.c **** 
1891:Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
1892:Source/queue.c **** 
1893:Source/queue.c **** 	void vQueueUnregisterQueue( xQueueHandle xQueue )
1894:Source/queue.c **** 	{
 2483              		.loc 1 1894 0
 2484              		.cfi_startproc
 2485              		@ args = 0, pretend = 0, frame = 16
 2486              		@ frame_needed = 1, uses_anonymous_args = 0
 2487              		@ link register save eliminated.
 2488 0000 80B4     		push	{r7}
 2489              	.LCFI78:
 2490              		.cfi_def_cfa_offset 4
 2491              		.cfi_offset 7, -4
 2492 0002 85B0     		sub	sp, sp, #20
 2493              	.LCFI79:
 2494              		.cfi_def_cfa_offset 24
 2495 0004 00AF     		add	r7, sp, #0
 2496              	.LCFI80:
 2497              		.cfi_def_cfa_register 7
 2498 0006 7860     		str	r0, [r7, #4]
1895:Source/queue.c **** 	unsigned portBASE_TYPE ux;
1896:Source/queue.c **** 
1897:Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1898:Source/queue.c **** 		registry. */
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2499              		.loc 1 1899 0
 2500 0008 4FF00003 		mov	r3, #0
 2501 000c FB60     		str	r3, [r7, #12]
 2502 000e 19E0     		b	.L195
 2503              	.L198:
1900:Source/queue.c **** 		{
1901:Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2504              		.loc 1 1901 0
 2505 0010 40F20002 		movw	r2, #:lower16:xQueueRegistry
 2506 0014 C0F20002 		movt	r2, #:upper16:xQueueRegistry
 2507 0018 FB68     		ldr	r3, [r7, #12]
 2508 001a 4FEAC303 		lsl	r3, r3, #3
 2509 001e D318     		adds	r3, r2, r3
 2510 0020 5A68     		ldr	r2, [r3, #4]
 2511 0022 7B68     		ldr	r3, [r7, #4]
 2512 0024 9A42     		cmp	r2, r3
 2513 0026 09D1     		bne	.L196
1902:Source/queue.c **** 			{
1903:Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1904:Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2514              		.loc 1 1904 0
 2515 0028 40F20003 		movw	r3, #:lower16:xQueueRegistry
 2516 002c C0F20003 		movt	r3, #:upper16:xQueueRegistry
 2517 0030 FA68     		ldr	r2, [r7, #12]
 2518 0032 4FF00001 		mov	r1, #0
 2519 0036 43F83210 		str	r1, [r3, r2, lsl #3]
1905:Source/queue.c **** 				break;
 2520              		.loc 1 1905 0
 2521 003a 06E0     		b	.L194
 2522              	.L196:
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2523              		.loc 1 1899 0
 2524 003c FB68     		ldr	r3, [r7, #12]
 2525 003e 03F10103 		add	r3, r3, #1
 2526 0042 FB60     		str	r3, [r7, #12]
 2527              	.L195:
1899:Source/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2528              		.loc 1 1899 0 is_stmt 0 discriminator 1
 2529 0044 FB68     		ldr	r3, [r7, #12]
 2530 0046 072B     		cmp	r3, #7
 2531 0048 E2D9     		bls	.L198
 2532              	.L194:
1906:Source/queue.c **** 			}
1907:Source/queue.c **** 		}
1908:Source/queue.c **** 
1909:Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2533              		.loc 1 1909 0 is_stmt 1
 2534 004a 07F11407 		add	r7, r7, #20
 2535 004e BD46     		mov	sp, r7
 2536 0050 80BC     		pop	{r7}
 2537 0052 7047     		bx	lr
 2538              		.cfi_endproc
 2539              	.LFE136:
 2541              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2542              		.align	2
 2543              		.global	vQueueWaitForMessageRestricted
 2544              		.thumb
 2545              		.thumb_func
 2547              	vQueueWaitForMessageRestricted:
 2548              	.LFB137:
1910:Source/queue.c **** 
1911:Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
1912:Source/queue.c **** /*-----------------------------------------------------------*/
1913:Source/queue.c **** 
1914:Source/queue.c **** #if ( configUSE_TIMERS == 1 )
1915:Source/queue.c **** 
1916:Source/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
1917:Source/queue.c **** 	{
 2549              		.loc 1 1917 0
 2550              		.cfi_startproc
 2551              		@ args = 0, pretend = 0, frame = 16
 2552              		@ frame_needed = 1, uses_anonymous_args = 0
 2553 0000 80B5     		push	{r7, lr}
 2554              	.LCFI81:
 2555              		.cfi_def_cfa_offset 8
 2556              		.cfi_offset 7, -8
 2557              		.cfi_offset 14, -4
 2558 0002 84B0     		sub	sp, sp, #16
 2559              	.LCFI82:
 2560              		.cfi_def_cfa_offset 24
 2561 0004 00AF     		add	r7, sp, #0
 2562              	.LCFI83:
 2563              		.cfi_def_cfa_register 7
 2564 0006 7860     		str	r0, [r7, #4]
 2565 0008 3960     		str	r1, [r7, #0]
1918:Source/queue.c **** 	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
 2566              		.loc 1 1918 0
 2567 000a 7B68     		ldr	r3, [r7, #4]
 2568 000c FB60     		str	r3, [r7, #12]
1919:Source/queue.c **** 
1920:Source/queue.c **** 		/* This function should not be called by application code hence the
1921:Source/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1922:Source/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1923:Source/queue.c **** 		It can result in vListInsert() being called on a list that can only
1924:Source/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1925:Source/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1926:Source/queue.c **** 		section. */
1927:Source/queue.c **** 
1928:Source/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1929:Source/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1930:Source/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1931:Source/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1932:Source/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1933:Source/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1934:Source/queue.c **** 		prvLockQueue( pxQueue );
 2569              		.loc 1 1934 0
 2570 000e FFF7FEFF 		bl	vPortEnterCritical
 2571 0012 FB68     		ldr	r3, [r7, #12]
 2572 0014 5B6C     		ldr	r3, [r3, #68]
 2573 0016 B3F1FF3F 		cmp	r3, #-1
 2574 001a 03D1     		bne	.L200
 2575              		.loc 1 1934 0 is_stmt 0 discriminator 1
 2576 001c FB68     		ldr	r3, [r7, #12]
 2577 001e 4FF00002 		mov	r2, #0
 2578 0022 5A64     		str	r2, [r3, #68]
 2579              	.L200:
 2580              		.loc 1 1934 0 discriminator 2
 2581 0024 FB68     		ldr	r3, [r7, #12]
 2582 0026 9B6C     		ldr	r3, [r3, #72]
 2583 0028 B3F1FF3F 		cmp	r3, #-1
 2584 002c 03D1     		bne	.L201
 2585              		.loc 1 1934 0 discriminator 3
 2586 002e FB68     		ldr	r3, [r7, #12]
 2587 0030 4FF00002 		mov	r2, #0
 2588 0034 9A64     		str	r2, [r3, #72]
 2589              	.L201:
 2590              		.loc 1 1934 0 discriminator 4
 2591 0036 FFF7FEFF 		bl	vPortExitCritical
1935:Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 2592              		.loc 1 1935 0 is_stmt 1 discriminator 4
 2593 003a FB68     		ldr	r3, [r7, #12]
 2594 003c 9B6B     		ldr	r3, [r3, #56]
 2595 003e 002B     		cmp	r3, #0
 2596 0040 06D1     		bne	.L202
1936:Source/queue.c **** 		{
1937:Source/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1938:Source/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2597              		.loc 1 1938 0
 2598 0042 FB68     		ldr	r3, [r7, #12]
 2599 0044 03F12403 		add	r3, r3, #36
 2600 0048 1846     		mov	r0, r3
 2601 004a 3968     		ldr	r1, [r7, #0]
 2602 004c FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 2603              	.L202:
1939:Source/queue.c **** 		}
1940:Source/queue.c **** 		prvUnlockQueue( pxQueue );
 2604              		.loc 1 1940 0
 2605 0050 F868     		ldr	r0, [r7, #12]
 2606 0052 FFF7FEFF 		bl	prvUnlockQueue
1941:Source/queue.c **** 	}
 2607              		.loc 1 1941 0
 2608 0056 07F11007 		add	r7, r7, #16
 2609 005a BD46     		mov	sp, r7
 2610 005c 80BD     		pop	{r7, pc}
 2611              		.cfi_endproc
 2612              	.LFE137:
 2614 005e 00BF     		.text
 2615              	.Letext0:
 2616              		.file 2 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 2617              		.file 3 "/home/thanhtruong/embedded-development/toolchain/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/
 2618              		.file 4 "Source/portable/GCC/ARM_CM4F/portmacro.h"
 2619              		.file 5 "Source/include/list.h"
 2620              		.file 6 "Source/include/task.h"
 2621              		.file 7 "Source/include/queue.h"
 2622              		.file 8 "App/STM32F4-Discovery/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000040 xQueueRegistry
     /tmp/cccTe46v.s:21     .text.xQueueGenericReset:00000000 $t
     /tmp/cccTe46v.s:26     .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/cccTe46v.s:146    .text.xQueueGenericCreate:00000000 $t
     /tmp/cccTe46v.s:151    .text.xQueueGenericCreate:00000000 xQueueGenericCreate
     /tmp/cccTe46v.s:250    .text.xQueueCreateMutex:00000000 $t
     /tmp/cccTe46v.s:255    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/cccTe46v.s:592    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/cccTe46v.s:360    .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/cccTe46v.s:365    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/cccTe46v.s:442    .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/cccTe46v.s:447    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/cccTe46v.s:1010   .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/cccTe46v.s:527    .text.xQueueCreateCountingSemaphore:00000000 $t
     /tmp/cccTe46v.s:532    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
     /tmp/cccTe46v.s:587    .text.xQueueGenericSend:00000000 $t
     /tmp/cccTe46v.s:1856   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/cccTe46v.s:2295   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/cccTe46v.s:2068   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/cccTe46v.s:834    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/cccTe46v.s:839    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/cccTe46v.s:1005   .text.xQueueGenericReceive:00000000 $t
     /tmp/cccTe46v.s:2001   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/cccTe46v.s:2186   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/cccTe46v.s:1279   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/cccTe46v.s:1284   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/cccTe46v.s:1421   .text.xQueuePeekFromISR:00000000 $t
     /tmp/cccTe46v.s:1426   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/cccTe46v.s:1529   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/cccTe46v.s:1534   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/cccTe46v.s:1581   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/cccTe46v.s:1586   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/cccTe46v.s:1639   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/cccTe46v.s:1644   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/cccTe46v.s:1687   .text.vQueueDelete:00000000 $t
     /tmp/cccTe46v.s:1692   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/cccTe46v.s:2481   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/cccTe46v.s:1742   .text.ucQueueGetQueueNumber:00000000 $t
     /tmp/cccTe46v.s:1747   .text.ucQueueGetQueueNumber:00000000 ucQueueGetQueueNumber
     /tmp/cccTe46v.s:1778   .text.vQueueSetQueueNumber:00000000 $t
     /tmp/cccTe46v.s:1783   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
     /tmp/cccTe46v.s:1816   .text.ucQueueGetQueueType:00000000 $t
     /tmp/cccTe46v.s:1821   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
     /tmp/cccTe46v.s:1852   .text.prvCopyDataToQueue:00000000 $t
     /tmp/cccTe46v.s:1997   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/cccTe46v.s:2064   .text.prvUnlockQueue:00000000 $t
     /tmp/cccTe46v.s:2182   .text.prvIsQueueEmpty:00000000 $t
     /tmp/cccTe46v.s:2233   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/cccTe46v.s:2238   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/cccTe46v.s:2291   .text.prvIsQueueFull:00000000 $t
     /tmp/cccTe46v.s:2344   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/cccTe46v.s:2349   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/cccTe46v.s:2404   .text.vQueueAddToRegistry:00000000 $t
     /tmp/cccTe46v.s:2409   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/cccTe46v.s:2476   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/cccTe46v.s:2542   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/cccTe46v.s:2547   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ulPortSetInterruptMask
vPortEnterCritical
xTaskRemoveFromEventList
vPortYield
vListInitialise
vPortExitCritical
pvPortMalloc
vPortFree
xTaskGetCurrentTaskHandle
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
vPortClearInterruptMask
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
